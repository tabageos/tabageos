(function() { 
		
	/** 
	* 
	* Load this file as part of your project in vscode, select it and scroll all the way down, leaving it open for a bit to be sure it is loaded.
	* When it is loaded, in your javascript files you have in the same project/workspace you will get tool tips and code completion for the tabageos library.
	*
	*
	*/
	
	/** 
	*
	* @class AISceneryThrower	
	* @classdesc   A TravelingSceneryThrower for platformers that is supposed to be computer controlled.
	*	 General use would be to construct it call setTarget, and then call .thinkAboutWhatToDo during a loop.    
	*
	* @constructor
	* 
	* @class AISceneryThrower
	* @param x {Number} x position of the AISceneryThrower
	* @param y {Number} y position of the AISceneryThrower
	* @param width {Number} width of the AISceneryThrower
	* @param height {Number} height of the AISceneryThrower
	* @param map {Array} collision map Array
	* @param [ca=null] {CanvasAnimation} Optional CanvasAnimation
	* @param [dontCloneMap=false] {Boolean} When true map will not be cloned, default is false, map is cloned by default.
	* @param [dt=.666666666667] {Number} Delta time, default is TimeKeeper._sae, change TimeKeeper._sae to effect all Travelers you use.
	* @param [tWidth] {Number} Tile width default is same as width
	* @param [tHeight] {Number} Tile height default is same as height
 	* @param [mr] {Number} amount of rows in map
	* @param [mc] {Number} amount of columns in map 
    *
    * @see TravelingSceneryThrower
	*  
	*/
    function AISceneryThrower(x,y,width,height, map, ca,dontCloneMap,dt,tWidth,tHeight,mr,mc) {
			tabageos.TravelerSkeleton.call(this, x, y, width, height);
			tabageos.MapTraveler.call(this,x,y,width,height, map,ca,dontCloneMap, dt, tWidth,tHeight, mr, mc);
			tabageos.TravelingSceneryThrower.call(this, x,y, width, height, map, ca, dontCloneMap, dt, tWidth, tHeight, mr, mc);
			this.width = width || 0;
			this.height = height || 0;
			this._middlePoint = new tabageos.MoverPoint();
			this._pos = new tabageos.MoverPoint(x,y);
			this._veloc = new tabageos.MoverPoint(0,0);
			this._lastVeloc = new tabageos.MoverPoint(0,0);
			this._lastPos = new tabageos.MoverPoint(x,y);
			this._deltaTime = dt || tabageos.TimeKeeper._sae;
			this._map = dontCloneMap ? map : tabageos.BlitMath.cloneMultiArray(map);
			this._state = 1;
			this.x = x || 0;
			this.y = y || 0;
			this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
			this._canvasAnimation = ca || null;
			this._tH = tHeight || this.height;
			this._tW = tWidth || this.width;
			this._outAltered = new tabageos.MoverPoint();
			this.holdingRect = new tabageos.Rectangle(0,0,width,height);
			this.holdingOffsetX = 1;
			this.holdingOffsetY = 3;
			this._jumps = 1;
			this.easeProximity = 7;
			this._checkHelper = new tabageos.MoverPoint();
			this.forceApplier = new tabageos.MoverPoint();
			this.forceHolder = new tabageos.MoverPoint();
			this._w = width || 0;
			this._h = height || 0;
			this.wanderOffset = new tabageos.MoverPoint(0,0);
			this.blankMO = new tabageos.MoverPoint();
			this._eventDispatcher = new tabageos.EventDispatcher();
			this.holdings = [];
			this._holdingHelperRect = new tabageos.Rectangle(0,0,0,0);
			this.personalSpace = this.width * 9;
			this._hpt = new tabageos.MoverPoint();
			this._jumpSpeed = 10;
			this.throwStrength = 10;
		};
   
    AISceneryThrower.prototype.constructor = AISceneryThrower;
		AISceneryThrower.prototype = Object.create(tabageos.TravelerSkeleton.prototype);
		Object.assign(AISceneryThrower.prototype, tabageos.MapTraveler.prototype, tabageos.TravelingSceneryThrower.prototype);
    /** 
	*   
	*    back up time, used by thinkAboutWhatToDo
	*    @type Number
	* @memberof AISceneryThrower
	*  
	*/
    AISceneryThrower.prototype.backUp = 300;
    /** 
	*   
	*    time of watching throw used during thinkAboutWhatToDo
	*    @type Number
	* @memberof AISceneryThrower 
	*  
	*/
    AISceneryThrower.prototype.watchingThrow = 750;
    /** 
	*   
	*    delay after an attack before another attack used during thinkAboutWhatToDo
	*    @type Number
	* @memberof AISceneryThrower  
	*  
	*/
    AISceneryThrower.prototype.afterAttackDelay = 750;
    /** 
	*   
	*    @private
	*    
	* @memberof AISceneryThrower  
	*  
	*/
    AISceneryThrower.prototype._hpt = null;
    /** 
	*   
	*    The MoverSkeleton target to try to hit with scenery.
	*    
	* @memberof AISceneryThrower  
	*  
	*/
    AISceneryThrower.prototype._target = null;
    /** 
	*   
	*    Sets _target
	*    
	* @memberof AISceneryThrower.prototype 
	* @method setTarget
	* @param t {MoverSkeleton} A MoverSkeleton or Object with x y width height.
    * 
	*/
    AISceneryThrower.prototype.setTarget = function(t) {
			this._target = t;
    };
	/** 
	*    
	*	 Determines the pick up method to use when picking up SceneryObjects
	*    1 for pickUpAndStore 0 for pickUp
	*    Those methods are inherited from TravelingSceneryThrower
	*    @type Number
	* @memberof AISceneryThrower  
	*  
	*/
    AISceneryThrower.prototype.pickUpMethodToUse = 1;
		
	/** 
	*   
	*    Determines the distance that the AISceneryThrower throws from and its throw strength.
	*    This method is called by walkJumpOrAttack which is called by thinkAboutWhatToDo.
	*    
	* @memberof AISceneryThrower.prototype  
	* @method smarts
	* @param level {Number} Level of smarts, 1 2 or 3.
	* @param [tw=16] {Number} Tile width, default is 16
	* @param [th=16] {Number} Tile height, default is 16
    * @returns {Boolean} Returns true if facing and close to the _target based on the smarts level.
	*/
    AISceneryThrower.prototype.smarts = function(level, tw, th) {
			
			var facing = ((this.x < this._target._pos.x && this._leftRightFace === 1) || (this.x > this._target._pos.x + (tw||16) && this._leftRightFace === 0) );
			
			if(!level || level <= 1) {
				this.personalSpace = this.width * 9;
				this.throwStrength = 10;
				return ( this.almostCloseTo(this._target._pos) &&  facing );
				
			}
			if(level && level == 2) {
				
				this.personalSpace = this.width * 4;
				this.throwStrength = 5;
				return ( this.almostCloseTo(this._target._pos) &&  facing );
			}
			if(level && level == 3) {
				
				this.personalSpace = this.width * 2;
				this.throwStrength = 3;
				return ( this.almostCloseTo(this._target._pos) &&  facing );
			}
		};
		
		
	/** 
	*   
	*    The main method of the class, causes the AISceneryThrower to first look for SceneryObjects and then pick one up and then try to hit the _target with it.
	*    
	* @memberof AISceneryThrower.prototype  
	* @method thinkAboutWhatToDo
	* @param sceneryArray {Array} The array that holds the SceneryObjects
	* @param sceneryMap {Array} The map that each SceneryObject is using.
	* @param sceneryCheck {Function} A method that dermines if a tile value is a SceneryObejct, it should take a tile value and return a Boolean.
	* @param sceneryRemoval {Function} A method that removes TileData from being displayed/drawn. It should take a TileData and clears the display of the TileData.
	* @param [tw=16] {Number} Tile width, default is 16
	* @param [th=16] {Number} Tile height default is 16
	* @param [smartness=1] {Number} 1 2 or 3, determines how far away the AISceneryThrower will throw from and its throw strength. Default is 1.
	* @param tileCheck {Function} A method that should determine if a tile value is solid/passible or not.
    * 
	*/
    AISceneryThrower.prototype.thinkAboutWhatToDo = function(sceneryArray, sceneryMap, sceneryCheck, sceneryRemoval, tw, th, smartness, tileCheck) {
			var td = tabageos.BlitMath.checkTileValueAt(Math.floor(this.x) , Math.floor(this.y) + (this.height/2), sceneryMap, tw || 16 , th || 16, this._hpt);
			
			if (!this.holding && this.watchingThrow >= this.afterAttackDelay) {
				if (!sceneryCheck(td)) { 
					var closeSceneryX = 0;
					var i = 0;var obj;
					for (i; i < sceneryArray.length; i++) {
						obj = sceneryArray[i]; closeSceneryX = obj.x+1-1;
						if(obj._grounded && tabageos.GeometricMath.testForPointInCircle(this._pos, 360, obj._pos) && obj.y >= this.y - (this.height/2)) {	
							closeSceneryX = obj.x+1-1; break;
						} 
					}
					
					if (closeSceneryX) {  
						var canr = this._leftRightFace === 1;
					
					
						var directioner = closeSceneryX > this.x && !this.pRight ? 0 : (closeSceneryX < this.x && !this.pLeft ? 1 : 0);
						
						this.walkOrJump(directioner, tw, th, closeSceneryX, tileCheck);  
						
						if(this.x >= (closeSceneryX - (tw ? tw : 16)) && this.x <= closeSceneryX + (tw || 16) && Math.abs(obj.y - this.y) <= (th||16)*2 ) {
							if(this.pickUpMethodToUse == 1) {
								this.pickUpAndStore(obj);
							} else {
								this.pickUp(obj);
							}
							sceneryArray.splice(sceneryArray.indexOf(obj),1);
						} else {
							//this.walkOrJump(directioner, tw, th, closeSceneryX, tileCheck);
							
						}
						
					} else {
						if(this._pRight) { 
							this.dX = this._pLeft ? 0 : 1;
						} else if (this._pLeft) {
							this.dX = 0;
						}
						
						this.walkOrJump(this.dX, tw, th,0,tileCheck);
					}
				} else {
					var mtd = tabageos.TileData.make(this._hpt.x * (tw||16) , this._hpt.y * (th||16) , td);
					this.pickUpTileData(mtd); 
					sceneryRemoval(mtd);
				}
			} else {
				
				
				var dd = this._target.x < this.x ? 1 : 0;
				
				
				this.walkJumpOrAttack(dd, tw, th, sceneryArray, smartness || 1,tileCheck);
			}
			
		};
	/** 
	*   
	*    Moves the AISceneryThrower to walk or jump if one tile is in the way.
	*    This method is used by thinkAboutWhatToDo.
	*    
	* @memberof AISceneryThrower.prototype  
	* @method walkOrJump
	* @param direc {Number} 1 for left, 0 for right.
	* @param [tw=16] {Number} Tile width, default is 16.
	* @param [th=16] {Number} Tile height, default is 16
	* @param closeSceneryX {Number} The x position of the closest SceneryObejct, this is calculated by thinkAboutWhatToDo
	* @param tileCheck {Function} A method that determines if a tile value is solid/passible or not.
    * 
	*/
    AISceneryThrower.prototype.walkOrJump = function(direc, tw, th, closeSceneryX, tileCheck) { 
		
			var td = tabageos.BlitMath.checkTileValueAt(this.x + (this._veloc.x >= 0  && (!closeSceneryX || closeSceneryX > this.x) ? (this.width*2) : -this.width), this.y + (this.height/2), this._map, tw || 16 , th || 16);
			var upperTd = tabageos.BlitMath.checkTileValueAt(this.x + (this._veloc.x >= 0  && (!closeSceneryX || closeSceneryX > this.x) ? (this.width*2) : -this.width), this.y - (this.height/2), this._map, tw || 16 , th || 16);
			
			var tile = tileCheck(td);
			var upTile = tileCheck(upperTd);
			
			if(!direc && this.pRight) {
				direc = 1;
			}
			if(direc && this.pLeft) {
				direc = 0;
			}
			if ( ( (tile) || !this._grounded || this.backUp > 250) && this.backUp < 1000 &&  (!upTile) ) {  
			
				
				this.jump(); this.backUp += 33.3; return;
			} else {
				if(this.backUp >= 1000) { this.walk(direc); }
				if ( (tile || upTile) ) {
					this.backUp = 300;
				}
			}
			
			if ( (tile) && this.backUp > 0) { 
				
				if(this.backUp != 300) {this.backUp = 300;} 
				this.backUp -= 33.3;  
				this.walk(direc); return;
			}
			if (this.backUp <= 0) {
				
				this.walk(direc); this.backUp = 300; return;
			} this.walk(direc);
			
		};
	/** 
	*   
	*    Causes the AISceneryThrower to move or jump or throw a SceneryObejct its holding.
	*    This method is used by thinkAboutWhatToDo.
	*    
	* @memberof AISceneryThrower.prototype  
	* @method walkJumpOrAttack
	* @param direc {Number} 1 for left, 0 for right.
	* @param tw {Number} Tile width
	* @param th {Number} Tile height
	* @param sceneryArray {Array} The Array holding the SceneryObejcts.
	* @param smartness {Number} 1 2 or 3, determines how far away the AISceneryThrower will throw from and its throw strength. Default is 1.
	* @param {Function} A method that should determine if a tile value is solid/passible or not.
    * 
	*/
    AISceneryThrower.prototype.walkJumpOrAttack = function(direc, tw, th, sceneryArray, smartness,tileCheck) { 
			if (this.watchingThrow < this.afterAttackDelay) {
				this.watchingThrow += 33.3;this.autoAnimation();
			} else { 
				var td = tabageos.BlitMath.checkTileValueAt(this.x + (this._veloc.x >= 1 ? (this.width*2) : -this.width), this.y + (this.height/2), this._map, tw || 16 , th || 16);
				var upperTd = tabageos.BlitMath.checkTileValueAt(this.x + (this._veloc.x >= 1 ? (this.width*2) : -this.width), this.y - (this.height/2), this._map, tw || 16 , th || 16);
				
				var tile = tileCheck(td);
				var upTile = tileCheck(upperTd);
				
				
				if(!direc && this.pRight) {
					direc = 1;
				}
				if(direc && this.pLeft) {
					direc = 0;
				}
				if ( ((tile) || !this._grounded || this.backUp > 300) && this.backUp < 1000 &&  (!upTile) ) {  
				
					
					this.jump(); this.backUp += 33.3; return;
				} else {
					if(this.backUp >= 1000) this.walk(direc);
					
				}
				
				
				if ( (tile) && this.backUp > 0) { 
					if(this.backUp > 300) {this.backUp = 300;} 
					this.backUp -= 33.3; this.walk(direc); return;
				}
				
				if ( this.smarts(smartness || 1, tw||16, th||16) ) {
					var aiobj;
					aiobj = this.pickUpMethodToUse == 1 ? this.removeLastFromStorage() : this.throwSceneryObjectTraveler(tw || 16, th || 16, 1);
					aiobj.xDirection = this._leftRightFace === 1 ? 1 : 0;
					aiobj._jumpSpeed = this.throwStrength +1-1;
					aiobj._fromEnemyAi = 1;
                    aiobj._walkSpeed = (Math.abs(this._veloc.x) >= this._walkSpeed ? 14 : 4);
					aiobj._veloc.y = -(Math.abs(this._veloc.x) < this._walkSpeed ? 2 : 3);aiobj._state = 3;
                    aiobj._solidSit = 0;aiobj._eHit = 0;aiobj._grounded = 0;
					sceneryArray.push(aiobj);
					
					this.autoAnimation();
					this.watchingThrow = 0; return;
				} this.walk(direc);
			}
			
		};
	/** 
	*   
	*    Causes the AISceneryThrower to move left or right.
	*    Used by thinkAboutWhatToDo.
	*    
	* @memberof AISceneryThrower.prototype  
	* @method walk
	* @param direc {Number} 1 for left, 0 for right.
    * 
	*/
    AISceneryThrower.prototype.walk = function(direc) {
			
			this.move(direc ? 1 : 0, direc ? 0 : 1, 0, 0);
    };
	/** 
	*   
	*    Causes the AISceneryThrower to move up.
	*    Used by thinkAboutWhatToDo.
	*    
	* @memberof AISceneryThrower.prototype  
	* @method jump
	* @param direc {Number}
    * 
	*/
    AISceneryThrower.prototype.jump = function(direc) {
			
			this.move(0,0,1,0);
    };
	tabageos.AISceneryThrower = AISceneryThrower;
})();

(function() { 

	'use strict';
    /** 
	*   Constructs a new BasicCamera, there should generally only be one camera, but it is not enforced.
	*    
	* @class BasicCamera
    * @classdesc 
    *
    *   A basic camera that will either render multiple CanvasObjects into one renderLayer,
	*    and/or just move the html canvas elements of each layer added.
    *
    * @constructor
	*
	* @param renderLayer {CanvasObject} The CanvasObject to draw all layers into.
	* @param blitLayer1 {CanvasObject}  The first offscreen CanvasObject layer to draw from onto the renderLayer
	* @param [blitLayer2] {CanvasObject}  The second CanvasObject layer
	* @param [blitLayer3] {CanvasObject}  The third CanvasObject layer
	* @param [blitLayer4] {CanvasObject}  The fourth CanvasObject layer
	* @param [blitLayer5] {CanvasObject}  The fifth CanvasObject layer, would get drawn on top of all the other layers.
	* @param vWidth {Number} The width of the cameras viewport
	* @param vHeight {Number} The height of the camera viewport
	* @param [constant1] {Number}  If not 0 or undefined, layer 1 will be moved instead of drawn into the render layer, for this you will need to be sure the html canvas of layer 1 is added as part of the html page.
	* @param [constant2] {Number}  If not 0 or undefined, layer 2 will be moved instead of drawn into the render layer, for this you will need to be sure the html canvas of layer 2 is added as part of the html page.
	* @param [constant3] {Number}  If not 0 or undefined, layer 3 will be moved instead of drawn into the render layer, for this you will need to be sure the html canvas of layer 3 is added as part of the html page.
	* @param [constant4] {Number}  If not 0 or undefined, layer 4 will be moved instead of drawn into the render layer, for this you will need to be sure the html canvas of layer 4 is added as part of the html page.
	* @param [constant5] {Number}  If not 0 or undefined, layer 5 will be moved instead of drawn into the render layer, for this you will need to be sure the html canvas of layer 5 is added as part of the html page.
	*  
	*/
    function BasicCamera(renderLayer, blitLayer1, blitLayer2, blitLayer3, blitLayer4, blitLayer5,vWidth,vHeight, constant1,constant2,constant3,constant4,constant5) {
        this.layerToRender = renderLayer;
        this.b1 = blitLayer1;
        this.b2 = blitLayer2;
        this.b3 = blitLayer3;
        this.b4 = blitLayer4;
        this.b5 = blitLayer5;
		this.c1 = constant1 || 0;
		this.c2 = constant2 || 0;
		this.c3 = constant3 || 0;
		this.c4 = constant4 || 0;
		this.c5 = constant5 || 0;
        this.tweens1 = [];
        this.tweens2 = [];
        this.p = new tabageos.MoverPoint();
        this.v = new tabageos.Rectangle(0,0);
        if (this.layerToRender) {
            this.v = new tabageos.Rectangle(0,0,this.layerToRender.width,this.layerToRender.height);
        }
        this.viewPortWidth = vWidth;
        this.viewPortHeight = vHeight;
		this._justMoveParallax = 0;
        this._isoPoint = new tabageos.MoverPoint();
		this._constantV = new tabageos.Rectangle(0,0,this.layerToRender.width, this.layerToRender.height);
    };
	/** 
	*   
	*    
	*    
	* @memberof BasicCamera
	*  
	*/
    BasicCamera.prototype.constructor = BasicCamera;
    BasicCamera.prototype = new Object();
	/** 
	*   
	*    The CanvasObject that will copy from each of the layers.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.layerToRender;
    /** 
	*   
	*    A reference to the CanvasObject that is layer 1.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.b1;
    /** 
	*   
	*     A reference to the CanvasObject that is layer 2.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.b2;
    /** 
	*   
	*     A reference to the CanvasObject that is layer 3.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.b3;
    /** 
	*   
	*     A reference to the CanvasObject that is layer 4.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.b4;
    /** 
	*   
	*     A reference to the CanvasObject that is layer 5.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.b5;
	/** 
	*   
	*     If 1, layer 1 will be moved instead of drawn.
	*    
	* @memberof BasicCamera
	*  
	*/
    BasicCamera.prototype.c1 = 0;
    /** 
	*    If 1, layer 2 will be moved instead of drawn.
	*    
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.c2 = 0;
    /** 
	*   
	*     If 1, layer 3 will be moved instead of drawn.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.c3 = 0;
    /** 
	*   
	*     If 1, layer 4 will be moved instead of drawn.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.c4 = 0;
    /** 
	*   
	*     If 1, layer 5 will be moved instead of drawn.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.c5 = 0;
    /** 
	*    The width of the cameras view port.
	*    
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.viewPortWidth;
    /** 
	*   
	*     The height of the cameras view port.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.viewPortHeight;
    /** 
	*   
	* @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.lastVXr = 0;
    /** 
	*   
	*  @private   
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.p;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.trsh = 0;
    /** 
	*   
	*  The view port Rectangle; the view port of the camera.
	*
	*  If a layer is being drawn, layerToRender is copying pixels from the layer using the view port x y width and height.
	*  The render methods, blitLayerRender, tweenedBlitLayerRender, and drag update v based on the parameters given to them,
	*  and then draw or move each layer.
	*    
	* @type Rectangle
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.v;
	/** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._constantV;
    /** 
	*   
	*    
	*    @private
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.tweens1 = [];
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.tweens2 = [];
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.lastvx = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.lastvy = 0;
    /** 
	*   
	*    
	*    @private
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.p1Tweens1 = [];
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.p1Tweens2 = [];
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.p2Tweens1 = [];
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.p2Tweens2 = [];
    /** 
	*   
	*    
	*    @private
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._pLayer1;
    /** 
	*   
	*    
	*    @private
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._pLayer2;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._pV1;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._pV2;
    /** 
	*   
	*    The type of tween for parallax layer one movement, default is Linear
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.pTweenType1 = "Linear";
    /** 
	*   
	*    The millisecond amount of time for parallax layer one movement
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.pTweenTime1 = 0;
    /** 
	*   
	*    The type of tween for parallax layer two movement.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.pTweenType2 = "Linear";
    /** 
	*   
	*    The millisecond amount of time for parallax layer two.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.pTweenTime2 = 0;
	/** 
	*   
	*    
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.pTween1XOffset = 2;
	/** 
	*   
	*    
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.pTween2XOffset = 4;
	/** 
	*   
	*    
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.pTween1YOffset = 1;
	/** 
	*   
	*    
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.pTween2YOffset = 1;
    /** 
	*   
	*    
	*    @private
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.pLastVs = {
        p1x: 0,
        p1y: 0,
        p2x: 0,
        p2y: 0
    };
    
    /** 
	*   Can be used with the .tweenedBlitLayerRender method to produce parallax effects.
	*
	* Only two layers can be added.
	* Layers will parallax based on .pTweenTime1 (or .pTweenTime2 for if you use 2 layers) or, a default of whatever you pass for tweentime in .tweenedBittLayerRender  multiplied by 2.
	*
	*  By default you just add a layer and it will move slower than the layers on top of it
	*  If you want to do more complex stuff, you would alter the .pTweenType1 and .pTweenTime1
	*    
	*    
	* @memberof BasicCamera.prototype 
	* @method addParallaxLayer
	* @param canvasObject {CanvasObject} The CanvasObject to add as a parallax layer
    * 
	*/
    BasicCamera.prototype.addParallaxLayer = function(canvasObject) {
        if (!this._pLayer1) {
            this._pLayer1 = canvasObject;
            this._pV1 = new tabageos.Rectangle(0,0,this._pLayer1.width,this._pLayer1.height);
        } else if (!this._pLayer2) {
            this._pLayer2 = canvasObject;
            this._pV2 = new tabageos.Rectangle(0,0,this._pLayer2.width,this._pLayer2.height);
        }
    };
	/** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._justMoveParallax = 0;
	/** 
	*   Same as addParallaxLayer except the layer added will be moved instead of drawn.
	*    When this method is used, any parallax layer already added will also just move instead of be drawn.
	*    And you need to be sure to have that layer as part of the things being displayed.
	*	Move just moves it, regular addParallaxLayer adds it to be  moved and drawn.
	*
	* @memberof BasicCamera.prototype  
	* @method addParallaxLayerForMove
	* @param canvasObejct {CanvasObject}
    * 
	*/
    BasicCamera.prototype.addParallaxLayerForMove = function(canvasObejct) {
		this._justMoveParallax = 1;
		this.addParallaxLayer(canvasObejct);
		
	};
    /** 
	*   
	*    the 2D Array to use during drawDirectlyFromMap
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._map = null;
	/** 
	*   
	*    the tileSheet to use during drawDirectlyFromMap
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._tileSheetImage = null;
	/** 
	*   
	*    Sets the 2D Array to use during drawDirectlyFromMap
	*    
	* @memberof BasicCamera.prototype  
	* @method setMap
	* @param toThis {Array} A 2D Array of tile values denoting where in a tileset to draw from.
    * 
	*/
    BasicCamera.prototype.setMap = function(toThis) {
		this._map = tabageos.BlitMath.cloneMultiArray(toThis);
	};    
	/** 
	*   
	*    Tile width of each tile used with drawDirectlyFromMap
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._tw = 16;
	/** 
	*   
	*    Tile height of each tile used with drawDirectlyFromMap
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._th = 16;
	/** 
	*   
	*    A function that determines the x index to draw from based on the value given.
    *    By default this will assume that the tile value is a [y,x] array, and will return a[1] by default for this method.
    *    To change what this method does override it by calling _mapIndexXMethod = function(a) { .. your details... returning index x }; 
	*    Used by setupForRenderFromMap
    *
	* @memberof BasicCamera.prototype  
	* @method _mapIndexXMethod
	* @param a {Object} The tile value
    * @returns {Number} The x index denoted by the tile value
	*/
    BasicCamera.prototype._mapIndexXMethod = function(a) {return a[1]};
	/** 
	*   
	*    A function that determines the y index to draw from based on the value given.
	*    By default this will assume that the tile value is a [y,x] array, and will return a[0] by default for this method.
    *    To change what this method does override it by calling _mapIndexXMethod = function(a) { .. your details... returning index y }; 
    *     Used by setupForRenderFromMap
    *
	* @memberof BasicCamera.prototype  
	* @method _mapIndexYMethod
	* @param a {Object} The tile value
    * @returns {Number} The y index denoted by the tile value 
	*/
    BasicCamera.prototype._mapIndexYMethod = function(a) {return a[0]};
    
    /** 
	*   
	*    setup a layer to be renedered directly from a 2D map array.
	* 
	*    
	* @memberof BasicCamera.prototype  
	* @method setupForRenderFromMap
	* @param map {Array} 2D map Array to use
	* @param tileSheetImg {Img} HTML img element or canvas element to draw from, sets the _tileSheetImage property of this class.
	* @param tw {Number} tile width
	* @param th {Number} tile height
	* @param layer {Number} The layer that will be rendered directly from the map. 1 2 3 4 or 5.
	* @param [vW] {Number} The view width for drawDirectlyFromMap calls, by default v.width will be used.
	* @param [vH] {Number} The view height for drawDirectlyFromMap calls, by default v.height will be used.
	* @param [indexXMethod] {Function} A method that will take a tile value and return its x index. by default it is assumed each tile value is a [y,x] index array.
	* @param [indexYMethod] {Function} A method that will take a tile value and return its y index. by default it is assumed that each tile value is a [y,x] index array.
    * 
	*/
    BasicCamera.prototype.setupForRenderFromMap = function(map, tileSheetImg, tw,th,layer, vW, vH, indexXMethod,indexYMethod) {
		this._map = map;
		this._tileSheetImage = tileSheetImg;
		this._tw = tw;
		this._th = th;
		this._mapIndexXMethod = indexXMethod || function(a) {return a[1]};
		this._mapIndexYMethod = indexYMethod || function(a) {return a[0]};
		
		if(vW) {
			this._vRenderWidth = vW;
		}
		if(vH) {
			this._vRenderHeight = vH;
		}
		
		if(laer) {
			if(laer == 1) {
				this.rfm1 = 1;
			}
			if(laer == 2) {
				this.rfm2 = 1;
			}
			if(laer == 3) {
				this.rfm3 = 1;
			}
			if(laer == 4) {
				this.rfm4 = 1;
			}
			if(laer == 5) {
				this.rfm5 = 1;
			}
		}
	};
    
    /** 
	*   
	*    A method to call when the end of _map is reached that would update _map.
    *    Used alongside the setupForRenderFromMap method
	*    
	* @memberof BasicCamera  
	*  
	*/
    BasicCamera.prototype.mapUpdateMethod = null;
	/** 
	*   
	*    Used during drawDirectlyFromMap if no _tileSheetImage has been set.
	*    
	* @memberof BasicCamera  
	*  
	*/
    BasicCamera.prototype.colorValues = {1:"#000000",2:"#000000",3:"#FFFFFF"};
    
    
    /** 
	*   
	*    Returns the view port Rectangle of the camera.
	*    
	* @memberof BasicCamera.prototype  
	* @method blitLayerRenderView
    * @returns {Rectangle} 
	*/
    BasicCamera.prototype.blitLayerRenderView = function() {
        return this.v;
    };
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera.prototype  
	* @method renderP1
    * @returns {} 
	*/
    BasicCamera.prototype.renderP1 = function() {
        if (this._pLayer1 && this._justMoveParallax == 0) {
            this.layerToRender.copyPixels(this._pLayer1.canvas, this._pV1, this.p, this._pV1.width, this._pV1.height);
        } else { //div containing pLayer1.canvas would need to have overflow set to hidden
			this._pLayer1.canvas.setAttribute("style", "position:absolute;z-index:-9;top:"+(-this._pV1.y)+"px;left:"+(-this._pV1.x)+"px;image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
		}
    };
    
    
    
    
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera.prototype  
	* @method renderP2
    * @returns {} 
	*/
    BasicCamera.prototype.renderP2 = function() {
        if (this._pLayer2 && this._justMoveParallax == 0) {
            this.layerToRender.copyPixels(this._pLayer2.canvas, this._pV2, this.p, this._pV2.width, this._pV2.height);
        } else {
			this._pLayer2.canvas.setAttribute("style", "position:absolute;z-index:-8;top:"+(-this._pV2.y)+"px;left:"+(-this._pV2.x)+"px;image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
		}
    };
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera.prototype  
	* @method renderB1
    * @returns {} 
	*/
    BasicCamera.prototype.renderB1 = function() {
        if (this.b1 && !this.c1) {
			if(this.rfm1 === 1) {
				this.drawDirectlyFromMap();
			} else {
				if(this.constantBackgroundFromRect) {
					this._cbRect.width = this.v.width;this._cbRect.height = this.v.height;
				}
				this.layerToRender.copyPixels(this.b1.canvas, this.constantBackgroundFromRect ? this._cbRect : this.v, this.p, this.v.width, this.v.height);
			}
		} else if ((this.b1 && this.c1) || this.b1ActualMover) { 
			if(this.b1ActualMover) {
				this.b1ActualMover.setAttribute("style", "position:absolute;z-index:-7;top:"+(-this.v.y)+"px;left:"+(-this.v.x)+"px;image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
			} else {
				this.b1.canvas.setAttribute("style", "position:absolute;z-index:-7;top:"+(-this.v.y)+"px;left:"+(-this.v.x)+"px;image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
			}
		}
    };
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera.prototype  
	* @method renderB2
    * @returns {} 
	*/
    BasicCamera.prototype.renderB2 = function() {
        if ((this.b2 && !this.c2) || this.rfm2) {
			if(this.rfm2 === 1) {
				this.drawDirectlyFromMap();
			} else {
				this.layerToRender.copyPixels(this.b2.canvas, this.v, this.p, this.v.width, this.v.height);
			}
		} else if ((this.b2 && this.c2) || this.b2ActualMover) {
			if(this.b2ActualMover) {
				this.b2ActualMover.setAttribute("style", "position:absolute;z-index:-6;top:"+(-this.v.y)+"px;left:"+(-this.v.x)+"px;image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
			} else {
				this.b2.canvas.setAttribute("style", "position:absolute;z-index:-6;top:"+(-this.v.y)+"px;left:"+(-this.v.x)+"px;image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
			}
		}
    };
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera.prototype  
	* @method renderB3
    * @returns {} 
	*/
    BasicCamera.prototype.renderB3 = function() {
        if (this.b3 && !this.c3) {
			if(this.rfm3 === 1) {
				this.drawDirectlyFromMap();
			} else {
				this.layerToRender.copyPixels(this.b3.canvas, this.v, this.p, this.v.width, this.v.height);
			}
		} else if ((this.b3 && this.c3) || this.b3ActualMover) {
			if(this.b3ActualMover) {
				this.b3ActualMover.setAttribute("style", "position:absolute;z-index:-5;top:"+(-this.v.y)+"px;left:"+(-this.v.x)+"px;image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
			} else {
				this.b3.canvas.setAttribute("style", "position:absolute;z-index:-5;top:"+(-this.v.y)+"px;left:"+(-this.v.x)+"px;image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
			}
		}
    };
    /** 
	*   @private
	*    
	*    
	* @memberof BasicCamera.prototype  
	* @method renderB4
    * @returns {} 
	*/
    BasicCamera.prototype.renderB4 = function() {
        if (this.b4 && !this.c4) {
			if(this.rfm4 === 1) {
				this.drawDirectlyFromMap();
			} else {
				this.layerToRender.copyPixels(this.b4.canvas, this.v, this.p, this.v.width, this.v.height);
			}
		} else if (this.b4 && this.c4) {
			this.b4.canvas.setAttribute("style", "position:absolute;z-index:-4;top:"+(-this.v.y)+"px;left:"+(-this.v.x)+"px;image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
		}
    }
    ;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera.prototype  
	* @method renderB5
    * @returns {} 
	*/
    BasicCamera.prototype.renderB5 = function() {
        if (this.b5 && !this.c5) {
			if(this.rfm5 === 1) {
				this.drawDirectlyFromMap();
			} else {
				this.layerToRender.copyPixels(this.b5.canvas, this.v, this.p, this.v.width, this.v.height);
			}
		} else if (this.b5 && this.c5) {
			this.b5.canvas.setAttribute("style", "position:absolute;z-index:-3;top:"+(-this.v.y)+"px;left:"+(-this.v.x)+"px;image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
		}
    };
    
    /** 
	*   
	*    Draws from _map onto layerToRender. 
    *   When the setupForRenderFromMap method is used, this method will be used internally to render the layer.
    *   If _tileSheetImage is defined then BlitMath.specificPatternAreaBlit or patternAreaBlit is used to render the map.
    *   If _tileSheetImage is not defined then BlitMath.drawSquresFromAreaOfPattern is used, using the colorValues property of this class.
	*  If _map is not a map of [y,x] values, ._mapIndexXMethod and ._mapIndexYMethod will be used on each value in _map to determine the location of each tile to draw.
	*    
	* @memberof BasicCamera.prototype  
	* @method drawDirectlyFromMap
    * 
	*/
    BasicCamera.prototype.drawDirectlyFromMap = function() {

		var sc = Math.floor(this.v.x / this._tw);
		var sr = Math.floor(this.v.y / this._th);
		var endC = sc + ((this._vRenderWidth || this.v.width)/this._tw) + 1 >= this._map[0].length ? this._map[0].length : sc + ((this._vRenderWidth || this.v.width)/this._tw) + 1;
		var endR = sr + ((this._vRenderHeight || this.v.height) / this._th) >= this._map.length ? this._map.length : sr + ((this._vRenderHeight || this.v.height) / this._th);
		
		if(endC > (this._map[0].length/2)) {
			if(this.mapUpdateMethod) {
				this.mapUpdateMethod();
			}
		}

		if(this._tileSheetImage) {
			if(this._map[0][0] === 0 || this._map[0][0]) {
				tabageos.BlitMath.specificPatternAreaBlit(this.layerToRender, this._tileSheetImage, this._map,  sr, endR , sc, endC, -this.v.x + (sc * this._tw), -this.v.y + (sr * this._th) );
				
			} else {
				tabageos.BlitMath.patternAreaBlit(this.layerToRender, this._tileSheetImage, this._map,  sr, endR , sc, endC, this._mapIndexXMethod, this._mapIndexYMethod, -this.v.x + (sc * this._tw), -this.v.y + (sr * this._th) );
			}
		} else {
			tabageos.BlitMath.drawSquaresFromAreaOfPattern(this.layerToRender, this._map, sr, endR , sc, endC, this._tw, this._th, this.colorValues, -this.v.x + (sc * this._tw), -this.v.y + (sr * this._th) );
		}

	};
    
    
    
    /** 
	*   
	*    Renders each layer into layerToRender (that is assigned during construction) based on the cameraOffsetPosition point given and limitX and limitY.
	*    This method does not render parallax layers.    
	*
	* @memberof BasicCamera.prototype  
	* @method blitLayerRender
	* @param cameraOffsetPosition {MoverPoint} A MoverPoint to offset the camera around.
	* @param [limitX] {Number} The horizontal limit of camera movement.
	* @param [limitY] {Number} The vertical limit of camera movement.
    * 
	*/
    BasicCamera.prototype.blitLayerRender = function(cameraOffsetPosition, limitX, limitY) {
        var rawx = Math.floor(cameraOffsetPosition.x - this.v.width);
        var rawy = Math.floor(cameraOffsetPosition.y - this.v.height);
        this.v.x = (rawx > 0 && rawx <= (limitX || this.v.width)) ? rawx : this.v.x;
        this.v.y = (rawy > 0 && rawy <= (limitY || this.v.height)) ? rawy : this.v.y;
        this.renderB1();
        this.renderB2();
        this.renderB3();
        this.renderB4();
        this.renderB5();
    }
    ;
    /** 
	*   
	*    Resets the view port position and all tweens.
	*    
	* @memberof BasicCamera.prototype  
	* @method reset
	* @param vx {Number} Reset to this x position instead of 0.
	* @param vy {Number} Reset to this y position instead of 0.
    * 
	*/
    BasicCamera.prototype.reset = function(vx, vy) {
        this.tweens1 = [];
        this.tweens2 = [];
        this.p1Tweens1 = [];
        this.p1Tweens2 = [];
        this.p2Tweens1 = [];
        this.p2Tweens2 = [];
        this.v.x = vx || 0;
        this.lastvx = vx || 0;
        this.v.y = vy || 0;
        this.lastvy = vy || 0;
        if (this._pV1) {
            this._pV1.x = vx || 0;
            this.pLastVs.p1x = vx || 0;
            this._pV1.y = vy || 0;
            this.pLastVs.p1y = vy || 0;
        }
        if (this._pV2) {
            this._pV2.x = vx || 0;
            this.pLastVs.p2x = vx || 0;
            this._pV2.y = vy || 0;
            this.pLastVs.p2y = vy || 0;
        }
    }
    ;
    /** 
	*   
	*    Resets all tweens.
	*    
	* @memberof BasicCamera.prototype  
	* @method resetTween
    *  
	*/
    BasicCamera.prototype.resetTween = function() {
        this.tweens1.length = 0;
        this.tweens2.length = 0;
        this.p1Tweens1.length = 0;
        this.p1Tweens2.length = 0;
        this.p2Tweens1.length = 0;
        this.p2Tweens2.length = 0;
    }
    ;
    /** 
	*   
	*    Resets tweens, and adjusts the view port position based on the MoverPoint given and the offsets,
	*    and then calls justRender and then blitLayerRender.
	*	 offsets should be the negative of what you would use as cameraOffsetPosition during blitLayerRender.
	*    
	* @memberof BasicCamera.prototype  
	* @method focus
	* @param mpToFocusOn {MoverPoint} The MoverPoint to focus on
	* @param [offsetX] {Number} Optional horizontal offset subtracted from mpToFocusOn
	* @param [offsetY] {Number} Optional vertical offset subtracted from mpToFocusOn
    * 
	*/
    BasicCamera.prototype.focus = function(mpToFocusOn, offsetX, offsetY) {

        this.resetTween();
        this.v.x = mpToFocusOn.x - offsetX;
        if (this.v.x < 0)
            this.v.x = 0;
        if (this.v.x > this.v.width)
            this.v.x = this.v.width;
        this.v.y = mpToFocusOn.y - offsetY;
        if (this.v.y < 0)
            this.v.y = 0;
        if (this.v.y > this.v.height)
            this.v.y = this.v.height;
        this.justRender();
        this.blitLayerRender(mpToFocusOn.subtractBy(-offsetX, -offsetY, 1), 0, 0);
    };
    
    
    /** 
	*   
	*    
	*    @private
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._shkincer = 717;
	/** 
	*   
	*    Defines the time of each shake, set during the shake method.
	*    
	* @memberof BasicCamera
	*  
	*/
    BasicCamera.prototype.shakeTime = 0;
	/** 
	*   
	*    Defines the amount of shaking that will happen, default is 4.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.shakeForce = 4;
	/** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.shakeContainer = null;
	/** 
	*   
	*    
	*    @private
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._shakeOriginals = {x:0,y:0};
	/** 
	*   
	*   Setup to shake the given container, automatic execution of the shake happens within the tweenedBlitLayerRender method, or use executeShake to execute the shake manually after calling this method to set up the shake.
	*    If your using a GameSkeleton, by default all you would have to do is call this method of the camera in your loop to shake the given container.
    *       GameSkeleton also has a shake method.
    *
	* @memberof BasicCamera.prototype  
	* @method shake
	* @param time {Number} 
	* @param container {HTMLElement} The HTML element to shake.
	* @param [ex] {Boolean} Execute the shake once, causes executeShake to be called once, executeShake is also called by tweenedBlitLayerRender.
    * 
	*/
    BasicCamera.prototype.shake = function(time, container, ex) {
		if((!ex || this.shakeTime == 0) && this._shkincer === 717) { this.shakeTime = time || 100; }
		this.shakeContainer = container;
		if(!this._shakeOriginals.x) {
			this._shakeOriginals.x = container.style.left;
			this._shakeOriginals.y = container.style.top;
		}
		if(ex) {
			
			this.executeShake();
		}
	};
	/** 
	*   
	*    Executes the shake, called by tweenedBlitLayerRender.
    *    set up the shake using the shake method.
	*    
	* @memberof BasicCamera.prototype  
	* @method executeShake
    * 
	*/
    BasicCamera.prototype.executeShake = function() {
		
		if(this.shakeTime > 0) {
			
			this._shkincer = this._shkincer === -1 ? 1 : -1;
			var shakeApply = this.shakeForce * this._shkincer;
			this.shakeContainer.style.left = (Number(this.shakeContainer.style.left.replace("px","")) + shakeApply) + "px";
			this.shakeContainer.style.top = (Number(this.shakeContainer.style.top.replace("px","")) - shakeApply) + "px";
			this.shakeTime -= 33.3;
		} else if( this.shakeTime <= 0 && this._shkincer != 717) {
			this.shakeTime = 0;this._shkincer = 717;
			this.shakeContainer.style.left = this._shakeOriginals.x;//the style is very modern, it becomes 'calc(50% - width)'
			this.shakeContainer.style.top = this._shakeOriginals.y;
			
		}
		
	};
    
    
    
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._tweenLoopOptions = {frameRate:60, useSceonds:0, millisecondRate:1000};
    /** 
	*   
	*    Call during a loop to move the camera around cameraOffsetPosition with easing.
	*	this method renders each individual layer onto layerToRender based on the params given.
	* 	if parallax layers have been defined they will be rendered first, underneath all other layers.
	*
	* @memberof BasicCamera.prototype  
	* @method tweenedBlitLayerRender
	* @param cameraOffsetPosition { MoverPoint } the point the camera should follow. The follow area is defined by v.width and v.height.
	* @param [limitX] { Number } The number that v.x should not be greater than. The default is v.width
	* @param [limitY]  { Number } The number that v.y should not be greater than. The default is v.height
	* @param tweenTime { Number } The millisecond amount of time each tween should take
	* @param [easeType='Linear'] { String } The easing function to use, default is 'Linear'.
	* @param [startingX] { Number }  denoting the number v.x should not be less than. default is 0.
	* @param [startingY] { Number }  denoting the number v.y should not be less than. default is 0.
    * 
	*/
    BasicCamera.prototype.tweenedBlitLayerRender = function(cameraOffsetPosition, limitX, limitY, tweenTime, easeType, startingX, startingY) {

        var rawx = (cameraOffsetPosition.x - this.v.width);
        var rawy = (cameraOffsetPosition.y - this.v.height);
        var sX = startingX != 0 ? startingX : 0;
        var sY = startingY != 0 ? startingY : 0;

        this.v.x = (rawx > sX && rawx <= (limitX || this.v.width)) ? rawx : this.v.x;
        this.v.y = (rawy > sY && rawy <= (limitY || this.v.height)) ? rawy : this.v.y;
        if (this._pV1) {
            //potential parallax 1
            this._pV1.x = this.v.x / this.pTween1XOffset;
            this._pV1.y = this.v.y / this.pTween1YOffset;
        }
        if (this._pV2) {
            //parallax 2
            this._pV2.x = this.v.x / this.pTween2XOffset;
            this._pV2.y = this.v.y / this.pTween2YOffset;
        }

        if (this.tweens1.length && this.tweens2.length) {
            this.v.x = this.tweens1.shift();//Math.floor(this.tweens1.shift());
            this.v.y = this.tweens2.shift();//Math.floor(this.tweens2.shift());
            this.lastvx = this.v.x+1-1;
            this.lastvy = this.v.y+1-1;
        } else {
            tabageos.TweenMath.tweenArray(this.lastvx, this.v.x, tweenTime, easeType || "Linear", this._tweenLoopOptions, this.tweens1);
            this.trsh = this.tweens1.shift();
            tabageos.TweenMath.tweenArray(this.lastvy, this.v.y, tweenTime, easeType || "Linear", this._tweenLoopOptions, this.tweens2);
            this.trsh = this.tweens2.shift();
            this.v.x = this.tweens1.shift();//Math.floor(this.tweens1.shift());
            this.v.y = this.tweens2.shift();//Math.floor(this.tweens2.shift());
            this.lastvx = this.v.x+1-1;
            this.lastvy = this.v.y+1-1;
        }

        if (this.p1Tweens1.length && this.p1Tweens2.length) {
            //p 1
            this._pV1.x = this.p1Tweens1.shift();
            this._pV1.y = this.p1Tweens2.shift();
            this.pLastVs.p1x = this._pV1.x;
            this.pLastVs.p1y = this._pV1.y;
        } else if (this._pLayer1) {
            tabageos.TweenMath.tweenArray(this.pLastVs.p1x, this._pV1.x, this.pTweenTime || tweenTime * 2, this.pTweenType || "Linear", this._tweenLoopOptions, this.p1Tweens1);
            this.trsh = this.p1Tweens1.shift();
            this._pV1.x = this.p1Tweens1.shift();
            tabageos.TweenMath.tweenArray(this.pLastVs.p1y, this._pV1.y, this.pTweenTime || tweenTime * 2, this.pTweenType || "Linear", this._tweenLoopOptions, this.p1Tweens2);
            this.trsh = this.p1Tweens2.shift();
            this._pV1.y = this.p1Tweens2.shift();
            this.pLastVs.p1x = this._pV1.x;
            this.pLastVs.p1y = this._pV1.y;
        }

        if (this.p2Tweens1.length && this.p2Tweens2.length) {
            //p 2
            this._pV2.x = this.p2Tweens1.shift();
            this._pV1.y = this.p2Tweens2.shift();
            this.pLastVs.p2x = this._pV2.x;
            this.pLastVs.p2y = this._pV2.y;
        } else if (this._pLayer2) {
            tabageos.TweenMath.tweenArray(this.pLastVs.p2x, this._pV2.x, this.pTweenTime2 || tweenTime * 2, this.pTweenType2 || "Linear", this._tweenLoopOptions, this.p2Tweens1);
            this.trsh = this.p2Tweens1.shift();
            this._pV2.x = this.p2Tweens1.shift();
            tabageos.TweenMath.tweenArray(this.pLastVs.p2y, this._pV2.y, this.pTweenTime2 || tweenTime * 2, this.pTweenType2 || "Linear", this._tweenLoopOptions, this.p2Tweens2);
            this.trsh = this.p2Tweens2.shift();
            this._pV2.y = this.p2Tweens2.shift();
            this.pLastVs.p2x = this._pV2.x;
            this.pLastVs.p2y = this._pV2.y;
        }

        if (this._pLayer1) {
            this.renderP1();
        }
        if (this._pLayer2) {
            this.renderP2();
        }
        this.renderB1();
        this.renderB2();
        this.renderB3();
        this.renderB4();
        this.renderB5();
        
        
        if(this.shakeTime > 0) {
			
			this._shkincer = this._shkincer === -1 ? 1 : -1;
			var shakeApply = this.shakeForce * this._shkincer;
			this.shakeContainer.style.left = (Number(this.shakeContainer.style.left.replace("px","")) + shakeApply) + "px";
			this.shakeContainer.style.top = (Number(this.shakeContainer.style.top.replace("px","")) - shakeApply) + "px";
			this.shakeTime -= 33.3;
		} else if( this.shakeTime <= 0 && this._shkincer != 717) {
			this.shakeTime = 0;this._shkincer = 717; 
			this.shakeContainer.style.left = this._shakeOriginals.x;//the style is very modern, it becomes 'calc(50% - width)'
			this.shakeContainer.style.top = this._shakeOriginals.y;
			
		}
        
        
        
    };
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._dragPosition = null;
    /** 
	*   
	*    Releases the camera from being dragged, use after a drag operation has been made.
	*    
	* @memberof BasicCamera.prototype  
	* @method releaseDrag
    * 
	*/
    BasicCamera.prototype.releaseDrag = function() {
        this._dragPosition = null;
    };
    
    /** 
	*    Drag the camera around.
	*  
	*     Parallax layers are not dragged, or displayed during drag.  For drag, only the 5 inital layers are available. 
    *
	* @example
    *           document.onmousemove = function(e) { camera.drag(mouseMP,64,0,1,100); }
	*           document.onmouseup = function(e) { camera.releaseDrag(); }
	*           gameLoop = function(e) { camera.justRender(); }
	*
	*
	* @memberof BasicCamera.prototype  
	* @method drag
	* @param dragPos {MoverPoint} The MoverPoint position the drag starts from, this must be defined, normally is just the mouse position.
	* @param [dragSpeed=64] {Number} The speed of the drag default is 64
	* @param [limitX]  {Number} default is v.width
	* @param [limitY]  {Number} default is v.height
	* @param tweenTime {Number} The amount of time for the tween
	* @param [easeType='Linear']  {String} Ease type
    * 
	*/
    BasicCamera.prototype.drag = function(dragPos, dragSpeed, limitX, limitY, tweenTime, easeType) {

        if (!this._dragPosition) {
            this._dragPosition = dragPos;
            return;
        }

        var spee = dragSpeed || 64;
        var rawx = this.v.x + ((this._dragPosition.x - dragPos.x) / (this.v.width / spee));
        //(cameraOffsetPosition.x - this.v.width);
        var rawy = this.v.y + ((this._dragPosition.y - dragPos.y) / (this.v.height / spee));
        //(cameraOffsetPosition.y - this.v.height);

        this.v.x = (rawx > 0 && rawx <= (limitX || this.v.width)) ? rawx : this.v.x;
        this.v.y = (rawy > 0 && rawy <= (limitY || this.v.height)) ? rawy : this.v.y;

        if (this.tweens1.length && this.tweens2.length) {
            this.v.x = this.tweens1.shift();
            this.v.y = this.tweens2.shift();
            this.lastvx = this.v.x;
            this.lastvy = this.v.y;
        } else {
            this.tweens1 = tabageos.TweenMath.tweenArray(this.lastvx, this.v.x, tweenTime, easeType || "Linear");
            this.trsh = this.tweens1.shift();
            this.tweens2 = tabageos.TweenMath.tweenArray(this.lastvy, this.v.y, tweenTime, easeType || "Linear");
            this.trsh = this.tweens2.shift();
            this.v.x = this.tweens1.shift();
            this.v.y = this.tweens2.shift();
            this.lastvx = this.v.x;
            this.lastvy = this.v.y;
        }
        this.renderB1();
        this.renderB2();
        this.renderB3();
        this.renderB4();
        this.renderB5();
    };
   
    /** 
	*   
	*    Renders each layer starting with layer 1 on the bottom, primarely for use with the drag method.
	*    
	* @memberof BasicCamera.prototype  
	* @method justRender
    *
	*/
    BasicCamera.prototype.justRender = function() {
		
        this.renderB1();
        this.renderB2();
        this.renderB3();
        this.renderB4();
        this.renderB5();
    }
    ;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype._isoPoint;
    /** 
	*    
	*    The horizontal camera follow offset, 
    *    typically you would set this to about negative half the cameraWidth minus tile width.
	*    
	* @memberof BasicCamera.protoype 
	*  
	*/
    BasicCamera.prototype.cameraFollowOffsetX = 0;
    /** 
	*   
	*    The vertical camera follow offset,
    *   typically you would set this to about negative half the cameraHeight minus tile height.
	*    
	* @memberof BasicCamera 
	*  
	*/
    BasicCamera.prototype.cameraFollowOffsetY = 0;
    /** 
	*   
	*    Sets the camera follow offsets for use with isoTweenedBlitLayerRender calls.
	*    
	* @memberof BasicCamera.prototype  
	* @method setIsoFollowOffsets
	* @param gameWidth {Number} The total width of the game
	* @param gameHeight {Number} The total height of the game
	* @param tileWidth {Number} The tile width
	* @param tileHeight {Number} tile height
    * 
	*/
    BasicCamera.prototype.setIsoFollowOffsets = function(gameWidth,gameHeight,tileWidth,tileHeight) {
        
        this.v.width = gameWidth - this.viewPortWidth; this.v.height = (gameHeight) - this.viewPortHeight;
        
        this.cameraFollowOffsetY = -((this.viewPortHeight/2)-tileHeight) -  (gameHeight - this.viewPortWidth*2 + tileHeight*2);
        this.cameraFollowOffsetX = -((this.viewPortWidth/2)+tileWidth)  -  (gameWidth - this.viewPortWidth*2);
        
    };
    /** 
	*   
	*    follows pointToFollow in a SimpleIsoScene.
	* 	 for use with the SimpleIsoScene Class.
	*    
	* @memberof BasicCamera.prototype  
	* @method isoTweenedBlitLayerRender
	* @param tileWidth {Number}
	* @param tileHeight {Number}
	* @param scene {SimpleIsoScene}
	* @param pointToFollow {MoverPoint}
	* @param [cFollowOffsetX] {Number}
	* @param [cFollowOffsetY] {Number}
	* @param [limitX] {Number}
	* @param [limitY] {Number}
	* @param tweenTime {Number}
	* @param [easeType='Linear'] {String}
	* @param [startingX=0] {Number}
	* @param [startingY=0] {Number}
    *  
	*/
    BasicCamera.prototype.isoTweenedBlitLayerRender = function(tileWidth,tileHeight,scene,pointToFollow, cFollowOffsetX, cFollowOffsetY, limitX, limitY, tweenTime, easeType, startingX, startingY) {
        
       
            var twdth = tileWidth > tileHeight ? tileWidth/tileHeight : tileHeight/tileWidth;
            var thdtw = tileHeight > tileWidth ? tileWidth/tileHeight : tileHeight/tileWidth;
                        
            twdth += scene._xSpreadShifter;
            thdtw += scene._ySpreadShifter;
                        
            var offX = (twdth)/2  + scene._spread;
            var offY = (thdtw)/2  + scene._spread;
                        
            this._isoPoint.x =  offX  * ((thdtw)/twdth) * tabageos.SimpleIsoPoint.rawToIso(pointToFollow.x,pointToFollow.y,1,0) + (scene.sceneXOffset);
            this._isoPoint.y =  offY  * ((twdth)/thdtw) * tabageos.SimpleIsoPoint.rawToIso(pointToFollow.x,pointToFollow.y,0,1) + (scene.sceneYOffset);
                         
            this._isoPoint.x -= cFollowOffsetX;
            this._isoPoint.y -= cFollowOffsetY;
            this.tweenedBlitLayerRender(this._isoPoint, limitX,limitY,tweenTime,easeType||"Linear",startingX||0,startingY||0);
        
        
    };
    
    tabageos.BasicCamera = BasicCamera;
})();

(function() { 

	'use strict';
    
    
    /** 
	*  Constructs a new BasicNinja
	*
	* @classdesc 
    *  A BasicNinja moves around in a tiled map using velocity, basic jumping and collisions are handled,
    *  and it can wall slide, wall jump, and double jump.
    *  A BasicNinja is a MapMover/MapTraveler but it does not extend either, rather is directly built from just an extension of TravelerSkeleton
    *
	*
	* @see MapMover
    * @see MapTraveler
	* @see TravelerSkeleton
	*    
	*    
	* @class BasicNinja
	* @param x {Number} The x position of the BasicNinja
	* @param y {Number} The y position of the BasicNinja
	* @param width {Number} The width of the BasicNinja
	* @param height {Number} The height of the BasicNinja
	* @param map {Array} 2D Array that the BasicNinja is to collide with, 0 or [0,0] as a value in the 2D array denotes a walkable spot. The 2d Array should have all integer values, or all values of [y,x] style inner arrays.  
	* @param [ca=null] {CanvasAnimation} CanvasAnimation for the BasicNinja
	* @param [dontCloneMap=false] {Boolean} Default is false
	* @param [dt=.6666666667] {Number} Default is tabageos.TimeKeeper._sae
	* @param [tileW] {Number} The width of each tile, default is the same as width.
	* @param [tileH] {Number} The height of each tile, default is the same as height.
	* @param [mapRows] {Number} The amount of rows in map
	* @param [mapColumns] {Number} The amount of columns in map
	* @param [useBlitMathSpecificArrays] {Boolean}  This ultimately is set based on the actual value types in map
    *
    * 
	*  
	*/
    function BasicNinja(x,y,width,height, map,ca,dontCloneMap, dt, tileW, tileH, mapRows, mapColumns, useBlitMathSpecificArrays) {
		tabageos.TravelerSkeleton.call(this,x,y,width,height);
        this.width = width || 0;
        this.height = height || 0;
        this._middlePoint = new tabageos.MoverPoint();
        this._pos = new tabageos.MoverPoint(x,y);
        this._veloc = new tabageos.MoverPoint(0,0);
        this._lastVeloc = new tabageos.MoverPoint(0,0);
        this._lastPos = new tabageos.MoverPoint(x,y);
        this._deltaTime = dt || tabageos.TimeKeeper._sae;
        this._map = dontCloneMap ? map : tabageos.BlitMath.cloneMultiArray(map);
        this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
        this._state = 1;
        this.forceApplier = new tabageos.MoverPoint();
        this.forceHolder = new tabageos.MoverPoint();
        this._canvasAnimation = ca || null;
		if(this._canvasAnimation) {
			this._canvasAnimation.addedAnimationChanges = this._addedToChangeDirectionAnimation;
			this._canvasAnimation._playerRef = this;
		}
        this._w = width || 0;
        this._h = height || 0;
        this.wanderOffset = new tabageos.MoverPoint(0,0);
        this.blankMO = new tabageos.MoverPoint();
        this._eventDispatcher = new tabageos.EventDispatcher();
        this.x = x || 0;
        this.y = y || 0;
        this._checkHelper = new tabageos.MoverPoint();
		this._jumps = 1;
		this._jumpSpeed = 4;
		this._jsp = 1;
		this._walkSpeed = 4;
		this._gravityLevel = .285;
		this.health = 100;
		this._pLeft = 0;
		this._npLeft = 0;
		this._pRight = 0;
		this._npRight = 0;
		this._grounded = 0;
		this._unGrounded = 1;
		this._atCeiling = 0;
		this._unCeiling = 1;
		this._wallObject = null;
		this.boundingMethod = null;
		this.path = [];
		this._mapRows = mapRows || map.length;//j
		this._mapColumns = mapColumns || map[0].length;//i
		this._tw = tileW || this.width;
		this._th = tileH || this.height;
		this.destination = new tabageos.MoverPoint();
		this._mt = useBlitMathSpecificArrays || 0;
		
		if(this._map && this._map[0] && this._map[0][1] && (typeof this._map[0][1] == 'array' || typeof this._map[0][1] == 'object')) {
			this._mt = 1;
		} else {
			this._mt = 0;
		}
		
    };
	/** 
	*   
	*    @private
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype.constructor = BasicNinja;
    BasicNinja.prototype = Object.create(tabageos.TravelerSkeleton.prototype);
	/** 
	*   
	*    @private
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._mapRows = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._mapColumns = 0;
    /** 
	*   
	*    state of 1
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype.stand = 1;
    /** 
	*   
	*   state of  2
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype.walk = 2;
    /** 
	*   state of 3
	*    
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype.up = 3;
    /** 
	*   
	*    A reference to the CanvasAnimation for this class.
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._canvasAnimation = null;
    /** 
	*   state of 4
	*    
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype.down = 4;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._deltaTime = .666666667;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._state = 1;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._checkHelper;
    /** 
	*   When _jumps is 0 gravity is not applied, by default _jumps is 1 for BasicNinja.
	*    
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._jumps = 1;
	/** 
	*   
	*    
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype.forceGrounded = 0;
    /** 
	*   
	*    Defines the height of jump
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._jumpSpeed = 4;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._jsp = 1;
    /** 
	*   Defines the speed of movement
	*    
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._walkSpeed = 4;
    /** 
	*   
	*    Default is .285
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._gravityLevel = .285;
    /** 
	*   Inherited from MapMover, if 1 then the BasicNinja is colliding left
	*    
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._pLeft = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._npLeft = 0;
    /** 
	*   
	*    if 1 then the BasicNinja is colliding right
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._pRight = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._npRight = 0;
    /** 
	*   
	*    If 1 then the BasicNinja is colliding bottom
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._grounded = 0;
    /** 
	*   
	*    If 1 then the BasicNinja is not colliding bottom 
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._unGrounded = 1;
	/** 
	*   
	*    Property for health to be used manually.
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype.health = 100;
    /** 
	*   
	*    If 1 then the BasicNinja is colliding top
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._atCeiling = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._unCeiling = 1;
    /** 
	*   
	*    The 2D Array that the BasicNinja is to collide with
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._map = null;
    /** 
	*   
	*    The tile width of each tile the values in _map represent, default is 16.
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._tw = 16;
    /** 
	*   The tile height of each tile the values in _map represent, default is 16.
	*    
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._th = 16;
	/** 
	*   An optional Rectangle defining a wall the BasicNinja should not pass.
    *   Set boundingMethod to one of the tabageos.BoundMethods and define this rectangle to have the BasicNinja collide with the Rectangle.
    *   By default the boundingMethod is tabageos.BoundMethods.bounceOff, so if you just define a _wallObject Rectangle it would bounce off that defined space.
    *   By default a _wallObject is not defined.
	*    @type Rectangle
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._wallObject = null;
	/** 
	*   
	*    By default this is set to tabageos.BoundMethods.bounceOff.
    *    See _wallObject.
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype.boundingMethod = null;
	/** 
	*   
	*    
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype.destination = null;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._mt = 1;
    /** 
	*   
	*    
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._autoAnimate = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._inDoubleJump = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof BasicNinja 
	*  
	*/
    BasicNinja.prototype._onWall = 0;
    
	
    /** 
	*   
	*    Moves the BasicNinja by _walkSpeed, also handling collisions with _map and double jumps, wall slides and wall jumps.
    *    
	*    
	* @memberof BasicNinja.prototype 
	* @method move
	* @param left {Boolean} To move left
	* @param right {Boolean} To move right
	* @param up {Boolean} To move up
	* @param down {Boolean} To move down
	* @param [dontApplyForce=false] {Boolean} Make it behave as a MapMover, default is false
	* 
    * 
	*/
    BasicNinja.prototype.move = function(left,right,up,down,dontApplyForce,easeFuncString) {
           
            if(this._state == 1) {//idle
            
                this._veloc.x = 0; this._veloc.y = 0;

                if (!this._grounded || this._atCeiling) {
                    this._state = 3;

                } else if ((left && !right) || (right && !left)) {
                    this._state = 2;

                } else if (up && !this._atCeiling) {
                    
                    this._jsp = (this._jumpSpeed-2);
                    this._veloc.y = this._jumps ? -(this._jumpSpeed-(this._jumpSpeed-2)) : -this._jumpSpeed;
                    this._state = 3;
                    
                } else if( !up && !this._jumps && down) {
                    
                    this._veloc.y = this._walkSpeed;
                    this._state = 4;
                }
                
                this.update(0,dontApplyForce); return;
            }
            if(this._state == 2) { //left right
                if (!left && !right) {
                    this._state = 1;
                    this._veloc.x = 0; this._veloc.y = 0;

                } else if (right) {
                    if (this._pRight) {
                        this._veloc.x = 0;
                    } else {
                        if(easeFuncString) {
                           // this[easeFuncString](this._pos.addBy(4,0,1));// this._veloc.x = this._walkSpeed;
                        } else {
                            this._veloc.x = this._walkSpeed;
                        }
                        
                    }
                    
                } else if (left) {
                    if (this._pLeft) {
                        this._veloc.x = 0;
                    } else {
                        if(easeFuncString) {
                            //this[easeFuncString](this._pos.addBy(-4,0,1));// this._veloc.x = -this._walkSpeed;
                        } else {
                            this._veloc.x = -this._walkSpeed;
                        }
                       
                    }
                } 

                if (up && !this._atCeiling) {
                    
                    this._jsp = (this._jumpSpeed-2);
                    this._veloc.y = this._jumps ? -(this._jumpSpeed-(this._jumpSpeed-2)) : -this._jumpSpeed;
                    this._state = 3;

                } else if(up && this._atCeiling) {
					if(this._jumps && !this._grounded) {
						this._state = 3;this._veloc.y = this._walkSpeed;
					}
					
				} else if (!up && !this._grounded) {
                    this._state = 3;

                }
                this.update(0,dontApplyForce); return;
            }

            if(this._state ==3) { //up
              
                if(!this._jumps) {
                    if(up && !this._atCeiling) {
                        this._veloc.y = -this._walkSpeed;
                    } else {
                        this._veloc.y = 0;
                    }
                    if(!up) {
                        if(!left && !right && !down) {
                            this._state = 1; this._veloc.x = 0; this._veloc.y = 0;
                        } else if ((left || right) && !down) {
                            this._state = 2;this._veloc.y = 0;
                        } else if(down) {
                            this._state = 4;this._veloc.y = this._walkSpeed;
                        }
                    }
                } else { //allow for jumping based on how long up pressed, and apply gravity to _veloc.y
                
                    if(up && !this._atCeiling && this._veloc.y > -this._jumpSpeed && this._jsp != 0) {
                        this._jsp -= 1; this._veloc.y = -(this._jumpSpeed-this._jsp); 
                    } else {
                        this._jsp = 0;
						
                    }

					if(this._jsp == 0 && !up) {
						if(this._inDoubleJump === 0) {
							this._inDoubleJump = 1;//means its in its first jump and now can jump again to double jump.
						}
					}

                    this._veloc.y += this._gravityLevel * this._deltaTime;
                    
                    if(this._veloc.y > this._jumpSpeed) {
                        this._veloc.y = this._jumpSpeed+1-1;  
                    } 
                
                    if (!up && this._veloc.y > 0) {
                        this._veloc.y = this._veloc.y > this._jumpSpeed ? this._jumpSpeed+1-1 : this._veloc.y;
                    }
					
					if(this._inDoubleJump === 1 && up && !this._atCeiling) {//perform double jump
						
						this._jsp -= 1; this._veloc.y = -(this._jumpSpeed-this._jsp);
						
						this._inDoubleJump = 2;//now it needs to land to reset double jump to 0.
					}
					
                }
                
                if (!right && !left) {
                    this._veloc.x = 0;
					this._onWall = 0;				
                } else if (right) {
                    if (this._pRight) {
                        this._veloc.x = 0;
                        if(!this._grounded ) { //on wall slow down
                        
                            this._veloc.y = this._jumpSpeed / 4;
							this._onWall = 1;
                        
                        } 
						
                    } else {
						
						if (!this._grounded && this._onWall == 1 && up && this._jumps) {//wall jump
							
							this._jsp -= 1; this._veloc.y = -(this._jumpSpeed-this._jsp);
							
							this._onWall = 0;
							
						}
						
                        this._veloc.x = this._walkSpeed;
                    }
                   
                } else if (left) {
                    if (this._pLeft) {
                        this._veloc.x = 0;
						if(!this._grounded ) {
                        
                            this._veloc.y = this._jumpSpeed / 4;
							this._onWall = 1;
                        
                        } 
                    } else {
						
						if (!this._grounded && this._onWall == 1 && up && this._jumps && this._pRight) {
							
							this._jsp -= 1; this._veloc.y = -(this._jumpSpeed-this._jsp);
							
							this._onWall = 0;
							
						}
						
                        this._veloc.x = -this._walkSpeed;
					}
                }

                if (this._grounded) {
                    if (!right && !left) {
                        this._state = 1;
                        this._veloc.x = 0; this._veloc.y = 0;
                        
                    } else  {
                        this._state = 2;
                        this._veloc.y = 0;
                    } 
					this._inDoubleJump = 0;
                } else {
                    
                    if(!this._jumps && down) {
                        this._veloc.y = this._walkSpeed;
                        this._state = 4;
                    } 
                }
                this.update(0,dontApplyForce); return;
            }
        
            if(!this._jumps && this._state == 4) { //down (when _jumps = 0)
                if(down && !this._grounded) {
                    this._veloc.y = this._walkSpeed;
                } else {
                    this._veloc.y = 0;
                }
                if(!down) {
                    if(!left && !right) {
                        this._state = 1; this._veloc.x = 0; this._veloc.y = 0;
                    } else {
                        this._state = 2;this._veloc.y = 0;
                    }
                }
                
                if (!right && !left) {
                    this._veloc.x = 0;
                } else if (right) {
                    if (this._pRight)
                        this._veloc.x = 0;
                    else
                        this._veloc.x = this._walkSpeed;
                   
                } else if (left) {
                    if (this._pLeft)
                        this._veloc.x = 0;
                    else
                        this._veloc.x = -this._walkSpeed;
                }
            
                if (this._atCeiling) {
                    if (!right && !left) {
                        this._state = 1;
                        this._veloc.x = 0; this._veloc.y = 0;
                        
                    } else  {
                        this._state = 2;
                        this._veloc.y = 0;
                    } 
                }
                this.update(0,dontApplyForce); return;
            }
        
    };
	
	
	/** 
	*   
	*    This method becomes part of this class' CanvasAnimation's changeDirectionAnimation method.
	*   This Class is using this functionality to add onwall animation and flip animation.
    *   It's ready for 'onwallleft' 'onwallright' and 'flipleft' and 'flipright'.
    *
    *   Simply define a 'onwallleft' and 'onwallright' animation for the CanvasAnimation passed to this class, 
    *   and this class automatically changes to those when the BasicNinja is on a wall.
    *   If you don't define those then the left and right animations would be used when on a wall.
    *   Same for flip.
    *   
	* @memberof BasicNinja.prototype 
	* @method _addedToChangeDirectionAnimation
	* @param left 
	* @param right 
	* @param up 
	* @param down 
	* @param keepAniIndex {Boolean}
	* @param noIdle {Boolean}
    * 
    *
    * @see CanvasAnimation#changeDirectionAnimation
	*/
    BasicNinja.prototype._addedToChangeDirectionAnimation = function(left, right, up, down, keepAniIndex, noIdle) {
		//this._canvasAnimation.changeDirectionAnimation(left, right, up, down, keepAniIndex, noIdle);
		if(this._playerRef._onWall === 1) {
			if(this._playerRef._pLeft) {
				this.currentAnimation = "onwallleft";
			} else if(this._playerRef._pRight) {
				this.currentAnimation = "onwallright";
			}
		}
		if(this._playerRef._inDoubleJump === 2  && this._playerRef._veloc.y < 0) {
			var direc = this.getDirectionOfAnimation(this.currentAnimation, 1);
			//window.console.log(this._canvasAnimation.currentAnimation);
			this.currentAnimation = "flip" + direc;
		}
	};
	
    
    /**
    *
    * _autoAnimate must be set to 1.
    * 
    *  the functionality of this method happens in the update method if _autoAnimate is true, 
    *  but you can also call this method if needed, for example if you need to animate outside of the move call.
    * 
    * updates the position of the _canvasAnimation and calls its changeDirectionAnimation function then animate and blit.
    * if there is no _canvasAnimation then _directCanvasObject.context.fillRect is used with this x y width height.
    *
    * @memberof BasicNinja.prototype
    * @method autoAnimation
    *
    *
    */
    BasicNinja.prototype.autoAnimation = function() {
		
		if(this._autoAnimate && this._canvasAnimation) {

            this._canvasAnimation.x = this.x;
			this._canvasAnimation.y = this.y;
					
			this._canvasAnimation.changeDirectionAnimation(this._veloc.x < 0,this._lastVeloc.x > 0, this._veloc.y < 0, this._veloc.y > 0);
					
			this._canvasAnimation.animate(this._autoAnimationThrottle);
			this._canvasAnimation.blit();
        
        } else if(this._autoAnimate && this._directCanvasObject) {


            this._directCanvasObject.context.fillRect(this.x,this.y,this.width,this.height);
            


        }
		
		
	};
    
    
    
    /** 
	*   
	*    Updates forceApplier and _veloc and handles collisions.
    *    This method is called inside of the move method.
    *    To manually move the Class you could update _veloc yourself then call this method.
    *    The move method changes _veloc and calls this method.
    *    This is the method that is handling collision with the _map and with _wallObject.
	*    
	* @memberof BasicNinja.prototype 
	* @method update
	* @param [dontApplyToXY=false] {Boolean} If true the x and y are not updated, just _pos.
	* @param [dontApplyForce=false] {Boolean} If true forceApplier is not used, and it opperates as a MapMover without traveling ability (ease, wander, etc...)
    * @param [dontCollide=false] {Boolean} If true it will not collide with the map
	*/
    BasicNinja.prototype.update = function(dontApplyToXY, dontApplyForce, dontCollide) {
		
		if(this._lastPos.x < this._pos.x) {
			
			this._leftRightFace = 1;//right
		}
		if(this._lastPos.x > this._pos.x) {
			
			this._leftRightFace = 0;
		}
		
		
        this._lastPos.x = this._pos.x +1-1;
        this._lastPos.y = this._pos.y +1-1;
        this._lastVeloc.x = this._veloc.x+1-1;
        this._lastVeloc.y = this._veloc.y+1-1;
        this._unGrounded =  this._grounded+1-1;
        
        this._npRight = this._pRight+1-1;
        this._npLeft = this._pLeft+1-1;
        this._unCeiling = this._atCeiling+1-1;
        
		if(!dontApplyForce) {
			this.forceApplier.truncate(this.maxForce);
			this.forceApplier.divide(this.mass, 0);
			this._veloc.add(this.forceApplier.multiply(this._deltaTime,0), 0);
			this.forceApplier.reset();
			this._veloc._length = 0;
			this._veloc._angle = 0;
			this._veloc.truncate(this.maxSpeed);
		}
        this._pos.addBy(this._veloc.x * this._deltaTime, this._veloc.y * this._deltaTime, 0);
        
        if(!dontCollide) {
            var pgy, pgx;
            pgx = this.isLeftPushingOnMap(this._lastPos,this._pos,this._veloc,this._map,this._tw,this._th);
            if(pgx > 0) {
                this._pLeft = 1;
                this._pos.x = pgx;
                this._veloc.x = 0;
            } else {
                
                this._pLeft = 0;
            }
            
            pgx = this.isRightPushingOnMap(this._lastPos,this._pos,this._veloc,this._map,this._tw,this._th);
            if(pgx > 0) {
                this._pRight = 1;
                this._pos.x = pgx - this.width;
                this._veloc.x = 0;
            } else {
                
                this._pRight = 0;
            }
            
            pgy = this.isGroundedOnMap(this._lastPos,this._pos,this._veloc,this._map,this._tw,this._th);
            if(pgy > 0){
                this._grounded = 1;
                this._pos.y = pgy - this.height;
                this._veloc.y = 0;
            } else {
                this._grounded = 0;
                if(this.forceGrounded && this._jumps) {
                    this._state = 3;this._veloc.y = this._walkSpeed; 
                }
            }
            
            pgy = this.isHeadHitOnMap(this._lastPos,this._pos,this._veloc,this._map,this._tw,this._th);
            if(pgy > 0) {
                this._atCeiling = 1;
                if( this._pos.y < pgy) this._pos.y = pgy ;
                if(this._veloc.y < 0) this._veloc.y = (this._jumps && !this._grounded) ? this._walkSpeed : 0;
            } else {
                this._atCeiling = 0;
                
            }
            
            if (this._wallObject) {
                this.boundingMethod(this, this._wallObject);
            }
            
        }
        if(!dontApplyToXY) {
            this.x = Math.round(this._pos.x +1-1);
            this.y = Math.round(this._pos.y +1-1);
        }

        if(this._autoAnimate && this._canvasAnimation) {

            this._canvasAnimation.x = this.x;
			this._canvasAnimation.y = this.y;
					
			this._canvasAnimation.changeDirectionAnimation(this._veloc.x < 0,this._lastVeloc.x > 0, this._veloc.y < 0, this._veloc.y > 0);
					
			this._canvasAnimation.animate(this._autoAnimationThrottle);
			this._canvasAnimation.blit();
        
        } else if(this._autoAnimate && this._directCanvasObject) {


            this._directCanvasObject.context.fillRect(this.x,this.y,this.width,this.height);
            


        }

    };
    /** 
	*   
	*    Used by the update method to determine bottom collision
	*    
	* @memberof BasicNinja.prototype 
	* @method isGroundedOnMap
	* @param last {MoverPoint} _lastPos
	* @param curr {MoverPoint} _pos
	* @param veloc {MoverPoint} _veloc
	* @param map {Array} _map
	* @param tw {Number} tile width,  _tw
	* @param th {Number} tile height, _th
    * @returns {Number} The y point of collision 
	*/
    BasicNinja.prototype.isGroundedOnMap = function(last, curr, veloc, map,tw,th) {
        
       var  bLx = this._pos.x+1-1; var bLy = this._pos.y+this.height +  ((this._veloc.y < 1 ? 1 : this._veloc.y));
        var bRx = this._pos.x + this.width;
        var tile; var gy = -999;var iX = 0; var iY = 0;var cmb;var cix; var ciy;
        
        while(bLx < bRx) {
           // tile = tabageos.BlitMath.getTileDataAt(bLx,bLy,map,tw,th);
            tabageos.BlitMath.fasterCheckTileValueAt(bLx,bLy,this._mapRows,this._mapColumns,tw,th,this._checkHelper);
			ciy = this._checkHelper.y; cix = this._checkHelper.x;
			tile = this._map[ciy][cix];
            if((this._mt === 0 && tile != 0)  || ( this._mt === 1 && ((tile[0] != 0 || tile[1] != 0)) )) {
                gy = (ciy*th) +1-1;//tile.position.y +1-1; 
                if(gy < bLy) {  } else { gy = -1; }
            }
            bLx += (tw > this.width ? this.width : tw) / 4;
            
        } return gy;
    };
    /** 
	*   
	*    Used by the update method to determine top collision
	*    
	* @memberof BasicNinja.prototype 
	* @method isHeadHitOnMap
	* @param last {MoverPoint} _lastPos
	* @param curr {MoverPoint} _pos
	* @param veloc {MoverPoint} _veloc
	* @param map {Array} _map
	* @param tw {Number} tile width,  _tw
	* @param th {Number} tile height, _th
    * @returns {Number} The y point of collision 
	*/
    BasicNinja.prototype.isHeadHitOnMap = function(last, curr, veloc, map,tw,th) {
        
        var bLx = this._pos.x+1-1; var bLy = this._pos.y -1 - (-(this._veloc.y));
        var bRx = this._pos.x + this.width;
        var tile; var gy = -999;var iX = 0; var iY = 0;var cmb = 0;var cix; var ciy;
        while(bLx < bRx) {
           // tile = tabageos.BlitMath.getTileDataAt(bLx,bLy,map,tw,th);
            cmb = tabageos.BlitMath.fasterCheckTileValueAt(bLx,bLy,this._mapRows,this._mapColumns,tw,th, this._checkHelper);
			ciy = this._checkHelper.y; cix = this._checkHelper.x;
			tile = this._map[ciy][cix];
            if((this._mt === 0 && tile != 0)  || ( this._mt === 1 && ((tile[0] != 0 || tile[1] != 0)) )) {
                gy = (ciy*th) +th; 
                if(gy > bLy) {  } else { gy = -1; }
            }
            bLx += (tw > this.width ? this.width : tw);
            
        } return gy;
    };
    /** 
	*   
	*    Used by the update method to determine right collision
	*    
	* @memberof BasicNinja.prototype 
	* @method isRightPushingOnMap
	* @param last {MoverPoint} _lastPos
	* @param curr {MoverPoint} _pos
	* @param veloc {MoverPoint} _veloc
	* @param map {Array} _map
	* @param tw {Number} tile width,  _tw
	* @param th {Number} tile height, _th
    * @returns {Number} The x point of collision 
	*/
    BasicNinja.prototype.isRightPushingOnMap = function(last, curr, veloc, map,tw,th) {
        
        var Tpy = this._pos.y+1-1; var Bty = this._pos.y + this.height;
        var rx = this._pos.x + (this.width) + 1;
        var tile; var gx = -999;var iX = 0; var iY = 0;var cmb = 0;var cix; var ciy;
        while(Tpy < Bty) {
            //tile = tabageos.BlitMath.getTileDataAt(rx,Tpy,map,tw,th);
            cmb = tabageos.BlitMath.fasterCheckTileValueAt(rx,Tpy,this._mapRows,this._mapColumns,tw,th, this._checkHelper);
			ciy = this._checkHelper.y; cix = this._checkHelper.x;
			tile = this._map[ciy][cix];
            if((this._mt === 0 && tile != 0)  || ( this._mt === 1 && ((tile[0] != 0 || tile[1] != 0)) )) {
                gx = (cix*tw) +1-1;//tile.position.x +1-1; 
                if(gx < rx) { break; } else { gx = -1; }
            }
            Tpy += (th > this.height ? this.height : th) ;
            
        } return gx;
    };
    /** 
	*   Used by the update method to determine left collision
	*    
	*    
	* @memberof BasicNinja.prototype 
	* @method isLeftPushingOnMap
	* @param last {MoverPoint} _lastPos
	* @param curr {MoverPoint} _pos
	* @param veloc {MoverPoint} _veloc
	* @param map {Array} _map
	* @param tw {Number} tile width,  _tw
	* @param th {Number} tile height, _th
    * @returns {Number} The x point of collision 
	*/
    BasicNinja.prototype.isLeftPushingOnMap = function(last, curr, veloc, map,tw,th) {
        
        var Tpy = this._pos.y+1-1; var Bty = this._pos.y + this.height;
        var lx = this._pos.x -1;
        var tile; var gx = -999;var iX = 0; var iY = 0;var cmb = 0;var cix; var ciy;
        while(Tpy < Bty) {
           // tile = tabageos.BlitMath.getTileDataAt(lx,Tpy,map,tw,th);
            cmb = tabageos.BlitMath.fasterCheckTileValueAt(lx,Tpy,this._mapRows,this._mapColumns,tw,th, this._checkHelper);
			ciy = this._checkHelper.y; cix = this._checkHelper.x;
			tile = this._map[ciy][cix];
            if((this._mt === 0 && tile != 0)  || ( this._mt === 1 && ((tile[0] != 0 || tile[1] != 0)) )) {
                gx = (cix*tw) + tw;//tile.position.x +tw; 
                if(gx > lx) { break; } else { gx = -1; }
            }
            Tpy += (th > this.height ? this.height : th) ;
            
        } return gx;
    };
    tabageos.BasicNinja = BasicNinja;
    
})();
(function() { 
	
	
	/** 
	*   
	*    A TravelingSceneryThrower designated as a Platformer character. BasicPlatformer climbs ladders designated by the ladderTileValue, and is ready for a 'climb' animation.
	*    
	* @class BasicPlatformer
	* @param x {Number}
	* @param y {Number}
	* @param width {Number}
	* @param height {Number}
	* @param map {Array}
	* @param ca {CanvasAnimation}
	* @param [dontCloneMap=false] {Boolean}  
	* @param [dt=.6666666667] {Number} delta time
	* @param [tWidth] {Number} tile width
	* @param [tHeight] {Number} tile height
	* @param [mr] {Number} map rows
	* @param [mc] {Number} map columns
	* @param mapOfOriginalTiles {Array} uncloned version of map containing ladder tile values.
	* @param controller {ControllerPad} a reference to the games ControllerPad instance.
	* @param ladderTileValue  {Object} tile value in map that denotes a ladder tile.
	*  
    *
    * @see TravelingSceneryThrower
    *
	*/
    function BasicPlatformer(x,y,width,height, map, ca,dontCloneMap,dt,tWidth,tHeight,mr,mc, mapOfOriginalTiles, controller, ladderTileValue) {
		tabageos.TravelerSkeleton.call(this, x, y, width, height);
		tabageos.MapTraveler.call(this,x,y,width,height, map,ca,dontCloneMap, dt, tWidth,tHeight, mr, mc);
		tabageos.TravelingSceneryThrower.call(this, x,y, width, height, map, ca, dontCloneMap, dt, tWidth, tHeight, mr, mc);
		this.width = width || 0;
		this.height = height || 0;
		this._middlePoint = new tabageos.MoverPoint();
		this._pos = new tabageos.MoverPoint(x,y);
		this._veloc = new tabageos.MoverPoint(0,0);
		this._lastVeloc = new tabageos.MoverPoint(0,0);
		this._lastPos = new tabageos.MoverPoint(x,y);
		this._deltaTime = dt || tabageos.TimeKeeper._sae;
		this._map = dontCloneMap ? map : tabageos.BlitMath.cloneMultiArray(map);
		this._state = 1;
		this.x = x || 0;
		this.y = y || 0;
		this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
		this._canvasAnimation = ca || null;
		this._tH = tHeight || this.height;
		this._tW = tWidth || this.width;
		this._outAltered = new tabageos.MoverPoint();
		this.holdingRect = new tabageos.Rectangle(0,0,width,height);
		this.holdingOffsetX = 1;
		this.holdingOffsetY = 3;
		this._jumps = 1;
		this.easeProximity = 7;
		this._checkHelper = new tabageos.MoverPoint();
		this.forceApplier = new tabageos.MoverPoint();
		this.forceHolder = new tabageos.MoverPoint();
		this._w = width || 0;
		this._h = height || 0;
		this.wanderOffset = new tabageos.MoverPoint(0,0);
		this.blankMO = new tabageos.MoverPoint();
		this._eventDispatcher = new tabageos.EventDispatcher();
		this.holdings = [];
		this._holdingHelperRect = new tabageos.Rectangle(0,0,0,0);
		this.personalSpace = this.width * 9;
		this._hpt = new tabageos.MoverPoint();
		this._jumpSpeed = 10;
		this.throwStrength = 10;
		if(this._canvasAnimation) {
			this._canvasAnimation.addedAnimationChanges = this._addedToChangeDirectionAni;
			this._canvasAnimation._playerRef = this;
		}
		this.tileMap = mapOfOriginalTiles;
		this._controllerRef = controller;
		this.ladderValue = ladderTileValue;
		this._hlpp = new tabageos.MoverPoint();
		
	};
	/** 
	*   
	*    
	*    
	* @memberof BasicPlatformer 
	*  
	*/
    BasicPlatformer.prototype.constructor = BasicPlatformer;
	BasicPlatformer.prototype = Object.create(tabageos.TravelerSkeleton.prototype);
	Object.assign(BasicPlatformer.prototype, tabageos.MapTraveler.prototype, tabageos.TravelingSceneryThrower.prototype);
	
	
	/** 
	*   
	*    
	*    
	* @memberof BasicPlatformer 
	*  
	*/
    BasicPlatformer.prototype.onLadder = 0;
	/** 
	*   
	*    
	*    
	* @memberof BasicPlatformer 
	*  
	*/
    BasicPlatformer.prototype.onMovingPlatform = 0;
	/** 
	*   
	*    The value of tiles that are ladders.
	*    
	* @memberof BasicPlatformer 
	*  
	*/
    BasicPlatformer.prototype.ladderValue = 0;
	
	/** 
	*   
	*    
	*    
	* @memberof BasicPlatformer 
	*  
	*/
    BasicPlatformer.prototype.tileMap = null;
	
	/** 
	*   
	*    
	*    
	* @memberof BasicPlatformer 
	*  
	*/
    BasicPlatformer.prototype.tile = null;
	/** 
	*   
	*    
	*    
	* @memberof BasicPlatformer 
	*  
	*/
    BasicPlatformer.prototype.tilelUp = null;
	/** 
	*   
	*    
	*    
	* @memberof BasicPlatformer 
	*  
	*/
    BasicPlatformer.prototype.tileDown = null;
	/** 
	*   
	*    
	*    
	* @memberof BasicPlatformer 
	*  
	*/
    BasicPlatformer.prototype.tileLeft = null;
	/** 
	*   
	*    
	*    
	* @memberof BasicPlatformer 
	*  
	*/
    BasicPlatformer.prototype.tileRight = null;
	/** 
	*   
	*    
	*    
	* @memberof BasicPlatformer 
	*  
	*/
    BasicPlatformer.prototype._hlpp = null;
	
	/** 
	*   
	*    Populates tile, tileUp, tileDown, tileLeft and tileRight with the values of those tiles found in tileMap.
	*    
	* @memberof BasicPlatformer.prototype 
	* @method getValuesOfCloseTiles
	* @param map 
    * 
	*/
    BasicPlatformer.prototype.getValuesOfCloseTiles = function(map) {
		
		var fpx = Math.floor(this.x);
        var fpy = Math.floor(this.y);
		
        this.tile = tabageos.BlitMath.checkTileValueAt(fpx,fpy,map||this.tileMap,this._tW,this._tH);
        this.tileUp = tabageos.BlitMath.checkTileValueAt(fpx,fpy-this._tH,map||this.tileMap,this._tW,this._tH);
        this.tileDown = tabageos.BlitMath.checkTileValueAt(fpx,fpy+this._tH,map||this.tileMap,this._tW,this._tH);
        this.tileLeft = tabageos.BlitMath.checkTileValueAt(fpx-this._tW,fpy,map||this.tileMap,this._tW,this._tH);
        this.tileRight = tabageos.BlitMath.checkTileValueAt(fpx+this._tW,fpy,map||this.tileMap,this._tW,this._tH);
		
	};
	
	/** 
	*   
	*    Returns true if the values match.
	*    
	* @memberof BasicPlatformer.prototype 
	* @method valuesMatch
	* @param val1 {Object}
	* @param val2 {Object}
    * @returns {Boolean} Returns true if the values match.
	*/
    BasicPlatformer.prototype.valuesMatch = function(val1, val2) {
		var r = false;
		if(val1[0] || val1[0] === 0) {
			var i = 0; var l = val1.length;
			for(i; i < l;i++) {
				if(val1[i] != val2[i]) {
					r = false; break;
				} else { r = true; }
			}
		} else {
			if(val1 == val2) { r = true; }
		}
		return r;
	};
	
	/** 
	*   
	*    This method becomes part of this class' CanvasAnimation's changeDirectionAnimation function.
    *    This class utilizes this method to add ladder climbing functionality and the 'climb' animation.
	*    
    *    The ladder tile value is defined during construction, then if a climb animation is defined,
    *    when on the ladder the class will switch to the climb animation. The ladder tile value should be a tile the BasicPlatformer does not collide with.
    *
	* @memberof BasicPlatformer.prototype 
	* @method _addedToChangeDirectionAni
	* @param left 
	* @param right 
	* @param up 
	* @param down 
	* @param keepAniIndex 
	* @param noIdle 
    * 
    *
    * @see CanvasAnimation#changeDirectionAnimation
	*/
    BasicPlatformer.prototype._addedToChangeDirectionAni = function(left, right, up, down, keepAniIndex, noIdle) {
		var btns = this._playerRef._controllerRef.buttons;
		if(this._playerRef.ladderValue) {
			
			this._playerRef.getValuesOfCloseTiles();
			var qpr = this._playerRef;
			if(!up && !left && !right && qpr.valuesMatch(qpr.tileDown, qpr.ladderValue) && !qpr.valuesMatch(qpr.tileUp, qpr.ladderValue)) {
				this._playerRef._veloc.y = 0;
				this._playerRef._grounded = 1;this._playerRef._state = 1;
			}
			if(btns.up && (qpr.valuesMatch(qpr.tileUp, qpr.ladderValue) ||  qpr.valuesMatch(qpr.tile, qpr.ladderValue) ||  qpr.valuesMatch(qpr.tileDown, qpr.ladderValue)) ) {
				this._playerRef._veloc.y = 0;
				this._playerRef._pos.y -= 1;
				this._playerRef.y -= 1;
				this._playerRef.onLadder = 1;
				if(this.animationSpecs.climb) { 
					this.currentAnimation = "climb";
				}
			} else if( (btns.down) && qpr.valuesMatch(qpr.tileDown, qpr.ladderValue) ) {
				this._playerRef._veloc.y = 0;
				this._playerRef._pos.y += 1;
				this._playerRef.y += 1;
				this._playerRef.onLadder = 1;
				if(this.animationSpecs.climb) {
					this.currentAnimation = "climb";
				}
			} else {
				this._playerRef.onLadder = 0;
			}
		
		}
	
	};
	
	tabageos.BasicPlatformer = BasicPlatformer;
	
})();



(function() { 

	'use strict';
	/**
    * 
    *   This constructor does nothing, all methods of this class are static.  
    * 
    * 
	* @classdesc A class of static methods that aid in drawing a tileset onto a canvas. And aid 2D Array manipulation.
    *  One of the core Classes of the library.
    *   
	*
	* @class BlitMath
	* 
	*
	*/
    function BlitMath() {
		
		
		
	}
    BlitMath.globalImageSource = null;
    BlitMath.ignoredY = 0;
    BlitMath.pPointPool = [];
    BlitMath.ignored = 0;
    BlitMath.ignoredArrays = [];
    BlitMath.basicPattern = null;
    BlitMath.levelPieceFunction = null;
    BlitMath.ignorSet = [];
    BlitMath.aLevelPiece = null;
	BlitMath._mpoint = new tabageos.MoverPoint();
	BlitMath._rect = new tabageos.Rectangle();
	/** 
    * Used in some calls to define the width and height of each individual tile draw.
	*  Default is 16x16. See BlitSpecs.
    * 
    * @see BlitSpecs
    *
    * @memberof BlitMath
	* @property _specs
	* @type {BlitSpecs}
    *
    */
    BlitMath._specs = new tabageos.BlitSpecs(16,16,0);
	
    BlitMath.levelPieceFactory = function() {
        return BlitMath.aLevelPiece;
    };
	
    BlitMath.getPositionPoint = function() {
        if (BlitMath.pPointPool.length <= 0) {
            while (BlitMath.pPointPool.length < 50) {
                BlitMath.pPointPool[BlitMath.pPointPool.length] = new tabageos.MoverPoint();
            }
        }
        return BlitMath.pPointPool.pop();
    };
	/** 
    *
    * 
    *  Returns BlitMath._specs
    *
    * @memberof BlitMath
	* @method getSpecs
    *
    */
    BlitMath.getSpecs = function() {
        if (!BlitMath._specs) {
            BlitMath._specs = new tabageos.BlitSpecs();
        }
        return BlitMath._specs;
    };
	/** 
    *
    * 
    *  Sets BlitMath._specs
    *
    * @memberof BlitMath
	* @method setSpecs
	* @param toThis {BlitSpecs}
    *
    */
    BlitMath.setSpecs = function(toThis) {
        BlitMath._specs = toThis;
    };
	/** 
    *
    * Compares the two values and returns true if they match.
	* If each value is a Number it compares the numnbers.
	* If each value is a Array it itterates through each array and if each value in the arrays matchs then it returns true.
    * 
    *
    * @memberof BlitMath
	* @method valuesMatch
	* @param val1 {Number|Array}
	* @param val2 {Number|Array}
    * @returns {Boolean}
    */
	BlitMath.valuesMatch = function(val1, val2) {
		var r = false;
		if(val1[0] || val1[0] === 0) {
			var i = 0; var l = val1.length;
			for(i; i < l;i++) {
				if(val1[i] != val2[i]) {
					r = false; break;
				} else { r = true; }
			}
		} else {
			if(val1 == val2) { r = true; }
		}
		return r;
	};
	/** 
	*   
	*    Draws squares from a 2D Array pattern of integers. 
	*    
	* @memberof BlitMath
	* @method drawSquaresFromPattern
	* @param subject {CanvasObject} The CanvasObject to draw the squares on.
	* @param pattern {Array} The 2D Array of integers that defines the pattern to draw.
	* @param squareWidth {Number} The width of each square, default is 16.
	* @param squareHeight {Number} The height of each square, default is 16.
	* @param colorValues {Object} An Object containing the string html color value each square should be, each value in the pattern would be associated with a color, for example {1:"#6495ed",2:"#ff00ff",3:"#c8c8c8"}
	*        
    * 
	*/
    BlitMath.drawSquaresFromPattern = function(subject,pattern,squareWidth,squareHeight,colorValues) {

        var i = 0; var j = 0;var val; var col = -1;var vc = 0;
        squareWidth = squareWidth || 16; squareHeight = squareHeight || 16;
        for(i; i < pattern.length;i++) {
            j= 0;
            for(j; j < pattern[i].length; j++) {

                val = pattern[i][j];
				if(val[0] === 0 || val[0]) { vc = val[0]; } else { vc = val; }
                if(colorValues && colorValues[vc]) {
                    col = colorValues[vc];
                } else {
                    col = -1;
                }
				if( col != -1 ) {
					subject.context.fillStyle = col;
					subject.context.fillRect(j * squareWidth, i * squareHeight, squareWidth, squareHeight);
				}
            }

        }
    }; 
	
	/** 
	*   
	*    Draws squares from a 2D Array pattern of integers/arrays using just a defined area of the pattern, not the whole pattern.
	*    
	* @memberof BlitMath
	* @method drawSquaresFromAreaOfPattern
	* @param subject {CanvasObject} The CanvasObject to draw the squares on.
	* @param pattern {Array} The 2D Array of integers or arrays that defines the pattern to draw.
	*                 when the inner values of the 2D Array are arrays this method uses just the first number in the inner array to get the number that will define the color of the tile.
	                  for example [7,5]  7 would be the number used.
	* @param startC {Number} The column in the pattern to start from.
	* @param endC {Number} The column in the pattern to end at.
	* @param startR {Number} The row in the pattern to start from.
	* @param endR {Number} The row in the pattern to end at.
	* @param squareWidth {Number} The width of each square, default is 16.
	* @param squareHeight {Number} The height of each square, default is 16.
	* @param colorValues {Object} An Object containing the color each square should be, each value in the pattern would be associated with a color.
	*        
	* @param toPointOffsetX {Number} Optional offset of the horizontal positon of the result.
	* @param toPointOffsetY {Number} Optional offset of the vertical position of the result.
    * 
	*/
	BlitMath.drawSquaresFromAreaOfPattern = function(subject,pattern,startC, endC, startR, endR,squareWidth,squareHeight,colorValues, toPointOffsetX, toPointOffsetY) {
		
		
		var val; var col = -1;var vc = 0;
		
		var ri =  startC;
        var rl = endC;
        var ci =  startR;
        var cl = endR;
		
		var destY;
               
        var destX;
		
        squareWidth = squareWidth || 16; squareHeight = squareHeight || 16;
        for(ri; ri < rl;ri++) {
            ci= startR;
            for(ci; ci < cl; ci++) {

                val = pattern[ri][ci];
				if(val[0] === 0 || val[0]) { vc = val[0]; } else { vc = val; }
                if(colorValues && colorValues[vc]) {
                    col = colorValues[vc];
                } else {
					if(vc != 0) {
						col = 0;
					} else { col = -1; }
                }
				if( col != -1 ) {
					
					destY = (toPointOffsetY || 0) + ((ri - startC) * squareHeight);
					destX = (toPointOffsetX || 0) + ((ci - startR) * squareWidth);
					
					subject.context.fillStyle = col;
					subject.context.fillRect(destX, destY, squareWidth, squareHeight);
				}
            }

        }
		
		
	};
	/**
	* Draws the pattern onto the subject.
	*
	*
	* @memberof BlitMath
	* @method patternBlit
	* @param subject {CanvasObject} the CanvasObject to draw to
	* @param source {Img} an html Image or loaded png/jpg file.
	* @param pattern {Array} <pre> A 2D Array that, by default, holds Integers that denote the x index of each tile to draw from. 
	*	The y index to draw from, for this method, is by default defined by BlitMath._specs.blitIndex. 
	*      For example:  
    *      var pattern = [  
	*			[ 1, 1, 1 ], 
	*			[ 1, 0, 1 ], 
	*			[ 1, 1, 1 ] 
	*		]; 
	*   By default, to get the exact x position where in the source to draw from, this method multiplies BlitMath._specs.blitWidth *  each number in the patterns inner arrays.
	*   By default, each y position is determined by BlitMath._specs.blitHeight * BlitMath._specs.blitIndex.   BlitMath._specs is an instance of the BlitSpecs Class.
    *
    *    By default BlitMath._specs has a blitWidth of 16 and blitHeight of 16 and blitIndex of 0.
    *    To change BlitMath._specs construct a new BlitSpecs instance, for example:    
    *
    *    BlitMath._specs = new tabageos.BlitSpecs(16,16);
    *    BlitMath._specs.blitIndex = 0;
    *     
    *    patternBlit(subject,source,pattern);
    *
    *    ---
	*  
	*   To change how the x index or y index is determined you can pass in a indexXMethod and/or indexYMethod.
	*  For example you could use decimal numbers to denote x and y index as follows:
	*   
	*   var pattern = [   
	*		[ 1.4, 1.4, 1.4],
	*		[ 1.4, 0.0, 1.4],
	*		[ 1.4, 1.4, 1.4]
	*   ];
	*   
    *   Then you need to define functions that would return the index values:
    *
	*   var xInd = function(num) { return Math.floor(num); } //in this example: 1 or 0
	*   var yInd = function(num)  { return tabageos.splitNumberAtDecimal(num); }//in this example: 4 or 0
	*
    *   and pass those functions during the patternBlit call:
    *
    *
	*   patternBlit(subject,source, pattern, xInd, yInd);
    *
    *    Each x index is multiplied by BlitMath._specs.blitWidth to determine the x position in the source to draw from.
    *   Each y index is multipled by BlitMath._specs.blitHeight.
    *
    *   The problem encountered when using decimals is that numbers with trailing zeros, for example: 1.10   would return 1 and 1, not 1 and 10.
    *   So for the location of drawing from a sprite sheet it is not ideal.
    *
    *   ---
    *
    *   Another option is to use bitwise operations to combine the values; 1 and 4 bitwsie combine as 65540.
    *   
    *   var pattern = [
    *       [tabageos.combineTwoNumbers(1,4), tabageos.combineTwoNumbers(1,4), tabageos.combineTwoNumbers(1,4)],
    *       [tabageos.combineTwoNumbers(1,4), tabageos.combineTwoNumbers(0,0),  tabageos.combineTwoNumbers(1,4)],
    *       [tabageos.combineTwoNumbers(1,4), tabageos.combineTwoNumbers(1,4), tabageos.combineTwoNumbers(1,4)]
    *   ];
    * 
    *    (you can use the combineTwoNumbers method as above, or you can use the ArrayMaker tool found on the tabageos site to make combined arrays for you)   
    *
    *    var xInd = function(num) { return tabageos.getAFromCombined(num); }
    *    var yInd = function(num) { return tabageos.getBFromCombined(num); }
    *   
    *    patternBlit(subject, source, pattern, xInd, yInd);
    *
    * 
    *  ---
    *
    *   So the patternBlit method allows you to define how the x and y index is calibrated, or by default it expects just x indexes.
    *
    *   If you have a special kind of way you like to set up your array values, patternBlit is what you would use, passing in functions that return x and y index based on your values.
    *  
    *    The specificaPatternBlit method takes only arrays that have [y,x]  values, for example:
    *    var pattern = [
    *      [ [4,1],[4,1],[4,1] ],
    *      [ [4,1],[0,0],[4,1] ],
    *      [ [4,1],[4,1],[4,1] ] 
    *    ];
    *    
    *    The combinedPatternBlit method takes only arrays that have bitwise combined xy values.
    *    
    *   </pre>
    *
	*
	* @param indexXMethod {Function} an optional method that would take a value in the array and return a x index, if not defined then the value itself is used as x index. 
	* @param indexYMethod {Function} an optional method that would take a value in the array and return a y index, if not defined then BlitMath._specs.blitIndex is used as y index.
	* @param toPointOffsetX {Number} an optional x offset to offset the x position of the whole drawing on the canvas.
	* @param toPointOffsetY {Number} an optional y offset to offset the y position of the whole drawing on the canvas.
	* 
	*
	*/
    BlitMath.patternBlit = function(subject, source, pattern, indexXMethod, indexYMethod, toPointOffsetX, toPointOffsetY) {
        var ri =  0;
        var rl = pattern.length;
        var ci =  0;
        var cl = pattern[0].length;
        var bitRect = new tabageos.Rectangle();
        var blitPoint = new tabageos.MoverPoint();
        for (ri = 0; ri < rl; ri++) {
            for (ci = 0; ci < cl; ci++) {
                var rowPatt = pattern[ri];
                var tileNum = indexXMethod ? indexXMethod(rowPatt[ci]) : rowPatt[ci];
				
                var indexY = indexYMethod ? indexYMethod(rowPatt[ci]) : BlitMath._specs.blitIndex;
				
                if (BlitMath.ignorSet.indexOf(tileNum) != -1) {
                    tileNum = BlitMath.ignored;
                    indexY = 0;
                }
                var destY = (toPointOffsetY || 0) + (ri * BlitMath._specs.blitHeight);
                var cx = ci;
                var destX = (toPointOffsetX || 0) + (cx * BlitMath._specs.blitWidth);
                var sourceX = tileNum * BlitMath._specs.blitWidth;
                var sourceY = indexY * BlitMath._specs.blitHeight;
				
                bitRect.width = BlitMath._specs.blitWidth;
                bitRect.height = BlitMath._specs.blitHeight;
                bitRect.x = sourceX;
                bitRect.y = sourceY;
                blitPoint.x = destX;
                blitPoint.y = destY;
                subject.copyPixels(source, bitRect, blitPoint);
            }
        }
    };
	
	
    /** 
	*   
	*    Draws from a 2D Array pattern using just a defined area of the pattern, not the whole pattern.
	*    
	* @memberof BlitMath
	* @method patternAreaBlit
	* @param subject {CanvasObject} The CanvasObject to draw on.
	* @param source {Img} The source image to draw from. The spritesheet/tileset.
	* @param pattern {Array} The 2D Array that defines the pattern to draw. For this method any 2D Array containing any kind of values can be used. You can define how to calculate each tile index by passing methods to this method.
	* @param startC {Number} The column in the pattern to start from.
	* @param endC {Number} The column in the pattern to end at.
	* @param startR {Number} The row in the pattern to start from.
	* @param endR {Number} The row in the pattern to end at.
	* @param indexXMethod {Function} A method to call on each tile value that will return the x index of the tile in the pattern.
	*						If a x method is not defined the tile value will be used as the x index.
	* @param indexYMethod {Function} A method to call on each value that will return the y index of the tile in the pattern.
	*						If a y method is not defined, Blith._specs.blitIndex will be used for every y index.
	* 
	* @param toPointOffsetX {Number} Optional offset of the horizontal positon of each square.
	* @param toPointOffsetY {Number} Optional offset of the vertical position of each square.
    * 
	*/
    BlitMath.patternAreaBlit = function(subject, source, pattern, startC, endC, startR, endR,indexXMethod, indexYMethod, toPointOffsetX, toPointOffsetY) {
        var ri =  startC;
        var rl = endC;
        var ci =  startR;
        var cl = endR;
        var bitRect = BlitMath._rect;
        var blitPoint = BlitMath._mpoint;
        for (ri; ri < rl; ri++) { ci =  startR;
            for (ci; ci < cl; ci++) {
                var rowPatt = pattern[ri];
               
                var tileNum = indexXMethod ? indexXMethod(rowPatt[ci]) : rowPatt[ci];
				
                var indexY = indexYMethod ? indexYMethod(rowPatt[ci]) : BlitMath._specs.blitIndex;
				
                if (BlitMath.ignorSet.indexOf(tileNum) != -1) {
                    tileNum = BlitMath.ignored;
                    indexY = 0;
                }
                var destY =  ((ri - startC) * BlitMath._specs.blitHeight) + (toPointOffsetY || 0);
                var cx = ci;
                var destX =  ((cx - startR) * BlitMath._specs.blitWidth)  + (toPointOffsetX || 0);
                var sourceX = tileNum * BlitMath._specs.blitWidth;
                var sourceY = indexY * BlitMath._specs.blitHeight;
				
                bitRect.width = BlitMath._specs.blitWidth;
                bitRect.height = BlitMath._specs.blitHeight;
                bitRect.x = sourceX;
                bitRect.y = sourceY;
                blitPoint.x = destX;
                blitPoint.y = destY;
                subject.copyPixels(source, bitRect, blitPoint);
            }
        }
    };
	
	/** 
	*   
	*    Draws from a 2D Array pattern of [y,x] values using just a defined area of the pattern, not the whole pattern.
	*    
	* @memberof BlitMath
	* @method specificPatternAreaBlit
	* @param subject {CanvasObject} The CanvasObject to draw on.
	* @param source {Img} The source image to draw from. The spritesheet/tileset.
	* @param pattern {Array} A 2D Array of [y,x] values that defines the pattern to draw.
	* @param startC {Number} The column in the pattern to start from.
	* @param endC {Number} The column in the pattern to end at.
	* @param startR {Number} The row in the pattern to start from.
	* @param endR {Number} The row in the pattern to end at.
	* @param toPointOffsetX {Number} Optional offset of the horizontal positon of each square.
	* @param toPointOffsetY {Number} Optional offset of the vertical position of each square.
    * 
	*/
	BlitMath.specificPatternAreaBlit = function(subject, source, pattern, startC, endC, startR, endR,toPointOffsetX, toPointOffsetY) {
        var ri =  startC;
        var rl = endC;
        var ci =  startR;
        var cl = endR;
        var bitRect = BlitMath._rect;
        var blitPoint = BlitMath._mpoint;
        for (ri; ri < rl; ri++) { ci =  startR;
            for (ci; ci < cl; ci++) {
                var rowPatt = pattern[ri];
               
                var tileNum =rowPatt[ci][0];
				
                var indexY = rowPatt[ci][1];
				
                if (BlitMath.ignorSet.indexOf(tileNum) != -1) {
                    tileNum = BlitMath.ignored;
                    indexY = 0;
                }
                var destY =  ((ri - startC) * BlitMath._specs.blitHeight) + (toPointOffsetY || 0);
                var cx = ci;
                var destX =  ((cx - startR) * BlitMath._specs.blitWidth)  + (toPointOffsetX || 0);
                var sourceX = tileNum * BlitMath._specs.blitWidth;
                var sourceY = indexY * BlitMath._specs.blitHeight;
				
                bitRect.width = BlitMath._specs.blitWidth;
                bitRect.height = BlitMath._specs.blitHeight;
                bitRect.x = sourceX;
                bitRect.y = sourceY;
                blitPoint.x = destX;
                blitPoint.y = destY;
                subject.copyPixels(source, bitRect, blitPoint);
            }
        }
    };
    /** 
    *
    * 
    *  Draws pattern onto subject. Pattern is a 2D Array of bitwise combined numbers. 
    *
    * @memberof BlitMath
	* @method combinedPatternBlit
	* @param subject {CanvasObject} CanvasObject to draw on
	* @param source {Img} The image to draw from.
	* @param pattern {Array} A 2D Array of bitwise combined integers that defines each tile to draw.
	* @param toPointOffsetX {Number} An optional horizontal offset of the whole result.
	* @param toPointOffsetY {Number} An optional vertical offset of the whole result.
    *
    */
    BlitMath.combinedPatternBlit = function(subject, source, pattern, toPointOffsetX, toPointOffsetY) {
        var ri =  0;
        var rl = pattern.length;
        var ci =  0;
        var cl = pattern[0].length;
        var bitRect = BlitMath._rect;
        var blitPoint = BlitMath._mpoint;
        for (ri = 0; ri < rl; ri++) {
            for (ci = 0; ci < cl; ci++) {
                var rowPatt = pattern[ri];
                var tileNum = rowPatt[ci] >> 16; 
				
                var indexY = rowPatt[ci] & 0xFFFF; 
				
                if (BlitMath.ignorSet.indexOf(tileNum) != -1) {
                    tileNum = BlitMath.ignored;
                    indexY = 0;
                }
                var destY = (toPointOffsetY || 0) + (ri * BlitMath._specs.blitHeight);
                var cx = ci;
                var destX = (toPointOffsetX || 0) + (cx * BlitMath._specs.blitWidth);
                var sourceX = tileNum * BlitMath._specs.blitWidth;
                var sourceY = indexY * BlitMath._specs.blitHeight;
				
                bitRect.width = BlitMath._specs.blitWidth;
                bitRect.height = BlitMath._specs.blitHeight;
                bitRect.x = sourceX;
                bitRect.y = sourceY;
                blitPoint.x = destX;
                blitPoint.y = destY;
                subject.copyPixels(source, bitRect, blitPoint);
            }
        }
    };
	/** 
    *
    * 
    *  Assuming that subject is a 2D Array of [y,x] or [x,y] values, this method will switch the inner position of the numbers in each value, so [y,x] would become [x,y]. 
    *
    * @memberof BlitMath
	* @method xySwitch
	* @param subject {CanvasObject} a 2D Array of [y,x] or [x,y] values.
	* 
    *
    */
    BlitMath.xySwitch = function(subject, xFitst, yFirst) {
        var a;
        var b;
        var hold0;
        var hold1;
        var i = 0;
        var bi = 0;
        for (i = 0; i < subject.length; i++) {
            a = subject[i];
            bi = 0;
            for (bi = 0; bi < a.length; bi++) {
                b = a[bi];
                hold0 = b.shift();
                hold1 = b.shift();
                b[0] = hold1;
                b[1] = hold0;
            }
        }
    };
	/** 
    *
    * 
    *  Draws pattern onto subject. Pattern is a 2D Array of [y,x] index values.
	*  The inner values can also be [y,x,y,x] in which case it draws two layers, the ending y,x first.
    *
    * @memberof BlitMath
	* @method specificPatternBlit
	* @param subject {CanvasObject} CanvasObject to draw on
	* @param source {Img} The image to draw from.
	* @param pattern {Array} A 2D Array of [y,x] values that defines each tile to draw. y,x are the index of the tile not the exact position.
	* @param tw {Number} The width of each tile. BlitMath._specs.blitWidth is used. this param effects only how each tile is actually drawn on screen.
	* @param th {Number} The height of each tile. BlitMath._specs.blitHeight is used. this param effects only how each tile is actually drawn on screen.
    *
    */
    BlitMath.specificPatternBlit = function(subject, source, pattern, tw, th) {
        var ri = 0;
        var rl = pattern.length;
        var ci = 0;
        var cl = pattern[0].length;
        var bitRect = new tabageos.Rectangle();
        var blitPoint = new tabageos.MoverPoint();
        for (ri = 0; ri < rl; ri++) {
            for (ci = 0; ci < cl; ci++) {
                var rowPatt = pattern[ri];
                var tileNum = rowPatt[ci][1];
                var yIndex = rowPatt[ci][0];
                var ia = 0;
                var a;
                for (ia = 0; ia < BlitMath.ignoredArrays.length; ia++) {
                    a = BlitMath.ignoredArrays[ia];
                    if (rowPatt[ci][0] == a[0] && rowPatt[ci][1] == a[1]) {
                        tileNum = BlitMath.ignored;
                        yIndex = BlitMath.ignoredY;
                        break;
                    }
                }
                var destY = ri * BlitMath._specs.blitHeight;
                var cx = ci;
                var destX = cx * BlitMath._specs.blitWidth;
                var sourceX = tileNum * BlitMath._specs.blitWidth;
                var sourceY = yIndex * BlitMath._specs.blitHeight;
                bitRect.width = BlitMath._specs.blitWidth;
                bitRect.height = BlitMath._specs.blitHeight;
                var ox;
                var oy;
                if (rowPatt[ci][2] && rowPatt[ci][3]) {
                    ia = 0;
                    ox = rowPatt[ci][3];
                    oy = rowPatt[ci][2];
                    for (ia; ia < BlitMath.ignoredArrays.length; ia++) {
                        a = BlitMath.ignoredArrays[ia];
                        if (rowPatt[ci][2] == a[0] && rowPatt[ci][3] == a[1]) {
                            ox = BlitMath.ignored;
                            oy = BlitMath.ignoredY;
                            break;
                        }
                    }
                    bitRect.x = ox * BlitMath._specs.blitWidth;
                    bitRect.y = oy * BlitMath._specs.blitHeight;
                    blitPoint.x = destX;
                    blitPoint.y = destY;
                    subject.copyPixels(source, bitRect, blitPoint, tw || BlitMath._specs.blitWidth, th || BlitMath._specs.blitHeight);
                }
                bitRect.x = sourceX;
                bitRect.y = sourceY;
                blitPoint.x = destX;
                blitPoint.y = destY;
                subject.copyPixels(source, bitRect, blitPoint, tw || BlitMath._specs.blitWidth, th || BlitMath._specs.blitHeight);
            }
        }
    };
	
	
	
	
    BlitMath.patternActionEvent = new tabageos.PatternActionEvent();
	/**
	*
	* An Array of tile values that is used by the dispatchFunctionAssignments method.
	* dispatchFunctionAssignments will dispatch a PatternActionEvent for each value from this array that it finds in the 2D pattern passed to it.
	* @memberof BlitMath
	* @type {Array}
	*
	*/
    BlitMath.functionAssignments = [];
	/** 
    *
    * 
    *  Goes through the pattern and each time it finds a value from BlitMath.functionAssignments 
	*  it dispatches a PatternActionEvent that gets handled by a method you define.
	*   That method would get a PatternActionEvent that contains information of the tile that caused the event.
    *
    * @memberof BlitMath
	* @method dispatchFunctionAssignments
	* @param eventDispatcher {EventDispatcher} EventDispatcher to use for the events.
	* @param handlerFunctionString {String} String name of the handler function to call. The function should expect an event as a param.
	* @param handlerObject {Object} Object that contains the handler function.
	* @param pattern {Array} The 2D Array to iterate through and dispatch an event each time a value from functionAssignments is found.
	* @param tileWidth {Number} The width of each tile.
	* @param tileHeight {Number} The height of each tile.
    *
    */
    BlitMath.dispatchFunctionAssignments = function(eventDispatcher, handlerFunctionString, handlerObject, pattern, tileWidth, tileHeight) {
        if (handlerFunctionString != null) {
            eventDispatcher.addEventListener(tabageos.PatternActionEvent.FUNCTION_ASSIGNMENT, handlerFunctionString, handlerObject);
            if (BlitMath.patternActionEvent.type == tabageos.PatternActionEvent.PATTERN_ACTION_EVENT) {
                BlitMath.patternActionEvent = new tabageos.PatternActionEvent(0,0,0,0,false,tabageos.PatternActionEvent.FUNCTION_ASSIGNMENT,0,0);
            }
        }
        var a;
        var i = 0;
        var len;
        var row = 0;
        var ob;
        var fa;
        var fi;
        var oa;
        a = pattern;
        if (!a)
            return;
        row = -1;
        var alen = a.length;
        var ai = 0;
        for (ai = 0; ai < alen; ai++) {
            row++;
            oa = a[ai];
            len = oa.length;
            i = 0;
            for (i = 0; i < len; i++) {
                ob = oa[i];
                fi = 0;
                for (fi = 0; fi < BlitMath.functionAssignments.length; fi++) {
                    fa = BlitMath.functionAssignments[fi];
                    if ( ((typeof fa == 'array' || typeof fa =='object') && fa[0] == ob[0] && fa[1] == ob[1])  || (typeof fa == 'number' && fa === ob) ) {
						
                        BlitMath.patternActionEvent.tileValue = ob;
                        BlitMath.patternActionEvent.tileXIndex = i;
                        BlitMath.patternActionEvent.tileYIndex = row;
                        BlitMath.patternActionEvent.x = (i * tileWidth);
                        BlitMath.patternActionEvent.y = (row * tileHeight);
                        BlitMath.patternActionEvent.patternIndex = 0;
                        BlitMath.patternActionEvent.typeToBe = tabageos.PatternActionEvent.FUNCTION_ASSIGNMENT;
                        eventDispatcher.dispatchEvent(BlitMath.patternActionEvent);
                        break;
                    }
                }
            }
        }
        if (handlerFunctionString != null) {
            eventDispatcher.removeEventListener(tabageos.PatternActionEvent.FUNCTION_ASSIGNMENT, handlerFunctionString, handlerObject);
        }
    };
	/** 
    *
    * 
    *  Returns true if the tile value at the position is not 0 or [0,0].
    *
    * @memberof BlitMath
	* @method isATileAt
	* @param x {Number} A x position to check. The position not the index.
	* @param y {number} A y position to check. The position not the index.
	* @param patt {Array} 2D Array to check.
	* @param tileWidth {Number} The width of each tile.
	* @param tileHeight {Number} The height of each tile.
    * @returns {Boolean}
    */
    BlitMath.isATileAt = function(x, y, patt, tileWidth, tileHeight) {
        var i = 0;
        var j = 0;
        var tx;
        var ty;
        var result = false;
        var l = patt.length;
        var jl = patt[0].length;
        var a;
        for (i = 0; i < l; i++) {
            for (j = 0; j < jl; j++) {
                tx = j * tileWidth;
                ty = i * tileHeight;
                if ((x >= tx && x < tx + tileWidth) && (y >= ty && y < ty + tileHeight)) {
                    a = patt[i][j];
                    if ((a[0] && a[0] != 0) || (a[1] && a[1] != 0) || a != 0) {
                        result = true;
                        break;
                    }
                }   
            }
        }
        return result;
    };
	/**
	*
	* An Array of TileData Objects. You can use BlitMath.convertToTileDataHolder to create this Array.
	*
	*
	* @memberof BlitMath
	* @type {Array}
	*
	*/
    BlitMath.tileDataHolder = [];
	/** 
    *
    * 
    *  Converts the internal values of a 1D Array into TileData Objects and returns a new array of TileData Objects.
	*  This method is used inside of the convertToTileDataHolder method.
    *
    * @memberof BlitMath
	* @method convertInternalValues
	* @param arr {Array} a 1D Array 
	* @param tileWidth {Number} The width of each tile.
	* @param tileHeight {Number} The height of each tile.
	* @param yIndex {Number} The y index of each tile.
	* 
    * @returns {Array}
    */
    BlitMath.convertInternalValues = function(arr, tileWidth, tileHeight, yIndex) {
        var a = [];
        var i = 0;
        for (i; i < arr.length; i++) {
            var mp = new tabageos.MoverPoint(i * tileWidth,yIndex * tileHeight);
            var td = new tabageos.TileData(mp,arr[i]);
            a.push(td);
        }
        return a;
    };
    /** 
    *
    * 
    *  Returns true if the tile value at the position does not contain any 0's.
	*  For values such as [0,1] this value returns false. Whereas isATileAt would return true.
    *
    * @memberof BlitMath
	* @method isANonZeroTileAt
	* @param x {Number} x position to check.
	* @param y {Number} y position to check.
	* @param patt {Array} 2D Array to check.
	* @param tileWidth {Number} The width of each tile.
	* @param tileHeight {Number} The height of each tile.
	* 
	* @returns {Boolean}
    *
    */
    BlitMath.isANonZeroTileAt = function(x, y, patt, tileWidth, tileHeight) {
        var i = 0;
        var j = 0;
        var tx;
        var ty;
        var result = false;
        var l = patt.length;
        var jl = patt[0].length;
        var a;
        for (i = 0; i < l; i++) {
            for (j = 0; j < jl; j++) {
                tx = j * tileWidth;
                ty = i * tileHeight;
                if ((x >= tx && x < tx + tileWidth) && (y >= ty && y < ty + tileHeight)) {
                    a = patt[i][j];
                    if ((a[0] && a[1] && a[0] != 0 && a[1] != 0) || a != 0) {
                        result = true;
                        break;
                    }
                }
                ;
            }
        }
        return result;
    };
	/** 
    *
    * 
    *  Adds values to the end of a 2D Array. The Array can have values of integers or [y,x] inner arrays.
    *
    * @memberof BlitMath
	* @method addSpecificValuesToMultiArray
	* @param mda {Array} 2D Array of integers or arrays.
	* @param values {Array} 1D Array of values to add. The index of each value in this array matches the row index in the mda.
	*                       Each value is pushed into the end of each repsective row of the mda.
	* 
	* 
    *
    */
	BlitMath.addSpecificValuesToMultiArray = function(mda,values) {
		var i = 0;
        var l = mda.length;
        var ina;
        var j = 0;
        var jl;
       
        var na;
        for (i; i < l; i++) {
            ina = mda[i];
            j = 0;
            jl = mda[i].length;
			if(mda[i][0] && mda[i][0].length) { 
				
			
				for (j; j < jl; j++) {
					
					if(j == jl-1) {
						
						ina[j+1] = values[i] || [0,0];
					}
					
					
				}
			
			} else {
				
				for (j; j < jl; j++) {
					
					if(j == jl-1) {
						
						ina[j+1] = values[i] || 0;
					}
				}
				
			}
        }
		
	};
	/** 
    *
    * 
    *  Clones a 2D Array and returns the new array.
	* 
    *
    * @memberof BlitMath
	* @method cloneMultiArray
	* @param mda {Array} 2D Array to clone.
	* 
	* 
    * @returns {Array}
    */
    BlitMath.cloneMultiArray = function(mda) {
        
        var i = 0;
        var l = mda.length;
        var ina;
        var j = 0;
        var jl;
        var clone = [];
        var na;
        for (i; i < l; i++) {
            ina = mda[i];
            j = 0;
            jl = mda[i].length;
			if(mda[i][0] && mda[i][0].length) { 
				clone[i] = [];
			
				for (j; j < jl; j++) {
					na = [(typeof ina[j][0] == "number" ? ina[j][0] + 1 - 1 : ina[j][0]), (typeof ina[j][1] == "number" ? ina[j][1] + 1 - 1 : ina[j][1])];
					clone[i].push(na);
					if (ina[j][2]) {
						na.push((typeof ina[j][2] == "number" ? ina[j][2] + 1 - 1 : ina[j][2]));
					}
					if (ina[j][3]) {
						na.push((typeof ina[j][3] == "number" ? ina[j][3] + 1 - 1 : ina[j][3]));
					}
				}
			
			} else {
				clone[i] = [];
				for (j; j < jl; j++) {
					clone[i].push(ina[j]+1-1);	
				}
				
			}
        }
        return clone;
    };
	/** 
    *
    * 
    *  Replaces value with rZero rOne.
	*  If the mda is a 2D Array of [y,x] arrays the matching values y is replaced with rZero and x with rOne.
	*  If the mda is a 2D Array of integers the matching value is replaced with rZero.
    *
    * @memberof BlitMath
	* @method replaceAllOfValueFromMultiArray
	* @param mda {Array} 2D Array to clone.
	* @param value {Number|Array} The value to replace.
	* @param rZero {Number} Number to replace interger/first index in [y,x] value with.
	* @param rOne {Number} Number to replace second index with.
    * @returns {Array}
    */
	BlitMath.replaceAllOfValueFromMultiArray = function(mda, value, rZero, rOne) {
		
		var i = 0;
        var l = mda.length;
        var ina;
        var j = 0;
        var jl;
        var clone = [];
        var na;
        for (i; i < l; i++) {
            ina = mda[i];
            j = 0;
            jl = mda[i].length;
			if(mda[i][0] && mda[i][0].length) { 
				clone[i] = [];
			
				for (j; j < jl; j++) {
					na = [(typeof ina[j][0] == "number" ? ina[j][0] + 1 - 1 : ina[j][0]), (typeof ina[j][1] == "number" ? ina[j][1] + 1 - 1 : ina[j][1])];
					if(na[0] == value[0] && na[1] == value[1]) {
						na = [rZero || 0,rOne || 0];
					}
					clone[i].push(na);
					if (ina[j][2]) {
						na.push((typeof ina[j][2] == "number" ? ina[j][2] + 1 - 1 : ina[j][2]));
					}
					if (ina[j][3]) {
						na.push((typeof ina[j][3] == "number" ? ina[j][3] + 1 - 1 : ina[j][3]));
					}
				}
			
			} else {
				clone[i] = [];
				for (j; j < jl; j++) {
					clone[i].push(ina[j] != value ? ina[j]+1-1 : (rZero || 0));	
				}
				
			}
        }
		return clone;
		
	};
	
	/** 
    *
    * 
    *  Replaces the values from the 2D Array.
	*  If the mda is a 2D Array of [y,x] arrays each matching values y is replaced with rZero and x with rOne.
	*  If the mda is a 2D Array of integers each matching value is replaced with rZero.
    *
    * @memberof BlitMath
	* @method replaceValuesFromMultiArray
	* @param mda {Array} 2D Array to clone.
	* @param values {Array} 1D Array of the values to replace.
	* @param rZero {Number} Number to replace interger/first index in [y,x] value with.
	* @param rOne {Number} Number to replace second index with.
    * @returns {Array}
    */
	BlitMath.replaceValuesFromMultiArray = function(mda, values, rZero, rOne) {
		
		var i = 1; var l = values.length;
		var a = BlitMath.replaceAllOfValueFromMultiArray(mda,values[0], rZero,rOne);;
		for(i; i < l;i++) { 
			a = BlitMath.replaceAllOfValueFromMultiArray(a,values[i], rZero,rOne);
			
		}
		return a;
		
	};
	/** 
    *
    * 
    *  Resets BlitMath.tileDataHolder
	*
	* @memberof BlitMath
	* @method resetTileDataHolder
    *
    */
    BlitMath.resetTileDataHolder = function() {
        BlitMath.tileDataHolder = [];
    };
	/** 
    *
    * 
    *  Converts a 2D Array into BlitMath.tileDataHolder which holds each tile value as a TileData Object.
    *
    * @memberof BlitMath
	* @method convertToTileDataHolder
	* @param patt {Array} 2D Array to convert into BlitMath.tileDataHolder
	* @param tileWidth {Number} the width of each tile.
	* @param tileHeight {Number} the eight of each tile.
	* 
    *
    */
    BlitMath.convertToTileDataHolder = function(patt, tileWidth, tileHeight) {
        BlitMath.tileDataHolder = [];
        var i = 0;
        for (i; i < patt.length; i++) {
            BlitMath.tileDataHolder.push(BlitMath.convertInternalValues(patt[i], tileWidth, tileHeight, patt.indexOf(patt[i])));
        }
    };
	/** 
    *
    * 
    *  Returns the tile value at the x y position in the patt.
    *
    * @memberof BlitMath
	* @method checkTileValueAt
	* @param x {Number} x position to check.
	* @param y {Number} y position to check.
	* @param patt {Array} 2D Array to check.
	* @param tileWidth {Number} the width of each tile.
	* @param tileHeight {Number} the eight of each tile.
	* @param indexHolderPoint {MoverPoint} An optional MoverPoint that would store the index of the result.
    * @returns {Object}
    */
    BlitMath.checkTileValueAt = function(x, y, patt, tileWidth, tileHeight, indexHolderPoint) {
        var result = 0;
        var i = 0;
        var j = 0;
        var tx;
        var ty;
        var l = patt.length;
        var jl = patt[0].length;
        for (i = 0; i < l; i++) { 
            for (j = 0; j < jl; j++) { 
                tx = j * tileWidth;
                ty = i * tileHeight;
                if ((x >= tx && x < tx + tileWidth) && (y >= ty && y < ty + tileHeight)) {
                    if(indexHolderPoint) { indexHolderPoint.x = j+1-1; indexHolderPoint.y = i+1-1; }
                    result = patt[i][j];
                    return result;
                }
            }
        }
        return result;
    };
	BlitMath._wasmGetIndexFromArbitraryBitwise = null;
	BlitMath._wasmLeftBit = null;
	BlitMath._wasmRightBit =  null;
	/** 
    *
    * 
    *  Assings the index of the tile found in the 2D Array to indexHolderPoint.
	* So to get the tile value you would then use pattern[indexHolderPoint.y][indexHolderPoint.x]
	* This method does not return anything.
    *
    * @memberof BlitMath
	* @method fasterCheckTileValueAt
	* @param x {Number} x position to check.
	* @param y {Number} y position to check.
	* @param pattLength {Number} The length of the outer array of the 2D Array; patt.length.
	* @param innerPattLength {Number} The length of the inner arrays in the 2D Array; patt[0].length.
	* @param tileWidth {Number} the width of each tile.
	* @param tileHeight {Number} the eight of each tile.
	* @param indexHolderPoint {MoverPoint} An optional MoverPoint that would store the index of the result.
    *
    */
	BlitMath.fasterCheckTileValueAt = function(x, y, pattLength,innerPattLength, tileWidth, tileHeight, indexHolderPoint) {

		var i = 0;
		var j = 0;
        var tx = 0;
        var ty = 0;
        var l = pattLength;
        var jl = innerPattLength;
        for (i = 0; i < l; i++) {
            for (j = 0; j < jl; j++) {
                tx = j * tileWidth;
                ty = i * tileHeight;
                if ((x >= tx && x < tx + tileWidth) && (y >= ty && y < ty + tileHeight)) {
                    if(indexHolderPoint) { indexHolderPoint.x = j+1-1; indexHolderPoint.y = i+1-1; }
                    return;
                }
            }
        }
		return; 
    };
	/** 
    *
    * 
    *  Returns the tile found in the pattern as a TileData Object.
	*  If the pattern is not BlitMath.tileDataHolder, BlitMath.tileDataHolder will be created using the pattern.
    *
    * @memberof BlitMath
	* @method getTileDataAt
	* @param x {Number} x position to check.
	* @param y {Number} y position to check.
	* @param patt {Array} 2D Array of values.
	* @param tileWidth {Number} the width of each tile.
	* @param tileHeight {Number} the eight of each tile.
	* @returns {TileData}
    *
    */
    BlitMath.getTileDataAt = function(x, y, patt, tileWidth, tileHeight) {
        var result;
		
		
        if (!BlitMath.tileDataHolder || BlitMath.tileDataHolder.length <= 0) {
            BlitMath.convertToTileDataHolder(patt, tileWidth, tileHeight);
        }
        var i = 0;
        var j = 0;
        var tx;
        var ty;
        var l = patt.length;
        var jl = patt[0].length;
        for (i = 0; i < l; i++) {
            for (j = 0; j < jl; j++) {
                tx = j * tileWidth;
                ty = i * tileHeight;
                if ((x >= tx && x < tx + tileWidth) && (y >= ty && y < ty + tileHeight)) {
                    result = BlitMath.tileDataHolder[i][j];
                    return result;
                }
            }
        }
        return result || null;
    };
	/** 
    *
    * 
    *  Draws one tile from pattern onto subject using source. Using a specific style 2D Array of [y,x] values. 
    *
    * @memberof BlitMath
	* @method specificBlit
	* @param subject {CanvasObject} CanvasObject to draw on.
	* @param source {Img} The image to draw from.
	* @param pattern {Array} A 2D Array of [y,x] or [y,x,y,x] values.
	* @param tw {Number} The width of each tile.
	* @param th {Number} The height of each tile.
	* @param xIn {number} The x index of the tile to draw.
	* @param yIn {Number} The y index of the tile to draw.
	*
    *
    */
    BlitMath.specificBlit = function(subject, source, pattern, tw, th, xIn, yIn) {
        var ri = yIn || 0;
        var ci = xIn || 0;
        var bitRect = new tabageos.Rectangle();
        var blitPoint = new tabageos.MoverPoint();
        var rowPatt = pattern[ri];
        var tileNum = rowPatt[ci][1];
        var yIndex = rowPatt[ci][0];
        var ia = 0;
        var a;
        for (ia = 0; ia < BlitMath.ignoredArrays.length; ia++) {
            a = BlitMath.ignoredArrays[ia];
            if (rowPatt[ci][0] == a[0] && rowPatt[ci][1] == a[1]) {
                tileNum = BlitMath.ignored;
                yIndex = BlitMath.ignoredY;
                break;
            }
        }
        var destY = ri * BlitMath._specs.blitHeight;
        var cx = ci;
        var destX = cx * BlitMath._specs.blitWidth;
        var sourceX = tileNum * BlitMath._specs.blitWidth;
        var sourceY = yIndex * BlitMath._specs.blitHeight;
        bitRect.width = BlitMath._specs.blitWidth;
        bitRect.height = BlitMath._specs.blitHeight;
        var ox;
        var oy;
        if (rowPatt[ci][2] && rowPatt[ci][3]) {
            ia = 0;
            ox = rowPatt[ci][3];
            oy = rowPatt[ci][2];
            for (ia; ia < BlitMath.ignoredArrays.length; ia++) {
                a = BlitMath.ignoredArrays[ia];
                if (rowPatt[ci][2] == a[0] && rowPatt[ci][3] == a[1]) {
                    ox = BlitMath.ignored;
                    oy = BlitMath.ignoredY;
                    break;
                }
            }
            bitRect.x = ox * BlitMath._specs.blitWidth;
            bitRect.y = oy * BlitMath._specs.blitHeight;
            blitPoint.x = destX;
            blitPoint.y = destY;
            subject.copyPixels(source, bitRect, blitPoint, tw || BlitMath._specs.blitWidth, th || BlitMath._specs.blitHeight);
        }
        bitRect.x = sourceX;
        bitRect.y = sourceY;
        blitPoint.x = destX;
        blitPoint.y = destY;
        subject.copyPixels(source, bitRect, blitPoint, tw || BlitMath._specs.blitWidth, th || BlitMath._specs.blitHeight);
    };
	/** 
    *
    * 
    *  Removes a tile from the map of specific [y,x] values using TileData and redraws the tile spot using specificBlit.
    *
    * @memberof BlitMath
	* @method removeTileData
	* @param td {TileData} The TileData to remove from map. You can use TileData.make to create a TileData from your value.
	* @param map {Array} 2D Array of [y,x] values. 
	* @param canvasObject {CanvasObject} The CanvasObject to draw on/clear.
	* @param img {Img} The image to use.
	* @param tw {Number} The width of each tile.
	* @param th {Number} The height of each tile.
	* @param clearWidth {number} will be same as tw.
	* @param clearHeight {Number} will be same as th.
	* @param tdh {Number|Boolean} If true map will not be used to create BlitMath.tileDataHolder, by default BlitMath.tileDataHolder is remade at the end of this method, using map. 
	*
    *
    */
    BlitMath.removeTileData = function(td, map, canvasObject, img, tw, th, clearWidth, clearHeight, tdh) {
        map[td.position.y / tw][td.position.x / th] = [0, 0];
        canvasObject.context.clearRect(td.position.x, td.position.y, tw, th);
        tabageos.BlitMath._specs.blitWidth = tw;
        tabageos.BlitMath._specs.blitHeight = th;
        tabageos.BlitMath.specificBlit(canvasObject, img, map, tw, th, td.position.x / th, td.position.y / tw);
        
        if (!tdh)
            tabageos.BlitMath.convertToTileDataHolder(map, tw, th);
    };
	/** 
    *
    * 
    *  Adds a value to a TileData based tile position in the map and redraws the tile spot.
    *
    * @memberof BlitMath
	* @method addValueToTileDataPosition
	* @param td {TileData} The TileData to remove from map. You can use TileData.make to create a TileData from your value.
	* @param value {Array} The [y,x] value to add.
	* @param map {Array} 2D Array of [y,x] values. 
	* @param canvasObject {CanvasObject} The CanvasObject to draw on/clear.
	* @param img {Img} The image to use.
	* @param tw {Number} The width of each tile.
	* @param th {Number} The height of each tile.
	* @param clearWidth {number} will be same as tw.
	* @param clearHeight {Number} will be same as th.
	* @param tdh {Number|Boolean} If true map will not be used to create BlitMath.tileDataHolder, by default BlitMath.tileDataHolder is remade at the end of this method, using map. 
	*
    *
    */
    BlitMath.addValueToTileDataPosition = function(td, value, map, canvasObject, img, tw, th, clearWidth, clearHeight, tdh) {
        map[td.position.y / tw][td.position.x / th] = value;
        canvasObject.context.clearRect(td.position.x, td.position.y, tw, th);
        tabageos.BlitMath._specs.blitWidth = tw;
        tabageos.BlitMath._specs.blitHeight = th;
        tabageos.BlitMath.specificBlit(canvasObject, img, map, tw, th, td.position.x / th, td.position.y / tw);
        
        if (!tdh)
            tabageos.BlitMath.convertToTileDataHolder(map, tw, th);
    };
	/** 
    *
    * 
    *  Adds a value to the position in the map and redraws the position using specificBlit.
    *
    * @memberof BlitMath
	* @method addValueToPosition
	* @param x {Number} The x index of the position.
	* @param y {Number} The y index of the position.
	* @param value {Object} The [y,x] value to add.
	* @param map {Array} A 2D Array of [y,x] values. 
	* @param canvasObject {CanvasObject} The CanvasObject to draw on/clear, if null no redraw happens.
	* @param img {Img} The image to use.
	* @param tw {Number} The width of each tile.
	* @param th {Number} The height of each tile.
	* @param clearWidth {number} will be same as tw.
	* @param clearHeight {Number} will be same as th.
	* @param tdh {Number|Boolean} If true map will not be used to create BlitMath.tileDataHolder, by default BlitMath.tileDataHolder is remade at the end of this method, using map. 
	*
    *
    */
    BlitMath.addValueToPosition = function(x, y, value, map, canvasObject, img, tw, th, clearWidth, clearHeight, tdh) {
        map[y / tw][x / th] = value;
		if(canvasObject) {
			canvasObject.context.clearRect(x, y,tw,  th);
			tabageos.BlitMath._specs.blitWidth = tw;
			tabageos.BlitMath._specs.blitHeight = th;
			tabageos.BlitMath.specificBlit(canvasObject, img, map, tw, th, x / th, y / tw);
		
			
			if (!tdh) {
				tabageos.BlitMath.convertToTileDataHolder(map, tw, th);
			}
		}
	};
	/** 
    *
    * 
    *  Returns an Array of MoverPoints that make up the path of tiles.
    *
    * @memberof BlitMath
	* @method getBasicPatternOf
	* @param thisTile {Number|Array} The value of the tile to make a path from.
	* @param patt {Array} A 2D Array of tile values.
	* @param tileWidth {Number} The width of each tile.
	* @param tileHeight {Number} The height of each tile.
	* @param leftToRight {Boolean} If false the search will begin from the right. Default is false.
    * @returns {Array}
    */
    BlitMath.getBasicPatternOf = function(thisTile, patt, tileWidth, tileHeight, leftToRight) {
        var i = 0;
        var j = 0;
        var txre;
        var tyre;
        var l = patt.length;
        var jl = patt[0].length;
        var result = [];
        var nmp;
        if(!leftToRight) {
            for (i = 0; i < l; i++) {
                for (j = 0; j < jl; j++) {
                    txre = j * tileWidth;
                    tyre = i * tileHeight;
                    if(typeof patt[i][j] != 'number') {
                        if (patt[i][j][0] == thisTile[0] && patt[i][j][1] == thisTile[1]) {
                            nmp = new tabageos.MoverPoint(txre,tyre);
                            result.push(nmp);

                        }
                    } else {
                        if (patt[i][j] == thisTile) {
                            nmp = new tabageos.MoverPoint(txre,tyre);
                            result.push(nmp);
                        }
                    }
                }
            }

        } else { i = l-1; j = 0;
            for (i; i >= 0; i--) {

               
                    txre = j * tileWidth;
                    tyre = i * tileHeight;
                    if(typeof patt[i][j] != 'number') {
                        if (patt[i][j][0] == thisTile[0] && patt[i][j][1] == thisTile[1]) {
                            nmp = new tabageos.MoverPoint(txre,tyre);
                            result.push(nmp);

                        }
                    } else {
                        if (patt[i][j] == thisTile) {
                            nmp = new tabageos.MoverPoint(txre,tyre);
                            result.push(nmp);
                        }
                    }
               
               if(i === 0 && j < jl-1) {
                   j++; i = l-1;
               }
            }
        }

        return result;
    };
    tabageos.BlitMath = BlitMath;
})();

(function() { 
	'use strict';
    /** 
    * @class BlitSpecs
    *  @classdesc
	*   Used by the BlitMath Class to define the default width and height for blit calls. 
	*    
	*    
	* 
	* @param blitWidth {Number}
	* @param blitHeight  {Number}
	*  
	*/
    function BlitSpecs(blitWidth, blitHeight) {
        this.blitWidth = blitWidth || 16;
        this.blitHeight = blitHeight || 16;
		this.blitIndex = 0;
    };
	/** 
	*   
	*    
	*    
	* @memberof BlitSpecs 
	*  
	*/
    BlitSpecs.prototype.blitWidth = 16;
    /** 
	*   
	*    
	*    
	* @memberof BlitSpecs 
	*  
	*/
    BlitSpecs.prototype.blitHeight = 16;
    /** 
	*   
	*    
	*    
	* @memberof BlitSpecs 
	*  
	*/
    BlitSpecs.prototype.blitIndex = 0;
	/** 
	*   
	*    
	*    
	* @memberof BlitSpecs 
	*  
	*/
    BlitSpecs.prototype.constructor = BlitSpecs;
    tabageos.BlitSpecs = BlitSpecs;
})();

(function() { 

	'use strict';

    /** 
	*   
    *
    * @class BlittedTraveler
    * @classdesc
	*    A Traveler that implements CanvasAnimation.
	*    It has separate methods that can use a WayDeterminer for collision, but has no collision stuffs during its update/move method.
	*    
    * @see Traveler
    * @see TravelerSkeleton
    * @see CanvasAnimation
    * @implements CanvasAnimation
	* 
	* @param source {Image} An Img element to draw from.
	* @param canvasObject {CanvasObject} the CanvasObject to draw on.
	* @param fromRect {Rectangle} The Rectangle area in the source to draw from.
	* @param x {Number} x  location of the BlittedTraveler
	* @param y {Number} y location of the Boolean
	* @param width {Number} Width of the BlittedTraveler
	* @param height {Number} Height of the BlittedTraveler
	* @param dt  {Number} Delta time, default is tabageos.TimeKeeper._sae
	*  
	*/
    function BlittedTraveler(source, canvasObject, fromRect, x, y, width, height, dt) {
		tabageos.TravelerSkeleton.call(this,x,y,width,height);
		tabageos.Traveler.call(this,x,y,width,height);
        if (source || canvasObject) {
            this.init(source, canvasObject, fromRect, x, y, width, height);
        }
        this.health = 100;
		this._deltaTime = dt || tabageos.TimeKeeper._sae;
    };
	/** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.constructor = BlittedTraveler;
	BlittedTraveler.prototype = Object.create(tabageos.TravelerSkeleton.prototype);
	Object.assign(BlittedTraveler.prototype, tabageos.Traveler.prototype);
    /** 
	*   
	*    Used like a super method.
	*    
	* @memberof BlittedTraveler.prototype 
	* @method init
	* @param source 
	* @param canvasObject 
	* @param fromRect 
	* @param x 
	* @param y 
	* @param width 
	* @param height 
    * @returns {} 
	*/
    BlittedTraveler.prototype.init = function(source, canvasObject, fromRect, x, y, width, height) {
        this._source = source;
        this._canvas = canvasObject;
		this.toPoint = new tabageos.MoverPoint();
        this.fromRect = fromRect || new tabageos.Rectangle(0,0,32,32);
        this.x = x || 0;
        this.y = y || 0;
        this.height = height || 0;
        this.width = width || 0;
        this.travelType = null;
		this.blankRect = new tabageos.Rectangle();
        this.boundingMethod = tabageos.BoundMethods.boundTo;
        this.mass = 10;
        this.avoidSpace = 35;
        this.maxSpeed = 14;
        this.maxForce = 25;
		this.personalSpace = 20;
		this.visionDistance = 20;
		this.circleDistance = 20;
		this.spreadDistance = 20;
		this.separationDistance = 20;
		this.bypassAvoidDistance = null;
		this.followDistance = 20;
		this.easeProximity = 20;
		this.wanderProximity = 20;
		this.wanderAngle = 30;
		this.wanderRadius = 20;
		this.wanderRange = 20;
		this.avoidDistance = 20;
		this.health = 100;
		this.fromWidthOffset = 0;
		this.fromHeightOffset = 0;
		this._blitType = 0;
    };
    /** 
	*   
	* @type Rectangle
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.fromRect = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.fromWidthOffset = 0;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.fromHeightOffset = 0;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.alphaPoint = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.fillColor = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.mergeAlpha = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.toPoint = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.blankRect = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.alphaBitmapData = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.travelType = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.boundingMethod = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.personalSpace = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.visionDistance = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.circleDistance = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.spreadDistance = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.separationDistance = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.bypassAvoidDistance = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.maxForce = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.forceApplier = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.followDistance = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.easeProximity = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.wanderProximity = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.wanderAngle = 30;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.wanderRadius = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.wanderRange = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.wanderOffset = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.avoidDistance = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.health = 100;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.avoidSpace = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.mass = 5;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.maxSpeed = 20;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype._source = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype._canvas = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype._blitType = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype._destination = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype._wallObject = null;
	/** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype._deltaTime = null;
    /** 
	*   
	*    Returns _destination
	*    
	* @memberof BlittedTraveler.prototype 
	* @method getDestination
    * @returns {MoverPoint} 
	*/
    BlittedTraveler.prototype.getDestination = function() {
        return this._destination;
    };
    /** 
	*   
	*    Sets _destination
	*    
	* @memberof BlittedTraveler.prototype 
	* @method setDestination
	* @param toThis 
    * 
	*/
    BlittedTraveler.prototype.setDestination = function(toThis) {
        this._destination = toThis;
    };
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler.prototype 
	* @method getSource
    * @returns {Image} 
	*/
    BlittedTraveler.prototype.getSource = function() {
        return this._source;
    };
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler.prototype 
	* @method setSource
	* @param toThis 
    * 
	*/
    BlittedTraveler.prototype.setSource = function(toThis) {
        this._source = toThis;
    };
    /** 
	*   
	*    Returns the blit type, see setBlitType
	*    
	* @memberof BlittedTraveler.prototype 
	* @method getBlitType
	* @see setBlitType
    * @returns {String} 
	*/
    BlittedTraveler.prototype.getBlitType = function() {
        var s = tabageos.BlittedTraveler.JUST_COPY;
        if (this._blitType == 1)
            s = tabageos.BlittedTraveler.FILL_RECT_THEN_COPY;
        if (this._blitType == 2)
            s = tabageos.BlittedTraveler.COPY_THEN_COPY;
        return s;
    };
    BlittedTraveler.JUST_COPY = "justCopy";
    BlittedTraveler.FILL_RECT_THEN_COPY = "fillRectTheCopy";
    BlittedTraveler.COPY_THEN_COPY = "copyThenCopy";
    /** 
	*   
	*    Set the blit type.
	*    Default is BlittedTraveler.JUST_COPY which just copies the animation onto the canvas.
	* 	 A blit type of BlittedTraveler.FILL_RECT_THEN_COPY will fill the animation area with the .fillColor color first then copy the animation over the same spot.
	*	 A blit type of BlittedTraveler.COPY_THEN_COPY will copy with the .blankRect first.
	*    
	* @memberof BlittedTraveler.prototype 
	* @method setBlitType
	* @param toThis {String}  BlittedTraveler.JUST_COPY  or BlittedTraveler.FILL_RECT_THEN_COPY or BlittedTraveler.COPY_THEN_COPY.
    * @returns {} 
	*/
    BlittedTraveler.prototype.setBlitType = function(toThis) {
        if (toThis == tabageos.BlittedTraveler.JUST_COPY)
            this._blitType = 0;
        if (toThis == tabageos.BlittedTraveler.FILL_RECT_THEN_COPY)
            this._blitType = 1;
        if (toThis == tabageos.BlittedTraveler.COPY_THEN_COPY) {
            if (!this.blankRect.width || !this.blankRect.height) {
                throw new Error("blankRect has no width or height, please set blankRect for copy_then_copy style blitting");
            }
            this._blitType = 2;
        }
    };
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler.prototype 
	* @method getCanvas
    * @returns {CanvasObject} 
	*/
    BlittedTraveler.prototype.getCanvas = function() {
        return this._canvas || null;
    };
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler.prototype 
	* @method setCanvas
	* @param toThis {CanvasObject}
    * 
	*/
    BlittedTraveler.prototype.setCanvas = function(toThis) {
        this._canvas = toThis;
    };
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler.prototype 
	* @method getWallObject
    * @returns {Rectangle} 
	*/
    BlittedTraveler.prototype.getWallObject = function() {
        return this._wallObject;
    };
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler.prototype 
	* @method setWallObject
	* @param toThis 
    * 
	*/
    BlittedTraveler.prototype.setWallObject = function(toThis) {
        this._wallObject = toThis;
    };
    /** 
	*   Applies forceApplier to _veloc with maxForce and mass.
	*   then truncates _veloc to maxSpeed.
	*   then adds _veloc to _pos.
	*   If a .wallObject is defined and a .boundingMethod definded, _pos will be updated by the boundingMehtod.
	*   then _pos is applied to x and y.
	*    
	*    
	* @memberof BlittedTraveler.prototype 
	* @method update
    * 
	*/
    BlittedTraveler.prototype.update = function() {
		
		this.forceApplier.truncate(this.maxForce);
        this.forceApplier.divide(this.mass, 0);
        this._veloc.add(this.forceApplier.multiply(this._deltaTime,0), 0);
        this.forceApplier.reset();
        this._veloc._length = 0;
        this._veloc._angle = 0;
        this._veloc.truncate(this.maxSpeed);
        this._pos.addBy(this._veloc.x * this._deltaTime, this._veloc.y * this._deltaTime, 0);
        if (this._wallObject)
            this.boundingMethod(this, this._wallObject);
		
        this.x = this._pos.x+1-1;
        this.y = this._pos.y+1-1;
        this._autoAnimation();
    };
    /** 
	*   Applies forceApplier to _veloc with maxForce and mass.
	*   then truncates _veloc to maxSpeed.
	*   then adds _veloc to _pos.
	*   If a .wallObject is defined and a .boundingMethod definded, _pos will be updated by the boundingMehtod.
	*   then _pos is applied to x and y.
	*    
    * In this class update and move do the same thing, you can call either one for movement.
	*    
	* @memberof BlittedTraveler.prototype 
	* @method move
    * 
	*/
    BlittedTraveler.prototype.move = function() {
		
		this.forceApplier.truncate(this.maxForce);
        this.forceApplier.divide(this.mass, 0);
        this._veloc.add(this.forceApplier.multiply(this._deltaTime,0), 0);
        this.forceApplier.reset();
        this._veloc._length = 0;
        this._veloc._angle = 0;
        this._veloc.truncate(this.maxSpeed);
        this._pos.addBy(this._veloc.x * this._deltaTime, this._veloc.y * this._deltaTime, 0);
        if (this._wallObject)
            this.boundingMethod(this, this._wallObject);
		
        this.x = this._pos.x+1-1;
        this.y = this._pos.y+1-1;
        this._autoAnimation();
    };
    /** 
	*   
	*    calls changeDirectionAnimation then animate then blit or _canvas.context.fillRect if there is no _source or currentAnimation.
	*    
	* @memberof BlittedTraveler.prototype 
	* @method _autoAnimation
    * 
	*/
    BlittedTraveler.prototype._autoAnimation = function() {

        if(this._autoAnimate && this._source && this.currentAnimation.length >= 1) {

			this.changeDirectionAnimation(this._veloc.x < 0,this._lastVeloc.x > 0, this._veloc.y < 0, this._veloc.y > 0);
					
			this.animate();
			this.blit();
        
        } else if(this._autoAnimate) {

            this._canvas.context.fillRect(this.x,this.y,this.width,this.height);
            
        }

    };
    /** 
	*   
	*    call travelType with _destination, then move then blit
	*    
	* @memberof BlittedTraveler.prototype 
	* @method travel
    * 
	*/
    BlittedTraveler.prototype.travel = function() {
        if (this.travelType != null)
            this.travelType(this._destination);
        this.move();
        if(!this._autoAnimate) this.blit();
    };
    /** 
	*   
	*    Uses a WayDeterminer to check if the future position is clear via the WayDeterminer.wayIsClear method.
	*    
	* @memberof BlittedTraveler.prototype 
	* @method checkFutureWayIsClear
	* @param wd {WayDeterminer}
    * @returns {Boolean}
    */
    BlittedTraveler.prototype.checkFutureWayIsClear = function(wd) {
        var futurePosition = this._pos.add(this._veloc.clone().truncate(this.maxSpeed));
        return wd.wayIsClear(futurePosition.x, futurePosition.y);
    };
    /** 
	*   
	*    Uses a WayDeterminer to check if the current position is clear via the WayDeterminer.wayIsClear method.
	*    
	* @memberof BlittedTraveler.prototype 
	* @method checkCurrentWayIsClear
	* @param wd {WayDeterminer}
    * @returns {Boolean}
	*/
    BlittedTraveler.prototype.checkCurrentWayIsClear = function(wd) {
        return wd.wayIsClear(this.x, this.y);
    };
    /** 
	*   
	*    Uses a WayDeterminer to check if the past position is clear.
	*    
	* @memberof BlittedTraveler.prototype 
	* @method checkPastWayIsClear
	* @param wd {WayDeterminer}
    * @returns {Boolean} 
	*/
    BlittedTraveler.prototype.checkPastWayIsClear = function(wd) {
        var pastPosition = this._pos.subtract(this._veloc.clone().truncate(this.maxSpeed));
        return wd.wayIsClear(pastPosition.x, pastPosition.y);
    };
    /** 
	*   
	*    Uses fromRect and toPoint to draw from this._source onto this._canvas.
	*    
	* @memberof BlittedTraveler.prototype 
	* @method blit
	* @param r {Rectanlge} An alternate fromRect to draw from, default is fromRect which is changed by the animate function.
	* @param p {MoverPoint} An alternate toPoint to draw to, default is this.x and this.y.
	* @param igf {Boolean} Ignore fromWidthOffset and fromHeightOffset if set fromWidth/HeightOfsset will be ignored.
    * 
	*/
    BlittedTraveler.prototype.blit = function(r, p, igf) {
        if (r)
            this.fromRect = r;
        if (p) {
            this.toPoint = p;
        } else if (!igf) {
            this.toPoint.x = this.x - (this.fromWidthOffset != 0 ? this.fromWidthOffset/2 : 0);
            this.toPoint.y = this.y - this.fromHeightOffset;
        } else if(igf) {
            this.toPoint.x = this.x;
            this.toPoint.y = this.y;
        }
        if (this._blitType == 1)
            this._canvas.fillRect(this.fromRect, this.fillColor);
        if (this._blitType == 2)
            this._canvas.copyPixels(this._source, this.blankRect, this.toPoint);
        this._canvas.copyPixels(this._source, this.fromRect, this.toPoint, this.fromRect.width, this.fromRect.height);
    };
    
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.currentAnimation = "";
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.animationSpecs = {
        left: [4, [1, 2, 3, 4, 5, 6, 7]]
    };
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.animationIndexOrder;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.ani = 0;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.blitIndex;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.fromXOffset = 0;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.fromYOffset = 0;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.lastAnim = "";
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.toPoint;
	/** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.onlyHorizontalAnimations = 0;
    BlittedTraveler._onlyHorizontalAni = 0;
	/** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype.addedAnimationChanges = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype._cpos;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype._addedPos;
	/** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype._playerRef = null;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype._inDelay = 0;
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype._autoAnimate = 0;
	/** 
	*   
	*    From CanvasAnimation see CanvasAnimation, BlittedTraveler fully implements CanvasAnimation.
	*    
	* @memberof BlittedTraveler.prototype 
	* @method defineAnimation
	* @param animationName 
	* @param arrayOfXYIndexValues 
	* @param yIndex 
    * 
	*/
    BlittedTraveler.prototype.defineAnimation = function(animationName, arrayOfXYIndexValues, yIndex) {
        
        this.animationSpecs[animationName] = [yIndex || 1, arrayOfXYIndexValues];  
        
    };
    /** 
	*   
	*    Returns _pos
	*    
	* @memberof BlittedTraveler.prototype 
	* @method getPosition
    * @returns {MoverPoint} 
	*/
    BlittedTraveler.prototype.getPosition = function() {
        return this._pos;
    };
	
	/** 
	*   
	*    Returns the position but not a reference to _pos. _cpos and _addedPos are used by this method.
	*    
	* @memberof BlittedTraveler.prototype 
	* @method getCAPosition
	* @param addedX {Number}
	* @param addedY {Number}
    * @returns {MoverPoint} 
	*/
    BlittedTraveler.prototype.getCAPosition = function(addedX, addedY) {
        if (!this._cpos || !this._addedPos) {
            this._cpos = new tabageos.MoverPoint();
            this._addedPos = new tabageos.MoverPoint();
        }
        this._cpos.x = this.x;
        this._cpos.y = this.y;
        if (addedX || addedY) {
            this._addedPos.x = this.x + (addedX || 0);
            this._addedPos.y = this.y + (addedY || 0)
        }
        return ((addedX || addedY) ? this._addedPos : this._cpos);
    };
	
	
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler.prototype 
	* @method changeLeftRightUpDownAnimation
	* @param left 
	* @param right 
	* @param up 
	* @param down 
	* @param dontKeepAniIndex 
    * 
	*/
    BlittedTraveler.prototype.changeLeftRightUpDownAnimation = function(left,right,up,down, dontKeepAniIndex) {
		
		if(!up && !down && !left && !right && this.lastAnim) {
			this.currentAnimation = this.lastAnim;
		} else {
			this.currentAnimation = up ? "up" : (down ? "down" : (left ? "left" : "right"));
		}
		if (!dontKeepAniIndex) {
            this.lastAnim = this.currentAnimation;
        }
		
	};
	/** 
	*   from CanvasAnimation
	*    
	*    
	* @memberof BlittedTraveler.prototype 
	* @method changeFaceAnimation
	* @param toFace 
	* @param keepAniIndex 
    *
	*/
    BlittedTraveler.prototype.changeFaceAnimation = function(toFace, keepAniIndex) {
			
			if (this.y >= toFace.y + toFace.height ) {
				this.currentAnimation = "up";
			}
			if (this.y + this.height < toFace.y  ) {
				this.currentAnimation = "down";
			}
			if (this.x > toFace.x + toFace.width) {
				this.currentAnimation = "left";
			}
			if (this.x + this.width < toFace.x ) {
				this.currentAnimation = "right";
			}
			if (keepAniIndex) {
				this.lastAnim = this.currentAnimation;
			}
			
	};
	
	/** 
	*   
	*    
	*    
	* @memberof BlittedTraveler.prototype 
	* @method getDirectionOfAnimation
	* @param currentAni 
	* @param onlyLeftRight 
	* @param onlyUpDown 
    * @returns {String} 
	*/
    BlittedTraveler.prototype.getDirectionOfAnimation = function(currentAni, onlyLeftRight, onlyUpDown) {
		
		var r = "";
		if(!onlyUpDown) {
			if(currentAni.indexOf("left") != -1) r = "left";
			if(currentAni.indexOf("right") != -1) r = "right";
		}
		if(!onlyLeftRight) {
			if(currentAni.indexOf("up") != -1) r = "up";
			if(currentAni.indexOf("down") != -1) r = "down";
		}
		return r;
		
	};
	
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler.prototype 
	* @method changeDirectionAnimation
	* @param left 
	* @param right 
	* @param up 
	* @param down 
	* @param keepAniIndex 
	* @param noIdle 
    * 
	*/
    BlittedTraveler.prototype.changeDirectionAnimation = function(left, right, up, down, keepAniIndex, noIdle) {
        var helda = this.currentAnimation + "";
        this.currentAnimation = (up ? "up" : (down ? "down" : "")) + (left ? "left" : (right ? "right" : (((up || down) && this.lastAnim.match("left")) ? "left" : (((up || down) && this.lastAnim.match("right")) ? "right" : ""))));
        if (this.currentAnimation.length <= 0) {
            this.currentAnimation = this.lastAnim.replace("idle", "").replace("down", "").replace("up", "") + (noIdle ? "" : "idle");
		}
		if (this.currentAnimation.length <= 0) {
			this.currentAnimation = helda;
		}
        if (keepAniIndex) {
            this.lastAnim = this.currentAnimation;
        }

		if(this.addedAnimationChanges && this._playerRef) {
			
			this.addedAnimationChanges(left, right, up, down, keepAniIndex, noIdle);
		}

    };
    /** 
	*   
	*    implementation of CanvasAnimation.animate, BlittedTraveler fully implements CanvasAnimation.
	*    
	* @memberof BlittedTraveler.prototype 
	* @method animate
	* @param thrott 
    * 
	*/
    BlittedTraveler.prototype.animate = function(thrott) {
        this.blitIndex = this.animationSpecs[this.currentAnimation] ? this.animationSpecs[this.currentAnimation][0] : this.blitIndex;
        this.animationIndexOrder = this.animationSpecs[this.currentAnimation] ? this.animationSpecs[this.currentAnimation][1] : this.animationIndexOrder;
        if (this.ani >= this.animationIndexOrder.length - 1) {
            this.ani = 0;
        } else {
            this.ani += (thrott || (this.onlyHorizontalAnimations === 0 ? 2 : 1) );
        }
        if (this.currentAnimation != this.lastAnim || (this.onlyHorizontalAnimations === 0 && this.ani > this.animationIndexOrder.length - 2) ) {
            this.ani = 0;
        }
        this.lastAnim = this.currentAnimation;
		var ain = Math.floor(this.ani); if(ain % 2 != 0) { ain = ain -1; }
		var aival = this.animationIndexOrder[ain];
		if(this.onlyHorizontalAnimations === 0) { 
			
				this.fromRect.x = this.animationIndexOrder[ain] * (this.width + this.fromXOffset);
				this.fromRect.y = this.animationIndexOrder[ain+1] * (this.height + this.fromYOffset);
			
		} else {
			this.fromRect.x = this.animationIndexOrder[ain] * (this.width + this.fromXOffset);
			this.fromRect.y = this.blitIndex * (this.height + this.fromYOffset);
		}
        this.fromRect.width = this.width + this.fromWidthOffset;
        this.fromRect.height = this.height + this.fromHeightOffset;
    };
	/** 
	*   
	*    Returns true if the current animation has finished.
	*    
	* @memberof BlittedTraveler.prototype 
	* @method finishedCurrentAnimation
    * @returns {Boolean} 
	*/
    BlittedTraveler.prototype.finishedCurrentAnimation = function() {
		if(!this.animationSpecs[this.currentAnimation]) {
			return false; 
		} else {
			return (this.ani >= this.animationSpecs[this.currentAnimation][1].length - 1);
		}
	};
    /** 
	*   
	*    @private
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype._throttRef;
    /** 
	*   
	*    @private
	*    
	* @memberof BlittedTraveler 
	*  
	*/
    BlittedTraveler.prototype._cBB;
    /** 
	*   
	*    Delays a call to animate and blit
	*    
	* @memberof BlittedTraveler.prototype 
	* @method delayedAnimateAndBlitt
	* @param thrott {Number} The throttle to use for the animate call.
	* @param milliSecondDelay {Number} The amount of time in milliseconds to wait before calling animate and blit 
	* @param animation {String} The currentAnimation to use.
	* @param clearBeforeBlitt {Boolean} Clear the canvas before blit, default is false.
    * 
	*/
    BlittedTraveler.prototype.delayedAnimateAndBlitt = function(thrott, milliSecondDelay, animation,clearBeforeBlitt) {
        this._inDelay = 1;
        if(animation) {
            this.currentAnimation = animation;
        }
        this._throttRef = thrott || 0;
        this._cBB = clearBeforeBlitt || 0;
        var ref = this;
        window.setTimeout(function(e) { ref._delayedFunction(); }, milliSecondDelay);
    };
    /** 
	*   
	*    
	*    
	* @memberof BlittedTraveler.prototype 
	* @method _delayedFunction
	* @param e {Event}
    * 
	*/
    BlittedTraveler.prototype._delayedFunction = function(e) {
        if(this._inDelay) {
            this.animate(this._throttRef);
            if(this._cBB) {
                this._canvas.context.clearRect(this.x,this.y,this.width,this.height);
            }
            this.blitt();
            this._inDelay = 0;
        }
    };
    /** 
	*   
	*    Sorts and sets each _canvas property of this instance and the other BlittedTraveler passed.
	*    The one with the greater y plus offset will be on the topCanvas.
    * 
	* @memberof BlittedTraveler.prototype 
	* @method basicDepthSort
	* @param bt {BlittedTraveler}
	* @param topCanvas {CanvasObject}
	* @param bottomCanvas {CanvasObjet}
	* @param sortRadius {Number}
	* @param offset {Number}
    * @returns {Boolean} 
	*/
    BlittedTraveler.prototype.basicDepthSort = function(bt, topCanvas, bottomCanvas, sortRadius, offset) {
        var sorted = false;
        if (tabageos.GeometricMath.testForPointInCircle(this._pos, sortRadius, bt._pos)) {
            if (this.y > bt.y + offset) {
                this._canvas = topCanvas;
                bt._canvas = bottomCanvas;
            } else {
                this._canvas = bottomCanvas;
                bt._canvas = topCanvas;
            }
            sorted = true;
        }
        return sorted;
    };
    tabageos.BlittedTraveler = BlittedTraveler;
})();


(function() { 
	'use strict';
    /** 
	*   All methods of this class are static.
	*    
	* @class BoundMethods
    * @classdesc 
    *
    *   A class of static methods that would bound a mover to a rectangle in various ways.
    *   This class is utilized by classes that have a _wallObject Rectangle that can be set,
    *   and a boundMethod that can be set, which by default is set to one of these methods.
    *
    * @constructor
	*
    */
    function BoundMethods() {};
    /**
    *
    *
    *  Bounds the mover to the boundObject
    * @memberof BoundMethods
    * @method boundTo
    * @param mover {Mover} a Mover or Object with x y width height properties
    * @param boundObejct {Rectangle}
    */
	BoundMethods.boundTo = function(mover, boundObject) {
        var pos = mover.getPosition();
        var width = mover.width;
        var height = mover.height;
        if (pos.x + width >= boundObject.x + boundObject.width) {
            pos.x = boundObject.x + boundObject.width - width;
        }
        if (pos.x < boundObject.x) {
            pos.x = boundObject.x;
        }
        if (pos.y + height >= boundObject.y + boundObject.height) {
            pos.y = boundObject.y + boundObject.height - height;
        }
        if (pos.y < boundObject.y) {
            pos.y = boundObject.y;
        }
    };
    /**
    *
    *
    *  Bounces the mover off of the boundObject
    * @memberof BoundMethods
    * @method bounceOff
    * @param mover {Mover} a Mover or Object with x y width height properties
    * @param boundObejct {Rectangle}
    *
    */
    BoundMethods.bounceOff = function(mover, boundObject) {
        var pos = mover.getPosition();
        var width = mover.width;
        var height = mover.height;
        if (pos.x + width >= boundObject.x + boundObject.width) {
            pos.x = boundObject.x + boundObject.width - width;
            mover._veloc.x *= -1;
        }
        if (pos.x < boundObject.x) {
            pos.x = boundObject.x;
            mover._veloc.x *= -1;
        }
        if (pos.y + height >= boundObject.y + boundObject.height) {
            pos.y = boundObject.y + boundObject.height - height;
            mover._veloc.y *= -1;
        }
        if (pos.y < boundObject.y) {
            pos.y = boundObject.y;
            mover._veloc.y *= -1;
        }
    };
    /**
    *
    *
    *  When the move reaches the end of the boundObject it wraps back to the start.
    * @memberof BoundMethods
    * @method wrapAround
    * @param mover {Mover} a Mover or Object with x y width height properties
    * @param boundObejct {Rectangle}
    *
    */
    BoundMethods.wrapAround = function(mover, boundObject) {
        var pos = mover.getPosition();
        var width = mover.width;
        var height = mover.height;
        if (pos.x > boundObject.x + boundObject.width + width) {
            pos.x = boundObject.x - width;
        }
        if (pos.x < boundObject.x - width) {
            pos.x = boundObject.x + boundObject.width + width;
        }
        if (pos.y > boundObject.y + boundObject.height + height) {
            pos.y = boundObject.y - height;
        }
        if (pos.y < boundObject.y - height) {
            pos.y = boundObject.y + boundObject.height;
        }
    };
    tabageos.BoundMethods = BoundMethods;
})();

(function() { 

'use strict';

    /** 
	* 
    * @class CanvasAnimation
    * @classdesc
	*    Controls the animation of an image onto a CanvasObject
	*    
	* 
	* @param source {HTMLImg} The source image to draw from
	* @param canvasObject {CanvasObject} The CanvasObject to draw to
	* @param fromRect {Rectangle} The Rectangle that defines where on the source to draw from, if none is passed a Rectangle with 0,0, width, height is created.
	* @param [x=0] {Number} The x position of the CanvasAnimation
	* @param [y=0] {Number} The y position of the CanvasAnimation
	* @param [width=0] {Number} The width of the CanvasAnimation
	* @param [height=0]  {Number} The height of the CanvasAnimation
	*  
    *  
	*/
    function CanvasAnimation(source, canvasObject, fromRect, x, y, width, height) {
        if (source || canvasObject) {
            this.init(source, canvasObject, fromRect, x, y, width, height);
        }
    };
	
    CanvasAnimation.prototype.constructor = CanvasAnimation;
    /** 
	*   
	*    Used as a super method for possible extension of this class.
	*    
	* @memberof CanvasAnimation.prototype
	* @method init
	* @param source {HTMLImg} The source image to draw from
	* @param canvasObject {CanvasObject} The CanvasObject to draw to
	* @param fromRect {Rectangle} The Rectangle that defines where on the source to draw from
	* @param [x=0] {Number} The x position of the CanvasAnimation
	* @param [y=0] {Number} The y position of the CanvasAnimation
	* @param [width=0] width {Number} The width of the CanvasAnimation
	* @param [height=0] height  {Number} The height of the CanvasAnimation
    * 
	*/
    CanvasAnimation.prototype.init = function(source, canvasObject, fromRect, x, y, width, height) {
        this._source = source;
        this._canvas = canvasObject;
        this.currentAnimation = "";
        this.ani = 0;
		this.animationIndexOrder = null;
		this.animationSpecs = {left: [4, [1, 2, 3, 4, 5, 6, 7]]};
		this.blitIndex = 0;
        this.x = x || 0;
        this.y = y || 0;
        this.width = width || 0;
        this.height = height || 0;
        this.toPoint = new tabageos.MoverPoint();
        this.fromRect = fromRect || new tabageos.Rectangle(0,0,this.width,this.height);
		this.fromXOffset = 0;
		this.fromYOffset = 0;
		this.fromWidthOffset = 0;
		this.fromHeightOffset = 0;
		this.lastAnim = "";
		this._cpos = null;
		this._addedPos = null;
		this._inDelay = 0;
		this._throttRef = 0;
		this._cBB = 0;
        if(tabageos.CanvasAnimation._onlyHorizontalAni) {
            this.onlyHorizontalAnimations = 1;
        }
    };
    /** 
	*   The source image to draw from
	*    
	*    @type Image
	* @memberof CanvasAnimation
	*  
	*/
    CanvasAnimation.prototype._source;
    /** 
	*   
	*    The CanvasObject to draw to
	*    @type CanvasObject
	* @memberof CanvasAnimation
	*  
	*/
    CanvasAnimation.prototype._canvas;
    /** 
	*   
	*    The current animation to be displayed
	*    
	* @memberof CanvasAnimation
	*  @type String
	*/
    CanvasAnimation.prototype.currentAnimation = "";
    /** 
	*   
	*    Each animation is stored in the animationSpecs Object.
    *    Each property of animationSpecs is an animation name "left" "right" etc... holding an array of x and y indexes that define the animations frames.
    *    Each index is multiplied by the CanvasAnimation width and height to get the exact location in the source to draw from.
    *
    *   The first value in each animation Array is the all frames y index if onlyHorizontalAnimations is set. Then an inner array with the frame indexes.
    *   And in the case of onlyHorizontalAnimations being set, the inner Array would only have x indexes.
    *   By default onlyHorizontalAnimations is not set and the all frames y index is not used, but still present.
    *
    *   You can set the animationSpecs Object directly or you can use the defineAnimation method.
    *
    *   The animate method references the animation in animationSpecs using the currentAnimation property.
    *
    * @example
    *     animationSpecs = {
    *         "left":[0,[1,2,1,3,1,4]],
    *         "right":[0,[4,2,4,3,4,4]]
    *     };
    *
    * 
	*   
    *
	* @memberof CanvasAnimation
	*  @type Object
	*/
    CanvasAnimation.prototype.animationSpecs = {
        left: [4, [1, 2, 3, 4, 5, 6, 7]]
    };
    
    /**
    *
    * Used to define a new animation.
    *  
    * @param animationName {String} The name of the animation being defined.
    * @param arrayOfXYIndexValues {Array} An Array of the x,y index values that define each frame of the animation. 
    *                                       For example defineAnimation("left", [2,4,3,5,3,7,2,4,5,9]) would create a "left" animation.
    *                                       The array is read as x,y index pairs, with x being multipled by the CanvasAnimations width, and y by height to get the position in the source to draw from.
    *                                       To change the animation you set the currentAnimation property and then call the animate method.
    *                                       To display the animation you call the blit method.
    *
    *
    * @param [yIndex=0] {Number} Optional param for when onlyHorizontalAnimations has been set.
    *
    * @memberof CanvasAnimation.prototype
    * @method defineAnimation
    * 
    *
    */
    CanvasAnimation.prototype.defineAnimation = function(animationName, arrayOfXYIndexValues, yIndex) {
        
        this.animationSpecs[animationName] = [yIndex || 1, arrayOfXYIndexValues];  
        
    };
    
    /** 
	*   
	*    
	*    
	* @memberof CanvasAnimation
	*  
	*/
    CanvasAnimation.prototype.animationIndexOrder;
    /** 
	*   
	*    @private
	*    
	* @memberof CanvasAnimation.prototype
	*  
	*/
    CanvasAnimation.prototype.ani = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof CanvasAnimation.prototype
	*  
	*/
    CanvasAnimation.prototype.blitIndex;
    /** 
	*   
	*    The width of the CanvasAnimation
	*    @type Number
	* @memberof CanvasAnimation
	*  
	*/
    CanvasAnimation.prototype.width = 0;
    /** 
	*   
	*    The height of the CanvasAnimation
	*    @type Number
	* @memberof CanvasAnimation
	*  
	*/
    CanvasAnimation.prototype.height = 0;
    /** 
	*   
	*    The x position of the CanvasAnimation
	*    @type Number
	* @memberof CanvasAnimation
	*  
	*/
    CanvasAnimation.prototype.x = 0;
    /** 
	*   
	*   The y position of the CanvasAnimation
	*    @type Number
	* @memberof CanvasAnimation
	*  
	*/
    CanvasAnimation.prototype.y = 0;
    /** 
	*   
	*    The rectangle used to define where to draw the current frame of animation from.
    *      The animate method updates this rectangle based on the currentAnimation.
	*    
	* @memberof CanvasAnimation
	*  @type Rectangle
	*/
    CanvasAnimation.prototype.fromRect;
    /** 
	*   
	*    An optional offset added to where to draw horizontally from.
	*    
	* @memberof CanvasAnimation
	*  @type Number
	*/
    CanvasAnimation.prototype.fromXOffset = 0;
    /** 
	*   
	*    An optional offset added to where to draw vertically from.
	*   
	* @memberof CanvasAnimation
	*   @type Number
	*/
    CanvasAnimation.prototype.fromYOffset = 0;
    /** 
	*   
	*    An optional offset added to the width of the draw from area.
	*    
	* @memberof CanvasAnimation
	*  @type Number
	*/
    CanvasAnimation.prototype.fromWidthOffset = 0;
    /** 
	*   
	*    An optional offset added to the height of the draw from area.
	*    
	* @memberof CanvasAnimation
	*  @type Number
	*/
    CanvasAnimation.prototype.fromHeightOffset = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof CanvasAnimation.prototype
	*  
	*/
    CanvasAnimation.prototype.lastAnim = "";
    /** 
	*   
	*    The MoverPoint to draw the animation to.
	*   
	* @memberof CanvasAnimation
	*   @type MoverPoint
	*/
    CanvasAnimation.prototype.toPoint;
    /** 
	*   @private
	*    
	*    
	* @memberof CanvasAnimation.prototype
	*  
	*/
    CanvasAnimation.prototype._cpos;
    /** 
	*   
	*    @private
	*    
	* @memberof CanvasAnimation.prototype
	*  
	*/
    CanvasAnimation.prototype._addedPos;
    /** 
	*   @private
	*    
	*    
	* @memberof CanvasAnimation.prototype
	*  
	*/
    CanvasAnimation.prototype._inDelay = 0;
    
    
    /*
    *
    *
    * When set to 1 or true the CanvasAnimation would only accept horizontal animations and therefore animation setup would be slightly different.
    *  If you set this to true or 1 then each animation in animationSpecs is defined with an array that holds first a y index to use for every frame, and then an array containing the x index of each frame.
    *  For example: [9,[1,2,3,4,5]] where 9 defines the y index that would be used for every frame, and the array is holding the x indexes.
    *
    *   Using only horizontal animations performs slightly faster than using x,y pairs, but it matters very little.
    *   The default behavior of the class is to use x,y pairs:  [0,[1,9,2,9,3,9,4,9,5,9]]  with the animationSpecs arrays still having a number first, but not being used.
    *
    *   Note: to use only horizontal animations all animations in your sprite sheet would have to be laid out horizontally, not vertically or just anywhere.
    * 
    * @memberof CanvasAnimation
    * @type Number
    */
    CanvasAnimation.prototype.onlyHorizontalAnimations = 0;
    /*
    *
    * If this static property is set to 1 then every CanvasAnimation instance would use only horizontal animations.
    *  @memberof CanvasAnimation 
    *  @static
    */
    CanvasAnimation._onlyHorizontalAni = 0;
    
    
    
    /**
    * Match x and y to the mover given.
    *
    * @memberof CanvasAnimation.prototype
    * @method matchPosition
    *
    * @param mover {MoverSkeleton} The mover to match positions with
    * @param [xoff=0] {Number} optional x offset
    * @param [yoff=0] {Number} optional y offset
    */
    CanvasAnimation.prototype.matchPosition = function(mover,xoff,yoff) {
		this.x = (mover.x+1-1) - (xoff||0);
		this.y = (mover.y+1-1) - (yoff||0);
	};
    
    
    
    /** 
	*   
	*    Returns a MoverPoint reference to the position of the CanvasAnimation.
	*    
	* @memberof CanvasAnimation.prototype 
	* @method getPosition
	* @param [addedX=0] {Number}  An optional amount to add to the x position
	* @param [addedY=0] {Number} An optional amount to add to the y position
    * @returns {MoverPoint} 
	*/
    CanvasAnimation.prototype.getPosition = function(addedX, addedY) {
        if (!this._cpos || !this._addedPos) {
            this._cpos = new tabageos.MoverPoint();
            this._addedPos = new tabageos.MoverPoint();
        }
        this._cpos.x = this.x;
        this._cpos.y = this.y;
        if (addedX || addedY) {
            this._addedPos.x = this.x + (addedX || 0);
            this._addedPos.y = this.y + (addedY || 0)
        }
        return ((addedX || addedY) ? this._addedPos : this._cpos);
    };
    /** 
	*   
	*    Basic change of animation based on left,right,up,down input.
	*    Changes the currentAnimation property to 'left' 'right' 'up' or 'down' based on params given.
	*    
	* @memberof CanvasAnimation.prototype 
	* @method changeLeftRightUpDownAnimation
	* @param left {Boolean} 
	* @param right {Boolean} 
	* @param up {Boolean}
	* @param down {Boolean}
	* @param [dontKeepAniIndex=false]  {Boolean} If set to true the lastAnim property would not be updated, otherwise, by default, lastAnim holds the last animation that was used before the currentAnimation.
    * 
	*/
    CanvasAnimation.prototype.changeLeftRightUpDownAnimation = function(left,right,up,down, dontKeepAniIndex) {
		
		if(!up && !down && !left && !right && this.lastAnim) {
			this.currentAnimation = this.lastAnim;
		} else {
			this.currentAnimation = up ? "up" : (down ? "down" : (left ? "left" : "right"));
		}
		if (!dontKeepAniIndex) {
            this.lastAnim = this.currentAnimation;
        }
		
	};
	/** 
	*   
	*    Change the basic direction animation to face towards the given Object.
	*    If the given Object is above the CanvasAnimation it would change it to 'up'
	*    If the given Object is left of the CanvasAnimation it would change it to 'left' 
	*    
	* @memberof CanvasAnimation.prototype 
	* @method changeFaceAnimation
	* @param toFace {MoverSkeleton} A MoverSkeleton or Object with x,y,width and height.
	* @param [keepAniIndex=false] {Boolean} If true lastAnim will be updated, by default this method does not update lastAnim.
    * 
	*/
    CanvasAnimation.prototype.changeFaceAnimation = function(toFace, keepAniIndex) {
			
			if (this.y >= toFace.y + toFace.height ) {
				this.currentAnimation = "up";
			}
			if (this.y + this.height < toFace.y  ) {
				this.currentAnimation = "down";
			}
			if (this.x > toFace.x + toFace.width) {
				this.currentAnimation = "left";
			}
			if (this.x + this.width < toFace.x ) {
				this.currentAnimation = "right";
			}
			if (keepAniIndex) {
				this.lastAnim = this.currentAnimation;
			}
			
	};


	/** 
	*   
	*    Returns the direction string of the current animation. 'left' 'right' 'up' or 'down'.
	*    
	* @memberof CanvasAnimation.prototype 
	* @method getDirectionOfAnimation
	* @param currentAni {String} The currentAnimation or animation name you want to get the named direction from.
	* @param [onlyLeftRight=false] {Boolean}
	* @param [onlyUpDown=false] {Boolean}
    * @returns {String} 
	*/
    CanvasAnimation.prototype.getDirectionOfAnimation = function(currentAni, onlyLeftRight, onlyUpDown) {
		
		var r = "";
		if(!onlyUpDown) {
			if(currentAni.indexOf("left") != -1) r = "left";
			if(currentAni.indexOf("right") != -1) r = "right";
		}
		if(!onlyLeftRight) {
			if(currentAni.indexOf("up") != -1) r = "up";
			if(currentAni.indexOf("down") != -1) r = "down";
		}
		return r;
		
	};





    /** 
	*   More advanced but still general changing of animation based on directions given.
	*    When all directions are false/0 'idle' will be applied to the animation.
	*    For example if the last animation was 'right' and then no input is given,
	*	this method would set the animation to 'idleright'.
	*
	*    This method will also compute 'upleft' 'upright' and so on for when two inputs are given.
    *
    *  Other classes such as the BasicNinja Class and WeaponHoldingAttacker Class add functionality to this method via the addedAnimationChanges property.
    *  In those cases that method happens after this method has changed the animation.
	*    
	* @memberof CanvasAnimation.prototype 
	* @method changeDirectionAnimation
	* @param left {Boolean}
	* @param right {Boolean}
	* @param up {Boolean}
	* @param down {Boolean}
	* @param [keepAniIndex=false] {Boolean} When true lastAnim would be updated, by default this method does not update lastAnim
    * @param [noIdle=false] {Boolean} When true idle will not be applied to the animation
    * @param [keepUpDown=false] {Boolean} By default if idle is being applied, 'up' and 'down' are stripped so that only idleleft or idleright happen, if you want idleup idledown also pass true for this. 
    *                                       By default this method is set up for platformers, that would never be idle in the air, for top down generally changeLeftRightUpDownAnimation is the method that would be used to change the animation.
	*/
    CanvasAnimation.prototype.changeDirectionAnimation = function(left, right, up, down, keepAniIndex, noIdle,keepUpDown) {
        var helda = this.currentAnimation + "";
        this.currentAnimation = (up ? "up" : (down ? "down" : "")) + (left ? "left" : (right ? "right" : (((up || down) && this.lastAnim.match("left")) ? "left" : (((up || down) && this.lastAnim.match("right")) ? "right" : ""))));
        if (this.currentAnimation.length <= 0 && !keepUpDown) {
            this.currentAnimation = this.lastAnim.replace("idle", "").replace("down", "").replace("up", "") + (noIdle ? "" : "idle");
		}
		if (this.currentAnimation.length <= 0) {
			this.currentAnimation = helda;
		}
        if (keepAniIndex) {
            this.lastAnim = this.currentAnimation;
        }

		if(this.addedAnimationChanges && this._playerRef) {
			
			this.addedAnimationChanges(left, right, up, down, keepAniIndex, noIdle);
		}

    };
	

	/** 
	*   
	*    Resets the current animation to the beginning frame.
	*    
	* @memberof CanvasAnimation.prototype 
	* @method resetCurrentAnimation
    * 
	*/
    CanvasAnimation.prototype.resetCurrentAnimation = function() {
		
		this.ani = 0;
	};

    /** 
	*   
	*    Cycles through the frames of the animation as defined by animationSpecs and the currentAnimation.
	*    call blit to display the result onto the CanvasObject defined during construction.
    *
	* @memberof CanvasAnimation.prototype 
	* @method animate
	* @param [thrott=1] {Number} Speed of the animation. 0.2 would be slow, 3 or higher would be fast. 1 is the default.
    * 
	*/
    CanvasAnimation.prototype.animate = function(thrott) {
        this.blitIndex = this.animationSpecs[this.currentAnimation] ? this.animationSpecs[this.currentAnimation][0] : this.blitIndex;
        this.animationIndexOrder = this.animationSpecs[this.currentAnimation] ? this.animationSpecs[this.currentAnimation][1] : this.animationIndexOrder;
        if (this.ani >= this.animationIndexOrder.length - 1) {
            this.ani = 0;
        } else {
            this.ani += (thrott || (this.onlyHorizontalAnimations === 0 ? 2 : 1) );
        }
        if (this.currentAnimation != this.lastAnim || (this.onlyHorizontalAnimations === 0 && this.ani > this.animationIndexOrder.length - 2) ) {
            this.ani = 0;
        }
        this.lastAnim = this.currentAnimation;
		var ain = Math.floor(this.ani); if(ain % 2 != 0) { ain = ain -1; }
		var aival = this.animationIndexOrder[ain];
		if(this.onlyHorizontalAnimations === 0) { 
			//if(this.animationIndexOrder[ain] && this.animationIndexOrder[ain+1] ) {
				this.fromRect.x = this.animationIndexOrder[ain] * (this.width + this.fromXOffset);
				this.fromRect.y = this.animationIndexOrder[ain+1] * (this.height + this.fromYOffset);
			//}
		} else {
			this.fromRect.x = this.animationIndexOrder[ain] * (this.width + this.fromXOffset);
			this.fromRect.y = this.blitIndex * (this.height + this.fromYOffset);
		}
        this.fromRect.width = this.width + this.fromWidthOffset;
        this.fromRect.height = this.height + this.fromHeightOffset;
    };
    /**
    *
    *
    *  Returns true when the currentAnimation has gone through all its frames.
    *
    *   For example in a game loop you could test for if(myCanvasAnimation.finishedCurrentAnimation())  { ... }
    *
    *   @memberof CanvasAnimation.prototype 
    *   @method finishedCurrentAnimation
    *   @returns {Boolean}
    */
    CanvasAnimation.prototype.finishedCurrentAnimation = function() {
		if(!this.animationSpecs[this.currentAnimation]) {
			return false; 
		} else {
			return (this.ani >= this.animationSpecs[this.currentAnimation][1].length - 1);
		}
	};
    /** 
	*   @private
	*    
	*    
	* @memberof CanvasAnimation
	*  
	*/
    CanvasAnimation.prototype._throttRef;
    /** 
	*   
	*    @private
	*    
	* @memberof CanvasAnimation
	*  
	*/
    CanvasAnimation.prototype._cBB;
    /** 
	*   
	*   Changes and blits the animation after milliSecondDelay amount of time. 
	*    
	* @memberof CanvasAnimation.prototype 
	* @method delayedAnimateAndBlit
	* @param [thrott=1] {Number} Throttle to use for the animate call
	* @param milliSecondDelay {Number} Amount of time in milliseconds to wait before calling animate and blit
	* @param [animation] {String} The currentAnimation to change to. Otherwise currentAnimation is used. this sets currentAnimation.
	* @param [clearBeforeBlitt=false] {Boolean} If true the canvas would be cleared before the blit
    * 
	*/
    CanvasAnimation.prototype.delayedAnimateAndBlit = function(thrott, milliSecondDelay, animation,clearBeforeBlitt) {
        this._inDelay = 1;
        if(animation) {
            this.currentAnimation = animation;
        }
        this._throttRef = thrott || 0;
        this._cBB = clearBeforeBlitt || 0;
        var ref = this;
        window.setTimeout(function(e) { ref._delayedFunction(); }, milliSecondDelay);
    };
    /** 
	*   
	*    @private
	*    
	* @memberof CanvasAnimation.prototype 
	* @method _delayedFunction
	* @param e 
    * 
	*/
    CanvasAnimation.prototype._delayedFunction = function(e) {
        if(this._inDelay) {
            this.animate(this._throttRef);
            if(this._cBB) {
                this._canvas.context.clearRect(this.x,this.y,this.width,this.height);
            }
            this.blitt();
            this._inDelay = 0;
        }
    };
    /** 
	*   
	*    Draws the animation onto the CanvasObject given during construction.
	*    
	* @memberof CanvasAnimation.prototype 
	* @method blit
	* @param [r] {Rectangle} optional Rectangle defining where to draw from. Default is fromRect (defined during construction and during animate calls)
	* @param [p] {MoverPoint} optional MoverPoint defining where to draw to. Default is toPoint (this.x, this.y) 
	* @param [igf=false] {Boolean} Default is false, if true fromWidthOffset and fromHeightOffset will not be part of positioning calculations.
	*                        For example, if your colliding at 16x16 and yet the animation is 32x32 you would have defined a fromWidthOffset/fromHeightOffset of 16,
	*								and by default the animation would therefore be placed in the middle offset by 16. If you don't want this behavior pass 1 for igf.
    *  
	*/
    CanvasAnimation.prototype.blit = function(r, p, igf) {
        if (r)
            this.fromRect = r;
        if (p) {
            this.toPoint = p;
        } else if (!igf) {
            this.toPoint.x = this.x - (this.fromWidthOffset != 0 ? this.fromWidthOffset/2 : 0);
            this.toPoint.y = this.y - this.fromHeightOffset;
        } else if(igf) {
            this.toPoint.x = this.x;
            this.toPoint.y = this.y;
        }
        this._canvas.copyPixels(this._source, this.fromRect, this.toPoint, this.fromRect.width, this.fromRect.height);
    }
    ;
    tabageos.CanvasAnimation = CanvasAnimation;
})();

(function() { 
	'use strict';
    /** 
    *
	*  @class CanvasObject
    * @classdesc
	*    A CanvasObject represents an html canvas element and has methods for drawing to the canvas and manipulating pixels.
	*    To allow for easeir inheritance this constructor is actually calling the init method, which in turn can be used like a super method.    
	*
	* 
	* @param [canvas] {HTMLCanvasElement} The canvas html element that this instance will reference, if blank a canvas element is created.
	* @param [width=1] {Number} The width of the canvas.
	* @param [height=1] {Number} The height of the canvas.
	* @param [dontPixelate=0] {Number} If 0 or absent the canvas will be set up to display crisp edges.
	* @param [scaleToPix=0]  {Number} If 1 and dontPixelate is 0 the canvas will be scaled to window.devicePixelRatio if available.
	*  
	*/
    function CanvasObject(canvas, width, height, dontPixelate, scaleToPix) {
		tabageos.EventDispatcher.call(this);
        if (canvas || width >= 0 || height >= 0) {
            this.init(canvas, width, height, 0, dontPixelate, scaleToPix);
        }
    };
	
    CanvasObject.prototype.constructor = CanvasObject;
	CanvasObject.prototype = Object.create(tabageos.EventDispatcher.prototype);
    /** 
	*   
	*  The init method can be thought of like super. If extending the CanvasObject class call init in your extensions constructor. 
	*    init sets up the canvas based on the parameters given.
	*    
	* @memberof CanvasObject.prototype 
	* @method init
	* @param [canvas] {HTMLCanvasElement} The canvas html element, if one is not given a canvas element is created.
	* @param [width=1] {Number} The width of the canvas element 
	* @param [height=1] {Number} The height of the canvas element 
	* @param [placePixelData=0] {Number} If present (1 or true) the imageData of the canvas will be stored in the ._pixelData property
	* @param [dontPixelate=0] {Number} If absent (0 or just not there) the canvas will be set up to render crisp edges.
	* @param [scaleToPix=0] {Number} If present the canvas will be scaled to window.devicePixelRatio if available, dontPixelate must be 0.
    * 
	*/
    CanvasObject.prototype.init = function(canvas, width, height, placePixelData, dontPixelate, scaleToPix) {
        this.width = width || 1;
        this.height = height || 1;
        this.canvas = (canvas == null ? document.createElement("canvas") : canvas);
        this.canvas.setAttribute("width", this.width);
        this.canvas.setAttribute("height", this.height);
        this.context = this.canvas.getContext("2d");
        if (canvas == null && placePixelData) {
            this._pixelData = this.context.createImageData(this.width, this.height);
        } else if (placePixelData) {
            this._pixelData = this.context.getImageData(0, 0, this.width, this.height);
        }
        if(this._pixelData) this.pixelDataArray = this._pixelData.data;
        this._alpha = 1;
		if(!dontPixelate) {
			this.canvas.setAttribute("style", "image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
			
			if(scaleToPix) {
				var wpix = window.devicePixelRatio || 1;
				this.context.scale(wpix,wpix);
				window.console.log(window.devicePixelRatio + " is the window.devicePixelRatio. CanvasObject has been scaled to it.");
			}
		}
		
    }
    ;
    /** 
	*   
	*    
	*    The width of the CanvasObject
	* @memberof CanvasObject 
	*  
	*/
    CanvasObject.prototype.width = 0;
    /** 
	*   
	*    
	*    The height of the CanvasObject
	* @memberof CanvasObject 
	*  
	*/
    CanvasObject.prototype.height = 0;
    /** 
	*   
	*    The html canvas element that this Class is referencing and manipulating.
	*    
	* @memberof CanvasObject 
	*  
	*/
    CanvasObject.prototype.canvas = null;
    /** 
	*   
	*    The 2DContext of the canvas element being used.
	*    
	* @memberof CanvasObject 
	*  
	*/
    CanvasObject.prototype.context = null;
    /** 
	*   
	*    @private
	*    
	* @memberof CanvasObject 
	*  
	*/
    CanvasObject.prototype._pixelData = null;
    /** 
	*   
	*    The getImageData().data Array of pixels from the canavs element being used.
	*    This value can be set during init, and to update it use the commit option in methods that have it,
	*    or call the update method.
	*    
	* @memberof CanvasObject 
	*  
	*/
    CanvasObject.prototype.pixelDataArray = null;
    /** 
	*   
	*    
	*    @private 
	* @memberof CanvasObject 
	*  
	*/
    CanvasObject.prototype._alpha = 1;
    /** 
	*   
	*    Sets the globalAlpha property of the canvas context.
	*    
	* @memberof CanvasObject.prototype 
	* @method setAlpha
	* @param value 
    * 
	*/
    CanvasObject.prototype.setAlpha = function(value) {
        this.context.globalAlpha = value;
        this._alpha = value * 100;
    }
    ;
    /** 
	*   
	*    Sets the strokeStyle property of the canvas context.
	*    
	* @memberof CanvasObject.prototype 
	* @method setStrokeStyle
	* @param colorString {String}
    * 
	*/
    CanvasObject.prototype.setStrokeStyle = function(colorString) {
        this.context.strokeStyle = colorString;
    }
    ;
    /** 
	*   
	*    Sets the fillStyle property of the canvas context.
	*    
	* @memberof CanvasObject.prototype 
	* @method setFillStyle
	* @param colorString {String}
    * 
	*/
    CanvasObject.prototype.setFillStyle = function(colorString) {
        this.context.fillStyle = colorString;
    }
    ;
    /** 
	*   Draws from the source image, from the given rectangle, onto the canvas at the given point. 
	*    
	*    
	* @memberof CanvasObject.prototype 
	* @method copyPixels
	* @param source {HTMLImage}
	* @param fromRect {Rectangle}
	* @param toMoverPoint {MoverPoint}
	* @param [copyWidth] {Number}
	* @param [copyHeight] {Number}
	* @param [commit=false] {Boolean} If true calls context.getImageData and updates the pixelDataArray. Typically not needed.
    * 
	*/
    CanvasObject.prototype.copyPixels = function(source, fromRect, toMoverPoint, copyWidth, copyHeight, commit) {
        
        this.context.drawImage(source, fromRect.x, fromRect.y, fromRect.width, fromRect.height, Math.round(toMoverPoint.x), Math.round(toMoverPoint.y), copyWidth || fromRect.width, copyHeight || fromRect.height);
        if (commit) {
            this._pixelData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
            this.pixelDataArray = this._pixelData.data;
        }
    }
    ;
    /** 
	*   
	*   Draws the given image at the x and y location given. 
	*    
	* @memberof CanvasObject.prototype 
	* @method drawImage
	* @param img {HTMLImg}
	* @param toX {Number}
	* @param toY {Number}
	* @param [commit=false] {Boolean} If true calls context.getImageData and updates the pixelDataArray. Typically not needed.
    * 
	*/
    CanvasObject.prototype.drawImage = function(img, toX, toY, commit) {
        this.context.drawImage(img, toX, toY);
        if (commit) {
            this._pixelData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
            this.pixelDataArray = this._pixelData.data;
        }
    }
    ;
    /** 
	*   
	*    Draws a triangle at the point given.
	*    
	* @memberof CanvasObject.prototype 
	* @method drawTriangle
	* @param trianglePointX {Number}
	* @param trianglePointY {Number}
	* @param width {Number}
	* @param height {Number}
	* @param [color] {String}
	* @param [horizontal=false] {Boolean}
	* @param [commit=false] {Boolean} If true calls context.getImageData and updates the pixelDataArray. Typically not needed.
    * 
	*/
    CanvasObject.prototype.drawTriangle = function(trianglePointX, trianglePointY, width, height, color, horizontal, commit) {
        commit = commit || false;
        horizontal = horizontal || false;
        this.context.beginPath();
        this.context.moveTo(trianglePointX, trianglePointY);
        if (horizontal == false) {
            this.context.lineTo(trianglePointX + (width / 2), trianglePointY + height);
            this.context.lineTo(trianglePointX - width, trianglePointY + height);
        } else {
            this.context.lineTo(trianglePointX - height, trianglePointY - (width / 2));
            this.context.lineTo(trianglePointX - height, trianglePointY + width);
        }
        this.context.closePath();
        this.context.stroke();
        if (color) {
            this.context.fillStyle = color;
            this.context.fill();
        }
        if (commit == true) {
            this._pixelData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
            this.pixelDataArray = this._pixelData.data;
        }
    };
    
    CanvasObject.mathPI = Math.PI;
    /** 
	*   
	*    Draws a circle whose center is at the x and y given, with the given radius.
	*    
	* @memberof CanvasObject.prototype 
	* @method drawCircle
	* @param x {Number}
	* @param y {Number}
	* @param radius {Number}
	* @param [color] {String} If a color is given the circle will be filled with it.
	* @param [commit=false] {Boolean} If true calls context.getImageData and updates the pixelDataArray. Typically not needed.
    * 
	*/
    CanvasObject.prototype.drawCircle = function(x, y, radius, color, commit) {
        this.context.beginPath();
        this.context.arc(x, y, radius, 0, CanvasObject.mathPI * 2);
        this.context.closePath();
        this.context.stroke();
        if (color) {
            this.context.fillStyle = color;
            this.context.fill();
        }
        if (commit == true) {
            this._pixelData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
            this.pixelDataArray = this._pixelData.data;
        }
    }
    ;
    /** 
	*   
	*    Writes the given text at the x and y given.
	*    
	* @memberof CanvasObject.prototype 
	* @method writeText
	* @param [text] {String} The text to write. No text given would give the string 'undefined'.
	* @param [toX=0]  {Number}
	* @param [toY=0] {Number}
	* @param [font] {String} Default is 'Arial'
	* @param [fontSize] {Number} Default is 24
	* @param [color] {String}
	* @param [commit=false] {Boolean} If true calls context.getImageData and updates the pixelDataArray. Typically not needed.
    * 
	*/
    CanvasObject.prototype.writeText = function(text, toX, toY, font, fontSize, color, commit) {
        this.context.font = font && fontSize ? "" + fontSize + "px" + " " + font + "" : "24px Arial";
        if (!fontSize && font) {
            this.context.font = "24px " + font + "";
        }
        if (!font && fontSize) {
            this.context.font = "" + fontSize + "px Arial";
        }
        if (color) {
            this.context.fillStyle = color;
            this.context.fillText(text || "undefined", toX || 0, toY || 0);
        } else {
            this.context.strokeText(text || "undefined", toX || 0, toY || 0);
        }
        if (commit == true) {
            this._pixelData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
            this.pixelDataArray = this._pixelData.data;
        }
    }
    ;
    /** 
	*   Clears the canvas of any drawings and then updates the pixelDataArray.
	*    
	*    
	* @memberof CanvasObject.prototype 
	* @method clear
    * 
	*/
    CanvasObject.prototype.clear = function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this._pixelData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
        this.pixelDataArray = this._pixelData.data;
    }
    ;
    /** 
	*   
	*    Draws a rectangle using the Rectangle given.
	*    
	* @memberof CanvasObject.prototype 
	* @method drawRect
	* @param rect {Rectangle}
	* @param [colorString] {String} If present the rectangle will be filled with the color.
	* @param [commit] {Boolean} If true the pixel data will be updated, only needed if pixel data is to be accessed.
    * 
	*/
    CanvasObject.prototype.drawRect = function(rect, colorString, commit) {
        if (colorString) {
            this.context.fillStyle = colorString;
            this.context.fillRect(rect.x, rect.y, rect.width, rect.height);
        } else {
            this.context.strokeRect(rect.x, rect.y, rect.width, rect.height);
        }
        if (commit == true) {
            this._pixelData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
            this.pixelDataArray = this._pixelData.data;
        }
    }
    ;
    /** 
	*   
	*    Sets a pixel of the canvas to the given color.
	*    
	* @memberof CanvasObject.prototype 
	* @method setPixel
	* @param x {Number}
	* @param y {Number}
	* @param color {String}
	* @param [pixelCommit=false] {Boolean} Commit the individual call with putImageData
	* @param [endCommit=false] {Boolean} You would call this at the end of all setPixel calls to putImageData for the whole canvas.
    * 
	*/
    CanvasObject.prototype.setPixel = function(x, y, color, pixelCommit, endCommit) {
        var p = ((Math.round(y) * this._pixelData.width) + Math.round(x)) * 4;
        var d = this._pixelData.data;
        d[p + 0] = (color & 0xff0000) >> 16;
        d[p + 1] = (color & 0x00ff00) >> 8;
        d[p + 2] = (color & 0x0000ff);
        if (pixelCommit == true) {
            this.context.putImageData(this._pixelData, 0, 0, x, y, 1, 1);
        }
        if (endCommit == true) {
            this.context.putImageData(this._pixelData, 0, 0);
        }
        ;
    }
    ;
    /** 
	*   
	*    Returns the color of the pixel at the given x and y location.
	*    
	* @memberof CanvasObject.prototype 
	* @method getPixel
	* @param x {Number}
	* @param y {Number}
    * @returns {Number} 
	*/
    CanvasObject.prototype.getPixel = function(x, y) {
        var p = ((Math.round(y) * this._pixelData.width) + Math.round(x)) * 4;
        var d = this._pixelData.data;
        return d[p + 0] << 16 | d[p + 1] << 8 | d[p + 2];
    }
    ;
    /** 
	*   
	*    Updates the pixelDataArray, if needing to use getPixel on a canvas that gets redrawn,
	*	 this method or the commit param of each drawing method needs to be called.
	*    
	* @memberof CanvasObject.prototype 
	* @method update
    *  
	*/
    CanvasObject.prototype.update = function() {
        this._pixelData = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
        this.pixelDataArray = this._pixelData.data;
        this.context.putImageData(this._pixelData, 0, 0);
    }
    ;
    tabageos.CanvasObject = CanvasObject;
})();


(function() { 
	'use strict';
    /** 
    *
    *@class CanvasObjectContainer
	*@classdesc
	*   A class representing HTML div elements, or other CanvasObjectContainers.
	*   Just like the CanvasObject class this class has an init method that acts like super.    
	*
	* 
	* @param divID {String} the id attribute value of the HTML div element.
	* @param width {Number} the width of the div. 
	* @param height {Number} the height of the div.
	* @param [rootCanvasObjectContainer] {CanvasObjectContainer} optional CanvasObjectContainer that should contain this one.
	* @param [floorColorString]  {String} the color for the floor CanvasObject of this CanvasObjectContainer, if no floor color is passed a floor CanvasObject is not created.
	*  
	*/
    function CanvasObjectContainer(divID, width, height, rootCanvasObjectContainer, floorColorString) {
		tabageos.EventDispatcher.call(this);
        if (divID || width || height || rootCanvasObjectContainer) {
            this.init(divID, width, height, rootCanvasObjectContainer, floorColorString);
        }
    }
    ;
	/** 
	*   
	*    
	*    
	* @memberof CanvasObjectContainer 
	*  
	*/
    CanvasObjectContainer.prototype.constructor = CanvasObjectContainer;
	CanvasObjectContainer.prototype = Object.create(tabageos.EventDispatcher.prototype);
    /** 
	*   Acts like a super method for inheriting Classes.
	*    
	*    
	* @memberof CanvasObjectContainer.prototype 
	* @method init
	* @param divID {String} the id attribute value of the HTML div element.
	* @param width {Number} the width of the div. 
	* @param height {Number} the height of the div.
	* @param [rootCanvasObjectContainer] {CanvasObjectContainer} optional CanvasObjectContainer that should contain this one.
	* @param [floorColorString]  {String} the color for the floor CanvasObject of this CanvasObjectContainer, if no floor color is passed a floor CanvasObject is not created.
    * 
	*/
    CanvasObjectContainer.prototype.init = function(divID, width, height, rootCanvasObjectContainer, floorColorString) {
        this._w = width || 300;
        this._h = height || 400;
        if (divID) {
            this.div = document.getElementById(divID);
			this.floor = null;
        } else {
            this.div = document.createElement("div");
            this.div.setAttribute("style", "position:absolute");
            this.div.setAttribute("width", this._w);
            this.div.setAttribute("height", this._h);
            if (rootCanvasObjectContainer) {
                rootCanvasObjectContainer.addChild(this);
			}
			
			if (floorColorString) {
				this.floor = new tabageos.CanvasObject(null,this._w,this._h);
				this.floor.context.fillStyle = floorColorString;
				this.floor.context.fillRect(0, 0, this._w, this._h);
				this.div.appendChild(this.floor.canvas);
				this._floorContext = this.floor.context;
				this.floor.canvas.setAttribute("style", "position:absolute;top:0px;z-index:-1");
			}
			
        }
        this._children = [];
        
    };
    /** 
	*   
	*    @private
	*    
	* @memberof CanvasObjectContainer 
	*  
	*/
    CanvasObjectContainer.prototype._w = null;
    /** 
	*   
	*    @private
	*    
	* @memberof CanvasObjectContainer 
	*  
	*/
    CanvasObjectContainer.prototype._h = null;
    /** 
	*   
	*    The html div that this Class is referencing.
	*    
	* @memberof CanvasObjectContainer 
	*  
	*/
    CanvasObjectContainer.prototype.div = null;
    /** 
	*   
	*   An optional floor CanvasObject that is the bottom child of this class.
	*   If no floorColorString is passed during construction a floor CanvasObject is not created.
	*    
	* @memberof CanvasObjectContainer 
	*  
	*/
    CanvasObjectContainer.prototype.floor = null;
    /** 
	*   
	*    @private
	*    
	* @memberof CanvasObjectContainer 
	*  
	*/
    CanvasObjectContainer.prototype._floorContext = null;
    /** 
	*   
	*    @private
	*    
	* @memberof CanvasObjectContainer 
	*  
	*/
    CanvasObjectContainer.prototype._children = [];
    /** 
	*   
	*    Returns the width of this CanvasObjectContainer
	*    
	* @memberof CanvasObjectContainer.prototype 
	* @method getWidth
    * @returns {Number} 
	*/
    CanvasObjectContainer.prototype.getWidth = function() {
        return this._w;
    }
    ;
    /** 
	*   
	*    Returns the set height of this CanvasObjectContainer.
	*    
	* @memberof CanvasObjectContainer.prototype 
	* @method getHeight
    * @returns {Number} 
	*/
    CanvasObjectContainer.prototype.getHeight = function() {
        return this._h;
    }
    ;
    /** 
	*   
	*    Returns the number of children that this CanvasObjectContainer has.
	*    
	* @memberof CanvasObjectContainer.prototype 
	* @method getNumChildren
    * @returns {Number} 
	*/
    CanvasObjectContainer.prototype.getNumChildren = function() {
        return this._children.length;
    }
    ;
    /** 
	*   
	*    Adds a html div element or CanvasObject to this CanvasObjectContainer.
	*    
	* @memberof CanvasObjectContainer.prototype 
	* @method addChild
	* @param child {HTMLDivElement | CanvasObject}
	* @param x {Number}
	* @param y {Number}
    * @returns {HTMLDivElement | CanvasObject} 
	*/
    CanvasObjectContainer.prototype.addChild = function(child, x, y) {
        if (this._children.indexOf(child) == -1) {
            this._children.unshift(child);
            this.div.appendChild(child.canvas || child.div);
            this._setUpChild(child, this._children.length - 1, x || 0, y || 0);
        }
        return child;
    }
    ;
    /** 
	*   
	*   Ads a HTML div element or CanvasObject to this CanvasObjectContainer at the index and x y location given. 
	*    
	* @memberof CanvasObjectContainer.prototype 
	* @method addChildAt
	* @param child {HTMLDivElement | CanvasObject}
	* @param index {Number} the index the child should have in the CanvasObjectContainer lower indexes are beneath other children.
	* @param x {Number}
	* @param y {Number}
    * @returns {HTMLDivElement | CanvasObject}
	*/
    CanvasObjectContainer.prototype.addChildAt = function(child, index, x, y) {
        if (this._children.indexOf(child) == -1) {
            this._children.splice(index, 0, child);
            this.div.appendChild(child.canvas || child.div);
            this._setUpChild(child, index + 1, x || 0, y || 0);
        }
        return child;
    }
    ;
    /** 
	*   
	*    Returns the index of the child in this CanvasObjectContainer. Call contains to check if the child is a child of this CanvasObjectContainer.
	*    
	* @memberof CanvasObjectContainer.prototype 
	* @method getChildIndex
	* @param child {HTMLDivElement | CanvasObject}
    * @returns {Number} 
	*/
    CanvasObjectContainer.prototype.getChildIndex = function(child) {
        return this._children.indexOf(child);
    }
    ;
    /** 
	*   
	*    Sets the index of the child to the index given.
	*    
	* @memberof CanvasObjectContainer.prototype 
	* @method setChildIndex
	* @param child {HTMLDivElement | CanvasObject}
	* @param index {Number}
	* @param x {Number}
	* @param y {Number}
    * 
	*/
    CanvasObjectContainer.prototype.setChildIndex = function(child, index, x, y) {
        if (this.contains(child)) {
            this.removeChild(child);
        }
        this.addChildAt(child, index, x, y);
    }
    ;
    /** 
	*   
	*    Removes a child from this CanvasObjectContainer.
	*    
	* @memberof CanvasObjectContainer.prototype 
	* @method removeChild
	* @param child {HTMLDivElement | CanvasObject}
    * @returns {HTMLDivElement | CanvasObject}
	*/
    CanvasObjectContainer.prototype.removeChild = function(child) {
        if (this._children.indexOf(child) != -1) {
            this.div.removeChild(child.canvas || child.div);
            this._children.splice(this._children.indexOf(child), 1);
        }
        return child;
    }
    ;
    /** 
	*   
	*    Gets the child that is at the given index.
	*    
	* @memberof CanvasObjectContainer.prototype 
	* @method getChildAt
	* @param index {Number}
    * @returns {HTMLDivElement | CanvasObject} 
	*/
    CanvasObjectContainer.prototype.getChildAt = function(index) {
        return this._children[index] || null;
    }
    ;
    /** 
	*   
	*    Returns true if the CanvasObjectContainer contains the given child.
	*    
	* @memberof CanvasObjectContainer.prototype 
	* @method contains
	* @param child {HTMLDivElement | CanvasObject}
    * @returns {Boolean} 
	*/
    CanvasObjectContainer.prototype.contains = function(child) {
        return this._children.indexOf(child) != -1;
    }
    ;
    /** 
	*   @private
	*    
	*    
	* @memberof CanvasObjectContainer.prototype 
	* @method _setUpChild
	* @param child 
	* @param indx 
	* @param x 
	* @param y 
    * @returns {} 
	*/
    CanvasObjectContainer.prototype._setUpChild = function(child, indx, x, y) {
        var ele = child.canvas || child.div;
        ele.setAttribute("style", "position:" + (child.canvas ? "absolute" : "relative") + ";z-index:" + indx + ";left:" + x + ";top:" + y + "");
    }
    ;
    tabageos.CanvasObjectContainer = CanvasObjectContainer;
})();



(function() {
	
	
		/**
		*  
        *  @class ControllerPad
        *  @classdesc
		*  HTML5 ControllerPad with 10 possible buttons. 
		*  Also handles keyboard input for when touches are not available.
		*  (for a game that is using tabageos and the tabageos.MouseController class)
		*  this class uses tabageos.GeometricMath and extends tabageos.EventDispatcher.
		*  Must instantiate and then call establish. The constructors params (besides the Numbers) are tabgeos.MoverPoints or Objects with x and y properties.
		*  Use the controller.keyboardEquivalents Object to define the keyboard key values that correspond to the buttons.
		* 
		*  Users may need to mash their touch screens to be sure and send a new touchstart event, when needing to press two buttons simultaineously 
		*  one needs to be sure and make definite presses, then smooth normal nintendo like play is what you get. 
		*  So your buttons should be big, at least all thumb size.
		*  The MoverPoints you pass during construction should define the middle point of each button.
		*
		*  Includes usb game pad support; see .handleGamePad()
        *
        *   See the ControllerPad example;    https://www.tabageos.com/examples/ControllerPad
		*  
        * @param holder {HTMLElement} The html div that is to hold the controller
		* @param x {Number} placeholder for x, actual position is done during the show method. 
        * @param y {Number} placeholder for y
        * @param w {Number} placeholder for width
        * @param h {Number} placeholder for height
        * @param leftp {MoverPoint} MoverPoint defining the middle point of the left button
        * @param rightp {MoverPoint} MoverPoint defining the middle point of the right button
        * @param upp {MoverPoint}
        * @param downp {MoverPoint}
        * @param startp {MoverPoint}
        * @param backp {MoverPoint}
        * @param ap {MoverPoint} MoverPoint defining the middle point of the a button
        * @param bp {MoverPoint}
        * @param cp {MoverPoint}
        * @param dp {MoverPoint}
        * @param directionButtonsWidth {Number} The width of each directional button
        * @param directionButtonsHeight {Number}
        * @param startAndBackWidth {Number} The width of the start and back buttons.
        * @param startAndBackHeight {Number}
        * @param buttonWidth {Number} The width of each letter button, a,b,c,d.
        * @param buttonHeight {Number}
        *
		*/
		function ControllerPad(holder, x, y, w, h, leftp, rightp, upp, downp, startp,backp,ap,bp,cp,dp, directionButtonsWidth, directionButtonsHeight, startAndBackWidth, startAndBackHeight, buttonWidth, buttonHeight) {
			tabageos.EventDispatcher.call(this);
			this.x = x; this.y = y;
			this.width = w; this.height =h;
			
			this._customSpecs = {};
			this._customSpecs.leftp = leftp;
			this._customSpecs.rightp = rightp;
			this._customSpecs.upp = upp;
			this._customSpecs.downp = downp;
			this._customSpecs.startp = startp;
			this._customSpecs.backp = backp;
			this._customSpecs.ap = ap;
			this._customSpecs.bp = bp;
			this._customSpecs.cp = cp;
			this._customSpecs.dp = dp;
			this._customSpecs.directionButtonsWidth = directionButtonsWidth;
			this._customSpecs.directionButtonsHeight = directionButtonsHeight;
			this._customSpecs.startAndBackWidth = startAndBackWidth;
			this._customSpecs.startAndBackHeight = startAndBackHeight;
			this._customSpecs.buttonWidth = buttonWidth;
			this._customSpecs.buttonHeight = buttonHeight;
			this.__recurse = -1;
			this._style = -1;
			this.__mouseEnabled = 0;
			this._buttonRectColor = "#6495edbb";
			this.holderDiv = holder;
			this._holderDivParent = holder ? holder.offsetParent : null;
			this.avg =  55;
			this.buttons = {"right":0, "left":0, "up":0, "down":0, "a":0, "b":0, "c":0, "d":0, "start":0, "back":0};
			this.basicArrows = {"right":39, "left":37, "up":38, "down":40, "a":32, "b":66, "c":67, "d":77, "start":16, "back":27};
			this.arrows = {"right":39, "left":37, "up":38, "down":40, "a":37, "b":38, "c":39, "d":40, "start":16, "back":27};
			this.basicWasd = {"right":68, "left":65, "up":87, "down":83, "a":32, "b":66, "c":67, "d":77, "start":16, "back":27};
			this.wasd = {"right":68, "left":65, "up":87, "down":83, "a":37, "b":38, "c":39, "d":40, "start":16, "back":27};
			this.keyboardEquivalents = {"right":68, "left":65, "up":87, "down":83, "a":69, "b":32, "c":81, "d":66, "start":16, "back":27};
			if(ControllerPad.instance) {
				throw "ControllerPad constructed already.";
			}
			this._gpb = {a:-1, b:-1, c:-1, d:-1, s:-1, st:-1};
			ControllerPad.instance = this;
		}
	
		ControllerPad.prototype = Object.create(tabageos.EventDispatcher.prototype);
		ControllerPad.prototype.x = 0;
		ControllerPad.prototype.y = 0;
		ControllerPad.prototype.width = 0;
		ControllerPad.prototype.height = 0;
		ControllerPad.prototype.avg = 52;
		ControllerPad.prototype._customSpecs;
		ControllerPad.prototype.buttonA;
		ControllerPad.prototype.buttonB;
		ControllerPad.prototype.buttonC;
		ControllerPad.prototype.buttonD;
		ControllerPad.prototype.startButton;
		ControllerPad.prototype.backButton;
		ControllerPad.prototype.dLeft;
		ControllerPad.prototype.dRight;
		ControllerPad.prototype.dUp;
		ControllerPad.prototype.dDown;
		ControllerPad.prototype.holderDiv;
		ControllerPad.prototype._holderDivParent;
		ControllerPad.prototype._style = 3;
		ControllerPad.prototype.customStyleTotalWidth = 0;
		ControllerPad.prototype.customStyleTotalHeight = 0;
        /**
        * defines the keyboard equivalents for basicController
        * @memberof ControllerPad
        */
		ControllerPad.prototype.basicArrows = {"right":39, "left":37, "up":38, "down":40, "a":32, "b":66, "c":67, "d":77, "start":16, "back":27};
		/**
        * defines the keyboard equivalents for the other controllers besides basicController.
        * @memberof ControllerPad
        */
        ControllerPad.prototype.arrows = {"right":39, "left":37, "up":38, "down":40, "a":37, "b":38, "c":39, "d":40, "start":16, "back":27};
		/**
        * defines the keyboard equivalents for basicController
        * @memberof ControllerPad
        */
        ControllerPad.prototype.basicWasd = {"right":68, "left":65, "up":87, "down":83, "a":32, "b":66, "c":67, "d":77, "start":16, "back":27};
		/**
        * defines the keyboard equivalents for the other controllers besides basicController.
        * @memberof ControllerPad
        */
        ControllerPad.prototype.wasd = {"right":68, "left":65, "up":87, "down":83, "a":37, "b":38, "c":39, "d":40, "start":16, "back":27};
		/**
        * defines keyboard equivalents for button presses
        * @memberof ControllerPad
        */
        ControllerPad.prototype.keyboardEquivalents = {"right":68, "left":65, "up":87, "down":83, "a":69, "b":32, "c":81, "d":66, "start":16, "back":27};
		/**
        * The instance of the ControllerPad, set during construction.
        * @memberof ControllerPad
        */
        ControllerPad.instance;
		/** 
		* test as follows: if(controller.buttons.right) { move right code }
		* @memberof ControllerPad
		*/
		ControllerPad.prototype.buttons = {"right":0, "left":0, "up":0, "down":0, "a":0, "b":0, "c":0, "d":0, "start":0, "back":0};
		ControllerPad.prototype.canvasObject;
		ControllerPad.prototype.firstGamePadInstance = null;
		ControllerPad.prototype.__mouseEnabled = 0;
		
		ControllerPad.prototype.rotation = 0;
		
		ControllerPad.prototype.deg0;
		ControllerPad.prototype.deg30;
		ControllerPad.prototype.deg60;
		ControllerPad.prototype.deg90;
		ControllerPad.prototype.deg120;
		ControllerPad.prototype.deg150;
		ControllerPad.prototype.deg180;
		ControllerPad.prototype.deg210;
		ControllerPad.prototype.deg240;
		ControllerPad.prototype.deg270;
		ControllerPad.prototype.deg300;
		ControllerPad.prototype.deg330;
		ControllerPad.prototype.deg360;
		
		ControllerPad.prototype.rotationPad;
		
        /**
        *
        * Enables mouse clicks on the controller
        *
        * @memberof ControllerPad.prototype
        * @method enableMouseControl
        *
        */
		ControllerPad.prototype.enableMouseControl = function() {
			
			this.__mouseEnabled = 1;
			
		};
		
		
		/** 
		*  If you put anything for addEvents, events will Not be added
		*  just don't pass anything, leave addEvents out, if you intended to use the controller as normal.
        *  This method needs to be called after construction to establish events.
        *
        * @memberof ControllerPad.prototype
        * @method establish
        * @param [addEvents] {Boolean} If set events will not be added.
        * 
		*/
		ControllerPad.prototype.establish = function(addEvents, recordPlay) {
			
			var dontad = false;
			if(addEvents || addEvents === false) { dontad = true; }
			
			if(dontad != true) {
				
				window.removeEventListener("keydown", ControllerPad.instance.handleKeys, false);
				window.removeEventListener("keyup",  ControllerPad.instance.releaseKeys, false);
				window.addEventListener("keydown", ControllerPad.instance.handleKeys, false);
				window.addEventListener("keyup",  ControllerPad.instance.releaseKeys, false);
				window.onfocus = ControllerPad.instance.keyEstablish;
				
				this.dLeft = this._scriptDiv();
				this.dRight = this._scriptDiv();
				this.dUp = this._scriptDiv();
				this.dDown = this._scriptDiv();
				this.buttonA = this._scriptDiv();
				this.buttonB = this._scriptDiv();
				this.buttonC = this._scriptDiv();
				this.buttonD = this._scriptDiv();
				this.startButton = this._scriptDiv();
				this.backButton = this._scriptDiv();
				this.rotationPad = this._scriptDiv();
				
				
				if(this._holderDivParent && this._holderDivParent.contains(this.holderDiv)) {
					window.console.log(this.holderDiv.id + "   " + this._holderDivParent);
					try { this._holderDivParent.removeChild(this.holderDiv); } catch (e) {
						window.console.log("caught e during controller.establish:  " + e +"  Most likely the controller is in a whole bunch of other divs and html, using position:absolute or position:relative for the container div style normally will solve this error.");
					}
				}
				
			}
			
			
		};
		
		
		ControllerPad.prototype._scriptDiv = function() {
			
			var dv = document.createElement("div");
			if( !('ontouchstart' in window) && !this.__mouseEnabled) {
				
				dv.removeEventListener("pointerdown", ControllerPad.instance.dispatch, false);
				dv.removeEventListener("pointerup", ControllerPad.instance.dispatch, false);
				dv.removeEventListener("pointermove", ControllerPad.instance.dispatch, false);
				dv.addEventListener("pointerdown", ControllerPad.instance.dispatch, false);
				dv.addEventListener("pointerup", ControllerPad.instance.dispatch, false);
				dv.addEventListener("pointermove", ControllerPad.instance.dispatch, false);
				
			} else {
				dv.removeEventListener("touchstart", ControllerPad.instance.dispatch, false);
				dv.removeEventListener("touchend", ControllerPad.instance.dispatch, false);
				dv.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
				dv.addEventListener("touchstart", ControllerPad.instance.dispatch, false);
				dv.addEventListener("touchend", ControllerPad.instance.dispatch, false);
				dv.addEventListener("touchmove", ControllerPad.instance.dispatch, false);
			
			}
			
			
			if(this.__mouseEnabled) {
				dv.removeEventListener("mouseup", ControllerPad.instance.dispatch, false);
				dv.removeEventListener("mousedown", ControllerPad.instance.dispatch, false);
			
				dv.addEventListener("mouseup", ControllerPad.instance.dispatch, false);
				dv.addEventListener("mousedown", ControllerPad.instance.dispatch, false);
				
			}
			return dv;
			
		};
        /**
        *
        * Removes touch move handling, such that only touchstart triggers anything.
        *  Needed if you want tile based non-fluid movement, frogger stlye or sokoban style.
        *
        * @memberof ControllerPad.prototype
        * @method removeTouchMove
        *
        */
		ControllerPad.prototype.removeTouchMove = function(nr) {
			this.dLeft.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
			this.dRight.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
			this.dUp.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
			this.dDown.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
			this.buttonA.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
			this.buttonB.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
			this.buttonC.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
			this.buttonD.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
			this.startButton.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
			this.backButton.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
			if(!nr) {
				this.rotationPad.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
			}
			
		};
		ControllerPad.prototype._unscriptDiv = function(dv) {
			
			dv.removeEventListener("touchstart", ControllerPad.instance.dispatch, false);
			dv.removeEventListener("touchend", ControllerPad.instance.dispatch, false);
			dv.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
			dv.removeEventListener("mouseup", ControllerPad.instance.dispatch, false);
			dv.removeEventListener("mousedown", ControllerPad.instance.dispatch, false);
			dv.removeEventListener("pointerdown", ControllerPad.instance.dispatch, false);
			dv.removeEventListener("pointerup", ControllerPad.instance.dispatch, false);
			dv.removeEventListener("pointermove", ControllerPad.instance.dispatch, false);
			
		};
		
		
		ControllerPad.prototype._ccStore = null;
        /**
        *
        * Ads a custom background image for the controller
        * 
        *
        * @memberof ControllerPad.prototype
        * @method addCustomImage
        *
        * @param [imgLocation] {String} The location of an image to use as the background
        * @param customStyleName {String} The html style id for the custom background
        * @param [imgElement] {Image} If present will copy from this image using its full width and height.
        */
		ControllerPad.prototype.addCustomImage = function(imgLocation, customStyleName, imgElement) {
			//
			if(imgLocation && !imgElement) {
				ControllerPad._selfStyle(customStyleName, imgLocation);
			} else {
				
				this._ccStore = new tabageos.CanvasObject(null,imgElement.width,imgElement.height);
				this._ccStore.copyPixels(imgElement, new tabageos.Rectangle(0,0,imgElement.width,imgElement.height),new tabageos.MoverPoint(),imgElement.width,imgElement.height);
				ControllerPad._selfStyle(customStyleName, this._ccStore.canvas.toDataURL());
			}
			
		};
		
		/**
        * For use with ControllerPad.css, this setup does not include a specific up down or D buttons.
		* You can still assign any one of the buttons to do anything, just that the specific 'up' 'down' and 'D' buttons are not set up via this method.
		* This image has a big left and right button, and big A B and C buttons with start and back buttons in the middle.
		* 
		* Used with .show(w,h) (no style param passed)
		* These methods automagically assign the button positions, 
		* you need to also call tabageos.MouseController.defineMousePositionOffset during any resizing of the games container,
		* or use the tabageos.Resize method passing in an intance of the controller.
        *
        * @memberof ControllerPad.prototype
        * @method basicControllerButtonSetup
        *
		* 
		*/
		ControllerPad.prototype.basicControllerButtonSetup = function() {
			this._configBasic("blue");
			this.holderDiv.appendChild(this.dLeft);
			this.holderDiv.appendChild(this.dRight);
			this.holderDiv.appendChild(this.startButton);
			this.holderDiv.appendChild(this.backButton);
			this.holderDiv.appendChild(this.buttonA);
			this.holderDiv.appendChild(this.buttonB);
			this.holderDiv.appendChild(this.buttonC);
		};
    /**
    *
    *
    *
    * @memberof ControllerPad.prototype
    * @method _basicControllerButtonTakedown
    *
    */
		ControllerPad.prototype._basicControllerButtonTakedown = function() {
			this.holderDiv.removeChild(this.dLeft);
			this.holderDiv.removeChild(this.dRight);
			this.holderDiv.removeChild(this.startButton);
			this.holderDiv.removeChild(this.backButton);
			this.holderDiv.removeChild(this.buttonA);
			this.holderDiv.removeChild(this.buttonB);
			this.holderDiv.removeChild(this.buttonC);
		};
		/**
		* For use with ControllerPad.css and the .show method
		* Use .show(w,h,2) to display the directionalsController image.
		* @memberof ControllerPad.prototype
        * @method directionalControllerButtonSetup
		*/
		ControllerPad.prototype.directionalsControllerButtonSetup = function() {
			this._configDirectional("blue");
			this.holderDiv.appendChild(this.dLeft);
			this.holderDiv.appendChild(this.dRight);
			this.holderDiv.appendChild(this.dUp);
			this.holderDiv.appendChild(this.dDown);
			this.holderDiv.appendChild(this.startButton);
			this.holderDiv.appendChild(this.backButton);
			this.holderDiv.appendChild(this.buttonA);
			this.holderDiv.appendChild(this.buttonB);
			this.holderDiv.appendChild(this.buttonC);
			this.holderDiv.appendChild(this.buttonD);
		};
		/**
        *
        *  centerRotationX and centerRotationY also need to be set.
        *  
        * 
        * 
        * @memberof ControllerPad.prototype
        * @method rotationalControllerButtonSetup
        *
        *
        *
        */
		ControllerPad.prototype.rotationalControllerButtonSetup = function() {
			
			this._configRotational("blue");
			
			this.holderDiv.appendChild(this.rotationPad);
			this.holderDiv.appendChild(this.startButton);
			this.holderDiv.appendChild(this.backButton);
			this.holderDiv.appendChild(this.buttonA);
			this.holderDiv.appendChild(this.buttonB);
			this.holderDiv.appendChild(this.dLeft);
			this.holderDiv.appendChild(this.dRight);
			this.holderDiv.appendChild(this.dUp);
			this.holderDiv.appendChild(this.dDown);
		};
        /**
        *
        *
        *
        * @memberof ControllerPad.prototype
        * @method _rotationalControllerButtonTakedown
        *
        */
        ControllerPad.prototype._rotationalControllerButtonTakedown = function() {
			
			this.holderDiv.removeChild(this.dLeft);
			this.holderDiv.removeChild(this.dRight);
			this.holderDiv.removeChild(this.dUp);
			this.holderDiv.removeChild(this.dDown);
			this.holderDiv.removeChild(this.startButton);
			this.holderDiv.removeChild(this.backButton);
			this.holderDiv.removeChild(this.buttonA);
			this.holderDiv.removeChild(this.buttonB);
			this.holderDiv.removeChild(this.rotationPad);
		};
		/**
        *
        *
        *
        * @memberof ControllerPad.prototype
        * @method _directionalsControllerButtonTakedown
        *
        */
		ControllerPad.prototype._directionalsControllerButtonTakedown = function() {
			
			this.holderDiv.removeChild(this.dLeft);
			this.holderDiv.removeChild(this.dRight);
			this.holderDiv.removeChild(this.dUp);
			this.holderDiv.removeChild(this.dDown);
			this.holderDiv.removeChild(this.startButton);
			this.holderDiv.removeChild(this.backButton);
			this.holderDiv.removeChild(this.buttonA);
			this.holderDiv.removeChild(this.buttonB);
			this.holderDiv.removeChild(this.buttonC);
			this.holderDiv.removeChild(this.buttonD);
		};
        /**
        *
        *
        * @memberof ControllerPad.prototype
        * @method standardControllerButtonSetup
        *
        *
        *
        *
        */
		ControllerPad.prototype.standardControllerButtonSetup = function() {
			this._configStandard("blue");
			this.holderDiv.appendChild(this.dLeft);
			this.holderDiv.appendChild(this.dRight);
			this.holderDiv.appendChild(this.dUp);
			this.holderDiv.appendChild(this.dDown);
			this.holderDiv.appendChild(this.startButton);
			this.holderDiv.appendChild(this.backButton);
			this.holderDiv.appendChild(this.buttonA);
			this.holderDiv.appendChild(this.buttonB);
			this.holderDiv.appendChild(this.buttonC);
			this.holderDiv.appendChild(this.buttonD);
		};
        /**
        *
        *
        *
        * @memberof ControllerPad.prototype
        * @method _standardControllerButtonTakedown
        *
        */
		ControllerPad.prototype._standardControllerButtonTakedown = function() {
			
			this.holderDiv.removeChild(this.dLeft);
			this.holderDiv.removeChild(this.dRight);
			this.holderDiv.removeChild(this.dUp);
			this.holderDiv.removeChild(this.dDown);
			this.holderDiv.removeChild(this.startButton);
			this.holderDiv.removeChild(this.backButton);
			this.holderDiv.removeChild(this.buttonA);
			this.holderDiv.removeChild(this.buttonB);
			this.holderDiv.removeChild(this.buttonC);
			this.holderDiv.removeChild(this.buttonD);
		};
        /**
        * Set up a custom controller pad.
        * Each MoverPoint param defines the x,y position of each button in relation to the top corner of the customImage, set with addCustomImage.
        * The top left point of each button in your image, the top left corner of the image being 0,0.
        *
        *
        * @memberof ControllerPad.prototype
        * @method customControllerButtonSetup
        *
        * @param leftp {MoverPoint}
        * @param rightp {MoverPoint}
        * @param upp {MoverPoint}
        * @param downp {MoverPoint}
        * @param startp {MoverPoint}
        * @param backp {MoverPoint}
        * @param ap {MoverPoint}
        * @param bp {MoverPoint}
        * @param cp {MoverPoint}
        * @param dp {MoverPoint}
        * @param directionButtonsWidth {Number}
        * @param directionButtonsHeight {Number}
        * @param buttonWidth {Number}
        * @param buttonHeight {Number}
        * @param totalWidth {Number}
        * @param totalHeight {Number}
        *
        *
        */
		ControllerPad.prototype.customControllerButtonSetup = function(leftp, rightp, upp, downp, startp,backp,ap,bp,cp,dp, directionButtonsWidth, directionButtonsHeight, startAndBackWidth, startAndBackHeight, buttonWidth, buttonHeight, totalWidth, totalHeight) {
			
			if(leftp) {
				this._customSpecs.leftp = leftp;
				this._customSpecs.rightp = rightp;
				this._customSpecs.upp = upp;
				this._customSpecs.downp = downp;
				this._customSpecs.startp = startp;
				this._customSpecs.backp = backp;
				this._customSpecs.ap = ap;
				this._customSpecs.bp = bp;
				this._customSpecs.cp = cp;
				this._customSpecs.dp = dp;
				this._customSpecs.directionButtonsWidth = directionButtonsWidth;
				this._customSpecs.directionButtonsHeight = directionButtonsHeight;
				this._customSpecs.startAndBackWidth = startAndBackWidth;
				this._customSpecs.startAndBackHeight = startAndBackHeight;
				this._customSpecs.buttonWidth = buttonWidth;
				this._customSpecs.buttonHeight = buttonHeight;
			}
			this.customStyleTotalWidth = totalWidth; this.customStyleTotalHeight = totalHeight;
			this._configCustom("blue");
			this.holderDiv.appendChild(this.dLeft);
			this.holderDiv.appendChild(this.dRight);
			this.holderDiv.appendChild(this.dUp);
			this.holderDiv.appendChild(this.dDown);
			this.holderDiv.appendChild(this.startButton);
			this.holderDiv.appendChild(this.backButton);
			this.holderDiv.appendChild(this.buttonA);
			this.holderDiv.appendChild(this.buttonB);
			this.holderDiv.appendChild(this.buttonC);
			this.holderDiv.appendChild(this.buttonD);
			
		};
        /**
        *
        *
        *
        * @memberof ControllerPad.prototype
        * @method _customControllerButtonTakedown
        *
        */
		ControllerPad.prototype._customControllerButtonTakedown = function() {
			
			this.holderDiv.removeChild(this.dLeft);
			this.holderDiv.removeChild(this.dRight);
			this.holderDiv.removeChild(this.dUp);
			this.holderDiv.removeChild(this.dDown);
			this.holderDiv.removeChild(this.startButton);
			this.holderDiv.removeChild(this.backButton);
			this.holderDiv.removeChild(this.buttonA);
			this.holderDiv.removeChild(this.buttonB);
			this.holderDiv.removeChild(this.buttonC);
			this.holderDiv.removeChild(this.buttonD);
			
		};
        /**
        * Assings default methods for start and back button presses.
        *
        * @memberof ControllerPad.prototype
        * @method assignStartAndBackMethods
        *
        * @param startMethodString {String} name of start method to call
        * @param backMethodString {String} name of back method to call
        * @param methodObjectRef {Object} Object that has the start and back methods
        */
		ControllerPad.prototype.assignStartAndBackMethods = function(startMethodString, backMethodString, methodObjectRef) {
			
			ControllerPad.instance.removeEventListener("padStart", startMethodString, methodObjectRef);
			ControllerPad.instance.removeEventListener("keyStart", startMethodString, methodObjectRef);
			ControllerPad.instance.removeEventListener("touchStart", startMethodString, methodObjectRef);
			ControllerPad.instance.removeEventListener("padBack", backMethodString, methodObjectRef);
			ControllerPad.instance.removeEventListener("keyBack", backMethodString, methodObjectRef);
			ControllerPad.instance.removeEventListener("touchBack", backMethodString, methodObjectRef);
			
			ControllerPad.instance.addEventListener("padStart", startMethodString, methodObjectRef);
			ControllerPad.instance.addEventListener("keyStart", startMethodString, methodObjectRef);
			ControllerPad.instance.addEventListener("touchStart", startMethodString, methodObjectRef);
			ControllerPad.instance.addEventListener("padBack", backMethodString, methodObjectRef);
			ControllerPad.instance.addEventListener("keyBack", backMethodString, methodObjectRef);
			ControllerPad.instance.addEventListener("touchBack", backMethodString, methodObjectRef);
			
		};
		/**
        * Removes the methods assigned with assignStartAndBackMethods
        *
        * @memberof ControllerPad.prototype
        * @method removeStartAndBackMethods
        *
        * @param startMethodString {String} name of start method to call
        * @param backMethodString {String} name of back method to call
        * @param methodObjectRef {Object} Object that has the start and back methods
        */
		ControllerPad.prototype.removeStartAndBackMethods = function(startMethodString, backMethodString, methodObjectRef) {
			
			ControllerPad.instance.removeEventListener("padStart", startMethodString, methodObjectRef);
			ControllerPad.instance.removeEventListener("keyStart", startMethodString, methodObjectRef);
			ControllerPad.instance.removeEventListener("touchStart", startMethodString, methodObjectRef);
			ControllerPad.instance.removeEventListener("padBack", backMethodString, methodObjectRef);
			ControllerPad.instance.removeEventListener("keyBack", backMethodString, methodObjectRef);
			ControllerPad.instance.removeEventListener("touchBack", backMethodString, methodObjectRef);
		
		};
		
		/**
        * Trys to destroy the ControllerPad instance
        *
        * @memberof ControllerPad.prototype
        * @method destroy
        *
        * @param startMethodString {String} optional name of start method that was added via assignStartAndBackMethods
        * @param backMethodString {String} optional name of back method that was added via assignStartAndBackMethods
        * @param methodObjectRef {Object} optional Object that has the start and back methods
        */
		ControllerPad.prototype.destroy = function(startMethodString, backMethodString, methodObjectRef) {
			
			if(ControllerPad.instance) {
				
				if(ControllerPad.instance._style == 1) {
					
					ControllerPad.instance._basicControllerButtonTakedown();
				}
				if(ControllerPad.instance._style == 2) {
					
					ControllerPad.instance._directionalsControllerButtonTakedown();
				}
				if(ControllerPad.instance._style == 3) {
					
					ControllerPad.instance._standardControllerButtonTakedown();
				}
				if(ControllerPad.instance._style == 4) {
					
					ControllerPad.instance._customControllerButtonTakedown();
				}
				if(ControllerPad.instance.dLeft) {
					ControllerPad.instance._unscriptDiv(ControllerPad.instance.dLeft);
				}
				if(ControllerPad.instance.dRight) {
					ControllerPad.instance._unscriptDiv(ControllerPad.instance.dRight);
				}
				if(ControllerPad.instance.dUp) {
					ControllerPad.instance._unscriptDiv(ControllerPad.instance.dUp);
				}
				if(ControllerPad.instance.dDown) {
					ControllerPad.instance._unscriptDiv(ControllerPad.instance.dDown);
				}
				if(ControllerPad.instance.startButton) {
					ControllerPad.instance._unscriptDiv(ControllerPad.instance.startButton);
				}
				if(ControllerPad.instance.backButton) {
					ControllerPad.instance._unscriptDiv(ControllerPad.instance.backButton);
				}
				if(ControllerPad.instance.buttonA) {
					ControllerPad.instance._unscriptDiv(ControllerPad.instance.buttonA);
				}
				if(ControllerPad.instance.buttonB) {
					ControllerPad.instance._unscriptDiv(ControllerPad.instance.buttonB);
				}
				if(ControllerPad.instance.buttonC) {
					ControllerPad.instance._unscriptDiv(ControllerPad.instance.buttonC);
				}
				if(ControllerPad.instance.buttonD) {
					ControllerPad.instance._unscriptDiv(ControllerPad.instance.buttonD);
				}
				if(startMethodString && backMethodString && methodObjectRef) {
					ControllerPad.instance.removeEventListener("padStart", startMethodString, methodObjectRef);
					ControllerPad.instance.removeEventListener("keyStart", startMethodString, methodObjectRef);
					ControllerPad.instance.removeEventListener("touchStart", startMethodString, methodObjectRef);
					ControllerPad.instance.removeEventListener("padBack", backMethodString, methodObjectRef);
					ControllerPad.instance.removeEventListener("keyBack", backMethodString, methodObjectRef);
					ControllerPad.instance.removeEventListener("touchBack", backMethodString, methodObjectRef);
				}
				if(ControllerPad.instance.canvasObject) {
					ControllerPad.instance.canvasObject.canvas.removeEventListener("touchstart", ControllerPad.instance.dispatch, false);
					ControllerPad.instance.canvasObject.canvas.removeEventListener("touchend", ControllerPad.instance.dispatch, false);
					ControllerPad.instance.canvasObject.canvas.removeEventListener("touchmove", ControllerPad.instance.dispatch, false);
					ControllerPad.instance.canvasObject = null;
				}
				
				window.removeEventListener("keydown", ControllerPad.instance.handleKeys, false);
				window.removeEventListener("keyup",  ControllerPad.instance.releaseKeys, false);
				ControllerPad.instance = null;
			}
		};
        /**
        * Don't absolute position the controllers holder div.
        * if you are positioning the controller in a special way you may need to set this so that the holder divs position style is not auto set to absolute.
        * 
        * @memberof ControllerPad
        *
        */
		ControllerPad.prototype._dontAbsolutePositionHolder = 0;
		/**
		*  displays the controller with the given style. show just displays it, it does not set up the buttons, to change the controller use one of the setup methods.
        *  The GameSkeleton Class and tabageos.ResizeGame call this method for you as needed.
        * Default style is 'basicController' see ControllerPad.css
		* The other built in style options are 'directionalsController' 'standController', style as 5 is the rotationController.
		*   
        * The ControllerPad.css stylesheet needs to be applied to the page before this method is called.
		*
		* @param w {Number} The width the controller should be, it will get scaled down if smaller than default
		* @param h {Number} The height the controller should be, both w and h must be defined, otherwise it uses the default w/h.
		* @param style {Number} The style id string or number, to define a custom style use the addCustomImag method and pass in your customStyleName here for this param.
		* @param styleOriginalWidth
		* @param styleOriginalHeight
		* @memberof ControllerPad.prototype
        * @method show
		*/
		ControllerPad.prototype.show = function(w,h,style,styleOriginalWidth,styleOriginalHeight) {
			if(this._style != -1) { //one of the setup methods must be called to establish inital style.
				var sty; //select style, premade or custom string
				if(style && typeof style == "number") {
				  sty = (style == 2 ? "directionalsController" : (style == 1 ?  "basicController" : "standardController") );
				} else { 
					sty = style || "standardController"; 
					if(sty != "standardController") {
						this._style = 4; //custom;
					}
				}
				if(this._style != 4 && this._style != 5) {
					this._style = (sty == "basicController" ? 1 : (sty == "directionalsController" ? 2 : 3));
				}
				
				if(this._style == 1) {
					styleOriginalWidth = 640;
					styleOriginalHeight = 144;
				}
				
				if(this._style == 2) {
					styleOriginalWidth = 640;
					styleOriginalHeight = 191;
				}
				
				if(this._style == 3) {
					styleOriginalWidth = 737;
					styleOriginalHeight = 144;
				}
				if(this._style == 5) {
					sty = "rotationController";
					styleOriginalWidth = 737;
					styleOriginalHeight = 192;
				}
				
				
				
				if(!styleOriginalWidth) {
					
					styleOriginalWidth = this.customStyleTotalWidth;
					styleOriginalHeight = this.customStyleTotalHeight;
				}
				
				//ready the holder div to display background and hold button divs
				if(!this._holderDivParent.contains(this.holderDiv)) {
					this._holderDivParent.appendChild(this.holderDiv);
				}
				
				
				//assign the holder div an id to style it with the controllers image as its background, see ControllerPad.css.
				this.holderDiv.setAttribute("id", sty);
				var toposition = this._dontAbsolutePositionHolder ? "" : "position:absolute;";
				//set the holder div to the actual width and height of the image
				this.holderDiv.setAttribute("style", toposition+"width:"+styleOriginalWidth+"px;height:"+styleOriginalHeight+"px");
				//alert("ffo");
				//now scale the holderDiv to the page, relative to the known width and height of the image,
				//and the given width height desired.
				//passing bigger or smaller w,h values will stretch/scale the image more
				var scaleX = ((w / window.innerWidth) *  (w / styleOriginalWidth) * 10);
				var scaleY = ((h / window.innerHeight) *  (h / styleOriginalHeight) * 10);
				
				var xOffset = ( w / window.innerWidth ) * 10;
				var yOffset = ( h / window.innerHeight ) * 10;
				
				//all the internal button divs will scale as well, (which does not happen correctly without transformations)
				this.holderDiv.style.transformOrigin = "0 0";
				this.holderDiv.style.transform = "scale(" + scaleX/xOffset + " , " + scaleY/yOffset + ")";
				this.hideButtons();
			}
			
		};
        /**
        *
        *
        * hide the ControllerPad
        *  @memberof ControllerPad.prototype
        * @method hide
        */
		ControllerPad.prototype.hide = function() {
			if(this._holderDivParent && this._holderDivParent.contains(this.holderDiv)) {
				try { this._holderDivParent.removeChild(this.holderDiv); } catch (e) {
					window.console.log("caught e during controller.hide:  " + e +"  most likely the controller is in a whole bunch of other divs and html");
				}
			}
		};
		/**
        *
        * establishes keydown and keyup events on the window for handleKeys and releaseKeys
        * used internally.
        *
        * @memberof ControllerPad.prototype
        * @method keyEstablish
        */
		ControllerPad.prototype.keyEstablish = function() {
			window.removeEventListener("keydown", this.handleKeys, false);
			window.removeEventListener("keyup",  this.releaseKeys, false);
			window.addEventListener("keydown", this.handleKeys, false);
			window.addEventListener("keyup",  this.releaseKeys, false);
		};
		ControllerPad.prototype._configBasic = function(str, prs)  { this._style = 1;
			this.dLeft.setAttribute("style", "position:absolute;left:16px;top:16px;width:96px;height:112px;background:"+ (prs ? (this.buttons.left ? str : "transparent") : str) );
			this.dRight.setAttribute("style", "position:absolute;left:128px;top:16px;width:96px;height:112px;background:"+ (prs ? (this.buttons.right ? str : "transparent") : str) );
			this.startButton.setAttribute("style", "position:absolute;left:240px;top:16px;width:96px;height:48px;background:"+ (prs ? (this.buttons.start ? str : "transparent") : str) );
			this.backButton.setAttribute("style", "position:absolute;left:240px;top:80px;width:96px;height:48px;background:"+ (prs ? (this.buttons.back ? str : "transparent") : str) );
			this.buttonA.setAttribute("style", "position:absolute;left:352px;top:16px;width:80px;height:100px;background:"+ (prs ? (this.buttons.a ? str : "transparent") : str) );
			this.buttonB.setAttribute("style", "position:absolute;left:448px;top:16px;width:80px;height:100px;background:"+ (prs ? (this.buttons.b ? str : "transparent") : str) );
			this.buttonC.setAttribute("style", "position:absolute;left:544px;top:16px;width:80px;height:100px;background:"+ (prs ? (this.buttons.c ? str : "transparent") : str) );
			
		};
		ControllerPad.prototype._configDirectional = function(str, prs) { this._style = 2;
			this.dLeft.setAttribute("style", "position:absolute;left:33px;top:63px;width:64px;height:64px;background:"+ (prs ? (this.buttons.left ? str : "transparent") : str) );
			this.dRight.setAttribute("style", "position:absolute;left:161px;top:63px;width:64px;height:64px;background:"+ (prs ? (this.buttons.right ? str : "transparent") : str) );
			this.dUp.setAttribute("style", "position:absolute;left:96px;top:2px;width:64px;height:64px;background:"+ (prs ? (this.buttons.up ? str : "transparent") : str) );
			this.dDown.setAttribute("style", "position:absolute;left:96px;top:128px;width:64px;height:64px;background:"+ (prs ? (this.buttons.down ? str : "transparent") : str) );
			this.startButton.setAttribute("style", "position:absolute;left:272px;top:32px;width:96px;height:48px;background:"+ (prs ? (this.buttons.start ? str : "transparent") : str) );
			this.backButton.setAttribute("style", "position:absolute;left:272px;top:112px;width:96px;height:48px;background:"+ (prs ? (this.buttons.back ? str : "transparent") : str) );
			this.buttonA.setAttribute("style", "position:absolute;left:416px;top:65px;width:64px;height:64px;background:"+ (prs ? (this.buttons.a ? str : "transparent") : str) );
			this.buttonB.setAttribute("style", "position:absolute;left:480px;top:2px;width:64px;height:64px;background:"+  (prs ? (this.buttons.b ? str : "transparent") : str) );
			this.buttonC.setAttribute("style", "position:absolute;left:544px;top:62px;width:64px;height:64px;background:"+  (prs ? (this.buttons.c ? str : "transparent") : str) );
			this.buttonD.setAttribute("style", "position:absolute;left:480px;top:128px;width:64px;height:64px;background:"+  (prs ? (this.buttons.d ? str : "transparent") : str) );
		};
		
		
		
		ControllerPad.prototype._configRotational = function(str, prs) { this._style = 5;
		
			this.rotationPad.setAttribute("style","position:absolute;left:32px;top:16px;width:160px;height:160px;background:"+ (prs ? (this.buttons.start ? str : "transparent") : str) );
			this.startButton.setAttribute("style", "position:absolute;left:224px;top:32px;width:96px;height:48px;background:"+ (prs ? (this.buttons.start ? str : "transparent") : str) );
			this.backButton.setAttribute("style", "position:absolute;left:224px;top:112px;width:96px;height:48px;background:"+ (prs ? (this.buttons.back ? str : "transparent") : str) );
			
			this.buttonA.setAttribute("style", "position:absolute;left:368px;top:32px;width:96px;height:48px;background:"+str);
			this.buttonB.setAttribute("style", "position:absolute;left:368px;top:112px;width:96px;height:48px;background:"+str);
			
			this.dLeft.setAttribute("style", "position:absolute;left:504px;top:65px;width:64px;height:64px;background:"+ (prs ? (this.buttons.a ? str : "transparent") : str) );
			this.dUp.setAttribute("style", "position:absolute;left:568px;top:2px;width:64px;height:64px;background:"+  (prs ? (this.buttons.b ? str : "transparent") : str) );
			this.dRight.setAttribute("style", "position:absolute;left:632px;top:62px;width:64px;height:64px;background:"+  (prs ? (this.buttons.c ? str : "transparent") : str) );
			this.dDown.setAttribute("style", "position:absolute;left:568px;top:128px;width:64px;height:64px;background:"+  (prs ? (this.buttons.d ? str : "transparent") : str) );
		};
		ControllerPad.prototype._configStandard = function(str, prs) { this._style = 3;
			this.dLeft.setAttribute("style", "position:absolute;left:21px;top:42px;width:50px;height:50px;background:"+str);
			this.dRight.setAttribute("style", "position:absolute;left:167px;top:42px;width:50px;height:50px;background:"+str);
			this.dUp.setAttribute("style", "position:absolute;left:91px;top:8px;width:50px;height:50px;background:"+str);
			this.dDown.setAttribute("style", "position:absolute;left:90px;top:85px;width:50px;height:50px;background:"+str);
			this.startButton.setAttribute("style", "position:absolute;left:240px;top:16px;width:96px;height:48px;background:"+str);
			this.backButton.setAttribute("style", "position:absolute;left:240px;top:80px;width:96px;height:48px;background:"+str);
			this.buttonA.setAttribute("style", "position:absolute;left:352px;top:16px;width:80px;height:100px;background:"+str);
			this.buttonB.setAttribute("style", "position:absolute;left:448px;top:16px;width:80px;height:100px;background:"+str);
			this.buttonC.setAttribute("style", "position:absolute;left:544px;top:16px;width:80px;height:100px;background:"+str);
			this.buttonD.setAttribute("style", "position:absolute;left:644px;top:16px;width:80px;height:100px;background:"+str);
		};
		ControllerPad.prototype._configCustom = function(str, prs) { this._style = 4;
			
			this.dLeft.setAttribute("style", "position:absolute;left:"+this._customSpecs.leftp.x+"px;top:"+this._customSpecs.leftp.y+"px;width:"+this._customSpecs.directionButtonsWidth+"px;height:"+this._customSpecs.directionButtonsHeight+"px;background:"+ (prs ? (this.buttons.left ? str : "transparent") : str) );
			this.dRight.setAttribute("style", "position:absolute;left:"+this._customSpecs.rightp.x+"px;top:"+this._customSpecs.rightp.y+"px;width:"+this._customSpecs.directionButtonsWidth+"px;height:"+this._customSpecs.directionButtonsHeight+"px;background:"+ (prs ? (this.buttons.right ? str : "transparent") : str) );
			this.dUp.setAttribute("style", "position:absolute;left:"+this._customSpecs.upp.x+"px;top:"+this._customSpecs.upp.y+"px;width:"+this._customSpecs.directionButtonsWidth+"px;height:"+this._customSpecs.directionButtonsHeight+"px;background:"+ (prs ? (this.buttons.up ? str : "transparent") : str) );
			this.dDown.setAttribute("style", "position:absolute;left:"+this._customSpecs.downp.x+"px;top:"+this._customSpecs.downp.y+"px;width:"+this._customSpecs.directionButtonsWidth+"px;height:"+this._customSpecs.directionButtonsHeight+"px;background:"+ (prs ? (this.buttons.down ? str : "transparent") : str) );
			this.startButton.setAttribute("style", "position:absolute;left:"+this._customSpecs.startp.x+"px;top:"+this._customSpecs.startp.y+"px;width:"+this._customSpecs.startAndBackWidth+"px;height:"+this._customSpecs.startAndBackHeight+"px;background:"+ (prs ? (this.buttons.start ? str : "transparent") : str) );
			this.backButton.setAttribute("style", "position:absolute;left:"+this._customSpecs.backp.x+"px;top:"+this._customSpecs.backp.y+"px;width:"+this._customSpecs.startAndBackWidth+"px;height:"+this._customSpecs.startAndBackHeight+"px;background:"+ (prs ? (this.buttons.back ? str : "transparent") : str) );
			this.buttonA.setAttribute("style", "position:absolute;"+this._addedButtonRectStyle+"left:"+this._customSpecs.ap.x+"px;top:"+this._customSpecs.ap.y+"px;width:"+this._customSpecs.buttonWidth+"px;height:"+this._customSpecs.buttonHeight+"px;background:"+ (prs ? (this.buttons.a ? str : "transparent") : str) );
			this.buttonB.setAttribute("style", "position:absolute;"+this._addedButtonRectStyle+"left:"+this._customSpecs.bp.x+"px;top:"+this._customSpecs.bp.y+"px;width:"+this._customSpecs.buttonWidth+"px;height:"+this._customSpecs.buttonHeight+"px;background:"+ (prs ? (this.buttons.b ? str : "transparent") : str) );
			this.buttonC.setAttribute("style", "position:absolute;"+this._addedButtonRectStyle+"left:"+this._customSpecs.cp.x+"px;top:"+this._customSpecs.cp.y+"px;width:"+this._customSpecs.buttonWidth+"px;height:"+this._customSpecs.buttonHeight+"px;background:"+ (prs ? (this.buttons.c ? str : "transparent") : str) );
			this.buttonD.setAttribute("style", "position:absolute;"+this._addedButtonRectStyle+"left:"+this._customSpecs.dp.x+"px;top:"+this._customSpecs.dp.y+"px;width:"+this._customSpecs.buttonWidth+"px;height:"+this._customSpecs.buttonHeight+"px;background:"+ (prs ? (this.buttons.d ? str : "transparent") : str) );
		};
		
		ControllerPad.prototype.__recurse = -1;
        /**
        * Defines the html button color used during showButtons.
        *
        * @memberof ControllerPad
        *  @type {String}
        *
        */
		ControllerPad.prototype._buttonRectColor = "#6495edbb";
        /**
        * Optional additional css to add to each buttons style.
        *
        * @memberof ControllerPad
        *  @type {String}
        *
        */
		ControllerPad.prototype._addedButtonRectStyle = "";
		/**
        *
        * Can be used to display the actual rectangle hit regions of each button.
        *
        * @memberof ControllerPad.prototype
        * @method showButtons
        *  @param ifPressed {Boolean} only show each button if it is pressed, once set, to unset pass -1.
        *
        */
		ControllerPad.prototype.showButtons = function(ifPressed) {
			if(this.__recurse == -1 && ifPressed) {
				this.__recurse = 1;
			}
			if(ifPressed == -1) { this.__recurse = -1; return; }
			if(this._style == 1) {
				this._configBasic(this._buttonRectColor, ifPressed || 0);
			}
			if(this._style == 2) {
				this._configDirectional(this._buttonRectColor, ifPressed || 0);
			}
			if(this._style == 3) {
				this._configStandard(this._buttonRectColor, ifPressed || 0);
			}
			if(this._style == 4) {
				this._configCustom(this._buttonRectColor, ifPressed || 0);
			}
		};
        /**
        *
        *  hide buttons, by default this is called during setup.
        *
        * @memberof ControllerPad.prototype
        * @method hideButtons
        *
        *
        */
		ControllerPad.prototype.hideButtons = function() {
			if(this._style == 1) {
				this._configBasic("transparent");
			}
			if(this._style == 2) {
				this._configDirectional("transparent");
			}
			if(this._style == 3) {
				this._configStandard("transparent");
			}
			if(this._style == 4) {
				this._configCustom("transparent");
			}
			if(this._style == 5) {
				this._configRotational("transparent");
			}
		};
		/**
        *
        * routes all touch and mouse events to their respective methods.
        *  Calls showButtons if 1 has been set on a showButtons call.
        *  Used internally by each button.
        *
        * @memberof ControllerPad.prototype
        * @method dispatch
        *
        */
		ControllerPad.prototype.dispatch = function(e) {
			if(e) e.preventDefault();
			
			if(e.type == "touchstart" || e.type == "pointerdown") {
				ControllerPad.instance.handleTouches(e); 
				if(ControllerPad.instance.__recurse >= 1) { ControllerPad.instance.showButtons(1); }
				return;
			}
			if(e.type == "touchend" || e.type == "pointerup") {
				ControllerPad.instance.releaseTouches(e); 
				if(ControllerPad.instance.__recurse === 1) { ControllerPad.instance.showButtons(1); }
				return;
			}
			if(e.type == "touchmove" || e.type == "pointermove") {
				ControllerPad.instance.changeTouches(e);
				if(ControllerPad.instance.__recurse === 1) { ControllerPad.instance.showButtons(1); }
				return;
			}
			
			if(e.type == "mousedown") { 
				ControllerPad.instance.handleTouches(e); 
				if(ControllerPad.instance.__recurse >= 1) { ControllerPad.instance.showButtons(1); }
				return;
			}
			if(e.type == "mouseup") {
				ControllerPad.instance.releaseTouches(e); 
				if(ControllerPad.instance.__recurse === 1) { ControllerPad.instance.showButtons(1); }
				return;
			}
		};
        /**
        * Used internally
        *
        * @memberof ControllerPad.prototype
        * @method changeTouches
        *
        */
		ControllerPad.prototype.changeTouches = function(e) {
			e.preventDefault();//touchmove
			var tx,ty,i,touches;
			if(e && e.targetTouches && e.targetTouches.length) {
				//var i = 0;
				//for (i; i < e.targetTouches.length; i++) {
					//var touches = e.targetTouches[i];
					//var tx = touches.pageX * tabageos.MouseController._oX;//oX/Y defined during resize
					//var ty = touches.pageY * tabageos.MouseController._oY;
					//var tpoint = new tabageos.MoverPoint(tx,ty); var tstri = "";
					
					
					if(this._style == 5 && e.target == this.rotationPad) {
						i = 0;
						for (i; i < e.targetTouches.length; i++) {
							touches = e.targetTouches[i];
							tx = touches.pageX * tabageos.MouseController._oX;//oX/Y defined during resize
							ty = touches.pageY * tabageos.MouseController._oY;
						}
						this.rotateWithPoint(tx,ty);
					}
					
					
					if(e.target == this.dRight) {
						this.buttons.right = 1; this.buttons.left = 0;
					} 
					if(e.target == this.dLeft) {
						this.buttons.left = 1; this.buttons.right = 0;
					} 
					if(e.target == this.dUp) {
						this.buttons.up = 1; this.buttons.down = 0;
					} 
					if(e.target == this.dDown) {
						this.buttons.down = 1; this.buttons.up = 0;
					} 
					if(e.target == this.buttonA) {
						this.buttons.a = 1; this.buttons.b = 0; this.buttons.c = 0; this.buttons.d = 0;
					} 
					if(e.target == this.buttonB) {
						this.buttons.b = 1; this.buttons.c = 0; this.buttons.a = 0;this.buttons.d = 0;
					} 
					if(e.target == this.buttonC) {
						this.buttons.c = 1; this.buttons.b = 0;  this.buttons.a = 0;this.buttons.d = 0;
					}
					if(e.target == this.buttonD) {
						this.buttons.c = 0; this.buttons.b = 0;  this.buttons.a = 0; this.buttons.d = 1;
					}
					if(e.target == this.startButton) {
						//if(this.buttons.a == 0 && this.buttons.right == 0 && this.buttons.left == 0) { this.buttons.start = 1; tstri = "Start"; }
					} 
					if(e.target == this.backButton) {
						//if(this.buttons.a == 0 && this.buttons.right == 0 && this.buttons.left == 0) { this.buttons.back = 1; tstri = "Back"; }
					}
					
				//}
				
			} else if (e && e.pointerType && e.pointerType == "touch") {
				
				if(this._style == 5 && e.target == this.rotationPad) {
					tx = e.pageX * tabageos.MouseController._oX;
					ty = e.pageY * tabageos.MouseController._oY;
					this.rotateWithPoint(tx,ty);
				}
				
				if(e.target == this.dRight) {
						this.buttons.right = 1; this.buttons.left = 0;
					} 
					if(e.target == this.dLeft) {
						this.buttons.left = 1; this.buttons.right = 0;
					} 
					if(e.target == this.dUp) {
						this.buttons.up = 1; this.buttons.down = 0;
					} 
					if(e.target == this.dDown) {
						this.buttons.down = 1; this.buttons.up = 0;
					} 
					if(e.target == this.buttonA) {
						this.buttons.a = 1; this.buttons.b = 0; this.buttons.c = 0; this.buttons.d = 0;
					} 
					if(e.target == this.buttonB) {
						this.buttons.b = 1; this.buttons.c = 0; this.buttons.a = 0;this.buttons.d = 0;
					} 
					if(e.target == this.buttonC) {
						this.buttons.c = 1; this.buttons.b = 0;  this.buttons.a = 0;this.buttons.d = 0;
					}
					if(e.target == this.buttonD) {
						this.buttons.c = 0; this.buttons.b = 0;  this.buttons.a = 0; this.buttons.d = 1;
					}
					if(e.target == this.startButton) {
						//if(this.buttons.a == 0 && this.buttons.right == 0 && this.buttons.left == 0) { this.buttons.start = 1; tstri = "Start"; }
					} 
					if(e.target == this.backButton) {
						//if(this.buttons.a == 0 && this.buttons.right == 0 && this.buttons.left == 0) { this.buttons.back = 1; tstri = "Back"; }
					}
				
				
				
				
			}
		};
        /**
        * Used internally
        *
        * @memberof ControllerPad.prototype
        * @method handleTouches
        *
        */
		ControllerPad.prototype.handleTouches = function(e) {
			e.preventDefault();var tstri = "";//touchstart 
			if((e && e.targetTouches && e.targetTouches.length) || e.type == "mousedown" || (e.pointerType && e.pointerType == "touch")) {
				//var i = 0;
				//for (i; i < e.targetTouches.length; i++) {
					//var touches = e.targetTouches[i];
					//var tx = touches.pageX * tabageos.MouseController._oX;//oX/Y defined during resize
					//var ty = touches.pageY * tabageos.MouseController._oY;
					
					if(e.target == this.dRight) {
						this.buttons.right = 1; this.buttons.left = 0;
					} 
					if(e.target == this.dLeft) {
						this.buttons.left = 1; this.buttons.right = 0;
					} 
					if(e.target == this.dUp) {
						this.buttons.up = 1; this.buttons.down = 0;
					} 
					if(e.target == this.dDown) {
						this.buttons.down = 1; this.buttons.up = 0;
					} 
					if(e.target == this.buttonA) {
						this.buttons.a = 1;this.buttons.b = 0;this.buttons.c = 0;this.buttons.d = 0;
					} 
					if(e.target == this.buttonB) {
						this.buttons.b = 1; this.buttons.c = 0;this.buttons.d = 0;this.buttons.a = 0;
					} 
					if(e.target == this.buttonC) {
						this.buttons.c = 1; this.buttons.b = 0;this.buttons.a = 0;this.buttons.d = 0;
					} 
					if(e.target == this.buttonD) {
						this.buttons.d = 1; this.buttons.b = 0; this.buttons.c = 0;this.buttons.a = 0;
					}
					if(e.target == this.startButton) {
						if(this.buttons.a == 0 && this.buttons.right == 0 && this.buttons.left == 0) { this.buttons.start = 1; tstri = "Start"; }
					} 
					if(e.target == this.backButton) {
						if(this.buttons.a == 0 && this.buttons.right == 0 && this.buttons.left == 0) { this.buttons.back = 1; tstri = "Back"; }
					} 
				//}
			}
			
			if(tstri != "") { ControllerPad.instance.dispatchEvent(new tabageos.Event("touch"+tstri)); }
		};
		ControllerPad.prototype.addedRotationX = 0;
		ControllerPad.prototype.addedRotationY = 0;
		/**
		*
		* The center x of the rotation pads circle on the whole screen.
		* For example, if the game has a width of 496, the middle of the rotation circle at full screen is about 64 to 120.
		* If the game is not full screen you will need to calculate where the game edge starts and count from there plus about 64 to 120.
		*  This number should define the middle x of the rotation circle image when the controller is shown.
        *
        *
		* centerRotationX and centerRotationY are pretty much arrived at by trial and error.
        *
        *  But the general formula when fullscreen is:
        *
        *           centerRotationX = 0 + 64;  
        *           centerRotationY = gameHeight + (this._scaleRectRef.height/(this._scaleRectRef.height/gameHeight)) - 64;
        *           ('this' would be a setup inherited instance of the GameSkeleton which would have _scaleRectRef available)
		*
		*  And the general formula for when not full screen is:
        *
		*         var fif = window.innerWidth/2;//50%
		*         var containerleft = fif - 248;//50% - half game width is what the container is positioned at when using the GameSkeleton Class.
		*         controller.centerRotationX = containerleft + 64;
        *         controller.centerRotationY = gameHeight + 64;
        *
        *  Use the above as general guides, test in dev tools and adjust as needed.
        *  The controller should generally work in dev tools with your finger able to rotate around the black part of the rotation circle.
        *  Arrive at definite numbers and it should work at all sizes, so generally you would just need to change the 64's in the formulas.
        *
		* @memberof ControllerPad
		*/
		ControllerPad.prototype.centerRotationX = 360;
		/**
		*
		*
		* The center y of the rotation pads circle on the whole screen.
		* see centerRotationX
		* @memberof ControllerPad
		*/
		ControllerPad.prototype.centerRotationY = 360;
		/**
        * for rotation the principle is to get the middle point and use atan2() * 180 / pi.
		* the other things making this possible are in the MouseController Class and the static tabageos.ResizeGame method. 
        * Together they translate the touch point into a point within gameWidth/Height.
		* when set up for capturing rotation, the controller calls rotateWithPoint on touchmove with the translate cords.
		* the Rotating[Traveler/Shooter] Classes then need only use .setRotation(controller.rotation) to rotate via the controller.
        *
        * @memberof ControllerPad.prototype
        * @method rotateWithPoint
        *
        * @param x {Number}
        * @param y {Number}
        * @param addedX {Number}
        * @param addedY {Number}
        * @param centerX {Number} The center x point of the rotation see centerRotationX, centerRotationX is used by default.
        * @param centerY {Number} The center y point of the rotation see centerRotationY, centerRotationY is used by default.
        *
		*/
        ControllerPad.prototype.rotateWithPoint = function(x,y, addedX, addedY, centerX,centerY) {
			this.rotation = Math.atan2((y + (addedY || this.addedRotationY)) - (centerY||this.centerRotationY), (x + (addedX || this.addedRotationX)) - (centerX||this.centerRotationX)) * 180 / Math.PI;
		};
		
		/**
        * Used internally
        *
        * @memberof ControllerPad.prototype
        * @method releaseTouches
        *
        */
		ControllerPad.prototype.releaseTouches = function(e) {
			e.preventDefault();//touch end
			//var touches = e.changedTouches;
			//var tx = touches[0].pageX * tabageos.MouseController._oX;//oX/Y defined during resize
			//var ty = touches[0].pageY * tabageos.MouseController._oY;
			//var tpoint = new tabageos.MoverPoint(tx,ty);
			
			if(e.target == this.dRight) {
				this.buttons.right = 0; 
			} 
			if(e.target == this.dLeft) {
				this.buttons.left = 0; 
			} 
			if(e.target == this.dUp) {
				this.buttons.up = 0; 
			} 
			if(e.target == this.dDown) {
				this.buttons.down = 0; 
			} 
			if(e.target == this.buttonA) {
				this.buttons.a = 0;
			} 
			if(e.target == this.buttonB) {
				this.buttons.b = 0; 
			} 
			if(e.target == this.buttonC) {
				this.buttons.c = 0;
			} 
			if(e.target == this.buttonD) {
				this.buttons.d = 0;
			}
			this.buttons.start = 0; this.buttons.back = 0;
		};
		
		
		/** 
		*   For override, called before keyCode checks during handleKeys.
		*	let's say you wanted users to be able to use either wasd or arrows
		*	then you can overide ._preHandleKeys and do for example;
		*	 if(e.keyCode == 39 || e.keyCode == 37 || e.keyCode == 38 || e.keyCode == 40) {
		*		controller.keyboardEquivalents = controller.arrows;
		*	 } else {
		*		controller.keyboardEquivalents = controller.wasd;
		*	 }
		*	or you wanted the keyboard equivalents to change based on the level
		*	or some other factor, then this overideable blank function is for that
		*	it gets called just before any checks of keyboardEquivalents are done.
		*
		*    If you want both WASD and Arrows to be used, you can also
		*    just call .acceptWASDAndArrows, which overrides ._preHandleKeys for you.
		* @memberof ControllerPad.prototype
        * @method _preHandleKeys
		*/
		ControllerPad.prototype._preHandleKeys = function(e) {
			
		};
        /**
        *
        * Sets up _preHandleKeys to change keyboardEquivalents based on what is pressed wasd or arrows. Allowing for both to be used.
        *
        * @memberof ControllerPad.prototype
        * @method acceptWASDAndArrows
        *
        */
		ControllerPad.prototype.acceptWASDAndArrows = function() {
			this._preHandleKeys = function(e) { 
				if(e.keyCode == 39 || e.keyCode == 37 || e.keyCode == 38 || e.keyCode == 40) {
					this.keyboardEquivalents = (this._style != 2 ? this.basicArrows : this.arrows);
				} else {
					this.keyboardEquivalents = (this._style != 2 ? this.basicWasd : this.wasd);
				}
			};
		};
        /**
        * Used internally
        *
        * @memberof ControllerPad.prototype
        * @method handleKeys
        *
        */
		ControllerPad.prototype.handleKeys = function(e) {
			if (typeof e == 'undefined') e = window.event;
			//e.preventDefault();
			//var oe = new tabageos.Event("touchstart");
			var inst = ControllerPad.instance; inst._preHandleKeys(e);
			if(e.keyCode == inst.keyboardEquivalents.right) { inst.buttons.right = 1; inst.buttons.left = 0;
				//oe.potato.targetTouches = [{pageX: inst.dRight.x/tabageos.MouseController._oX, pageY: inst.dRight.y/tabageos.MouseController._oY}];
			} 
			if(e.keyCode == inst.keyboardEquivalents.left) { inst.buttons.left = 1; inst.buttons.right = 0; 
				//oe.potato.targetTouches = [{pageX: inst.dLeft.x/tabageos.MouseController._oX, pageY: inst.dLeft.y/tabageos.MouseController._oY}];
			} 
			if(e.keyCode == inst.keyboardEquivalents.up) { inst.buttons.up = 1; inst.buttons.down = 0;
				//oe.potato.targetTouches = [{pageX: inst.dUp.x/tabageos.MouseController._oX, pageY: inst.dUp.y/tabageos.MouseController._oY}];
			} 
			if(e.keyCode == inst.keyboardEquivalents.down) { inst.buttons.up = 0; inst.buttons.down = 1;
				//oe.potato.targetTouches = [{pageX: inst.dDown.x/tabageos.MouseController._oX, pageY: inst.dDown.y/tabageos.MouseController._oY}];
			}
			if(e.keyCode == inst.keyboardEquivalents.a) { inst.buttons.a = 1;
				//oe.potato.targetTouches = [{pageX: inst.buttonA.x/tabageos.MouseController._oX, pageY: inst.buttonA.y/tabageos.MouseController._oY}];
			}
			if(e.keyCode == inst.keyboardEquivalents.b) { inst.buttons.b = 1; 
				//oe.potato.targetTouches = [{pageX: inst.buttonB.x/tabageos.MouseController._oX, pageY: inst.buttonB.y/tabageos.MouseController._oY}];
			}
			if(e.keyCode == inst.keyboardEquivalents.c) { inst.buttons.c = 1;
				//oe.potato.targetTouches = [{pageX: inst.buttonC.x/tabageos.MouseController._oX, pageY: inst.buttonC.y/tabageos.MouseController._oY}];
			} 
			if(e.keyCode == inst.keyboardEquivalents.d) { inst.buttons.d = 1;
				//oe.potato.targetTouches = [{pageX: inst.buttonD.x/tabageos.MouseController._oX, pageY: inst.buttonD.y/tabageos.MouseController._oY}];
			}
			if(e.keyCode == inst.keyboardEquivalents.start) { inst.buttons.start = 1;
				//oe.potato.targetTouches = [{pageX: inst.startButton.x/tabageos.MouseController._oX, pageY: inst.startButton.y/tabageos.MouseController._oY}];
			}
			if(e.keyCode == inst.keyboardEquivalents.back) { inst.buttons.back = 1;
				//oe.potato.targetTouches = [{pageX: inst.backButton.x/tabageos.MouseController._oX, pageY: inst.backButton.y/tabageos.MouseController._oY}];
			}
			//ControllerPad.instance.dispatch(oe);
			//inst.canvasObject.canvas.dispatchEvent(oe);
			
			if(e.keyCode == 118 && inst._gamePlayRecorder) {
				
				//inst._gamePlayRecorder.exportPressLog();
			}
		};
        /**
        * Used internally
        *
        * @memberof ControllerPad.prototype 
        * @method releaseKeys
        *
        */
		ControllerPad.prototype.releaseKeys = function(e) {
			if (typeof e == 'undefined') e = window.event;
			//e.preventDefault();
			//var changedTouches; 
			var inst = ControllerPad.instance;
			var kstri = "";
			if(e.keyCode == inst.keyboardEquivalents.right) { inst.buttons.right = 0; 
				//changedTouches = [{pageX: inst.dRight.x/tabageos.MouseController._oX, pageY: inst.dRight.y/tabageos.MouseController._oY}];
			} 
			if(e.keyCode == inst.keyboardEquivalents.left) { inst.buttons.left = 0; 
				//changedTouches = [{pageX: inst.dLeft.x/tabageos.MouseController._oX, pageY: inst.dLeft.y/tabageos.MouseController._oY}];
			} 
			if(e.keyCode == inst.keyboardEquivalents.up) { inst.buttons.up = 0; 
				//changedTouches = [{pageX: inst.dUp.x/tabageos.MouseController._oX, pageY: inst.dUp.y/tabageos.MouseController._oY}];
			} 
			if(e.keyCode == inst.keyboardEquivalents.down) { inst.buttons.down = 0; 
				//changedTouches = [{pageX: inst.dDown.x/tabageos.MouseController._oX, pageY: inst.dDown.y/tabageos.MouseController._oY}];
			}
			if(e.keyCode == inst.keyboardEquivalents.a) { inst.buttons.a = 0; 
				//changedTouches = [{pageX: inst.buttonA.x/tabageos.MouseController._oX, pageY: inst.buttonA.y/tabageos.MouseController._oY}];
			}
			if(e.keyCode == inst.keyboardEquivalents.b) { inst.buttons.b = 0; 
				//changedTouches = [{pageX: inst.buttonB.x/tabageos.MouseController._oX, pageY: inst.buttonB.y/tabageos.MouseController._oY}];
			}
			if(e.keyCode == inst.keyboardEquivalents.c) { inst.buttons.c = 0; 
				//changedTouches = [{pageX: inst.buttonC.x/tabageos.MouseController._oX, pageY: inst.buttonC.y/tabageos.MouseController._oY}];
			} 
			if(e.keyCode == inst.keyboardEquivalents.d) { inst.buttons.d = 0; 
				//changedTouches = [{pageX: inst.buttonD.x/tabageos.MouseController._oX, pageY: inst.buttonD.y/tabageos.MouseController._oY}];
			} 
			if(e.keyCode == inst.keyboardEquivalents.start) { inst.buttons.start = 0; kstri = "Start";
				//changedTouches = [{pageX: inst.startButton.x/tabageos.MouseController._oX, pageY: inst.startButton.y/tabageos.MouseController._oY}];
			}
			if(e.keyCode == inst.keyboardEquivalents.back) { inst.buttons.back = 0; kstri = "Back";
				//changedTouches = [{pageX: inst.backButton.x/tabageos.MouseController._oX, pageY: inst.backButton.y/tabageos.MouseController._oY}];
			} 
			
			if(kstri != "") { inst.dispatchEvent(new tabageos.Event("key"+kstri)); }
			//var oe = new tabageos.Event("touchend", changedTouches); 
			//ControllerPad.instance.dispatch(oe);
			//inst.canvasObject.canvas.dispatchEvent(oe);
		};
		
		ControllerPad.prototype.usingGamePad = 0;
		/**
		* the pad.buttons[index] of each game pad button
		* In general you should not change these yourself, unless you know the specific usb controller
		* your players will be using. Use .configureGamePadButtons when you don't know what specific usb game pad your users will have.
		* As is, these indexes are the numbers given by the Radio Shack Playstation controller to usb converter,
		* obviously it is most likely that players will have many different types of usb controllers.
        * @memberof ControllerPad
		*/
		ControllerPad.prototype.gamePadButtons = {a:0, b:3, c:2, d:1, s:9, st:11};
		/**
		* ._gpb is the private mirror of .gamePadButtons. (in JavaScript many developers will use an underscore to denote private or static vars, which is the case in tbgs.js. ControllerPad.js is using them as setter/getters, so very strictly not supposed to be changed, because that JavaScript can't do real getters/setters in all browers)
		* Your not supposed to change ._gpb, together with .configureGamePadButtons, .gamePadButtons therefore opperates as a setter.
		* Call .configureGamePadButtons() during a loop to properly set up buttons based on the users usb controller inputs.
		* There is no better way to accomplish setting up the buttons in a universal manner, because each controller may send
		* out different numbers for each button, therefore the best thing to do is let the user press the buttons first, and assign them that way,
		* all that is set up already and done for you by simply calling .configureGamePadButtons in a loop, see .handleGamePad.
        *
        * @memberof ControllerPad
		*/
		ControllerPad.prototype._gpb = {a:-1, b:-1, c:-1, d:-1, s:-1, st:-1};
		ControllerPad.prototype.gamePadButtonsUserDefined = 0;
		ControllerPad.prototype.requestForAButton = "please press your game pads a button";//for example in Subsist Giants, its "please press the jump button"
		ControllerPad.prototype.requestForBButton = "please press your game pads b button";
		ControllerPad.prototype.requestForCButton = "please press your game pads c button";
		ControllerPad.prototype.requestForDButton = "please press your game pads d button";
		ControllerPad.prototype.requestForSButton = "please press your game pads select/back button";
		ControllerPad.prototype.requestForSTButton = "please press your game pads start button";
		ControllerPad.prototype._createRequestDiv = function(inner, clear) {
			var div = document.getElementById("buttonsRequest") || document.createElement("div");
			div.setAttribute("id", "buttonsRequest");
			div.setAttribute("style", "position:absolute;color:black;top:8px;left:25%;width:250px;height:75px;border:thin solid black;background:white;z-index:999999999999999999999999999999999999999999999");
			div.innerHTML = inner;document.body.appendChild(div);
			if(clear) { document.body.removeChild(div); }
		};
		ControllerPad.prototype._gpa = 0;
        /**
        *
        *
        * Returns 1 if a game pad is available.
        *
        * @memberof ControllerPad.prototype
        * @method gamePadAvailable
        * @return {Number}
        *
        *
        *
        *
        */
		ControllerPad.prototype.gamePadAvailable = function() { //window.gamePadEvent
			var pads, pad, i, l;
			if(ControllerPad.instance._gpa == 0) {
				pads = (navigator && navigator.getGamepads) ? navigator.getGamepads() : []; l = pads.length; i = 0;
				for(i;i<l;i++) { pad = pads[i]; if(pad) { ControllerPad.instance._gpa = 1; break; } }
				return ControllerPad.instance._gpa;
			} else {
				return 1;
			}
		};
   
		/**
		* To be called during a loop.
		* see .handleGamePad
        *
        *@memberof ControllerPad.prototype
        * @method configureGamePadButtons
		*/
		ControllerPad.prototype.configureGamePadButtons = function() {
			var pads, pad, i, l;
			if(ControllerPad.instance._gpb.a == -1) {
				//window.console.log(navigator.getGamepads());
                
				pads = (navigator && navigator.getGamepads) ? navigator.getGamepads() : 0; l = pads ? pads.length : 0; i = 0;
				for(i;i<l;i++) { pad = pads[i]; if(pad) { break; } }
				if(!pad) return 0;
               // window.console.log(ControllerPad.instance._gpb.a);
				ControllerPad.instance._createRequestDiv(ControllerPad.instance.requestForAButton);
				
				if(pad && pad.buttons) { i = 0; l = pad.buttons.length;
					for(i;i<l;i++) { if(pad.buttons[i].pressed) { ControllerPad.instance._gpb.a = i; break;  } }
				} return 0;
			}
			if(ControllerPad.instance._gpb.b == -1) {
				ControllerPad.instance._createRequestDiv(ControllerPad.instance.requestForBButton);
				pads = (navigator && navigator.getGamepads) ? navigator.getGamepads() : 0; l = pads ? pads.length : 0; i = 0;
				for(i;i<l;i++) { pad = pads[i]; if(pad) { break; } }
				
				if(pad && pad.buttons) { i = 0; l = pad.buttons.length;
					for(i;i<l;i++) {
						if(pad.buttons[i].pressed && i != ControllerPad.instance._gpb.a && i != ControllerPad.instance._gpb.c && i != ControllerPad.instance._gpb.d) {
							ControllerPad.instance._gpb.b = i; break; 
						}
					}
				} return 0;
			}
			if(ControllerPad.instance._gpb.c == -1) {
				ControllerPad.instance._createRequestDiv(ControllerPad.instance.requestForCButton);
				pads = (navigator && navigator.getGamepads) ? navigator.getGamepads() : 0; l = pads ? pads.length : 0; i = 0;
				for(i;i<l;i++) { pad = pads[i]; if(pad) { break; } }
				
				if(pad && pad.buttons) { i = 0; l = pad.buttons.length;
					for(i;i<l;i++) {
						if(pad.buttons[i].pressed && i != ControllerPad.instance._gpb.a && i != ControllerPad.instance._gpb.b && i != ControllerPad.instance._gpb.d) {
							ControllerPad.instance._gpb.c = i;  break; 
						}
					}
				} return 0;
			}
			if(ControllerPad.instance._gpb.d == -1) {
				ControllerPad.instance._createRequestDiv(ControllerPad.instance.requestForDButton);
				pads = (navigator && navigator.getGamepads) ? navigator.getGamepads() : 0; l = pads ? pads.length : 0; i = 0;
				for(i;i<l;i++) { pad = pads[i]; if(pad) { break; } }
				
				if(pad && pad.buttons) { i = 0; l = pad.buttons.length;
					for(i;i<l;i++) {
						if(pad.buttons[i].pressed && i != ControllerPad.instance._gpb.a && i != ControllerPad.instance._gpb.c && i != ControllerPad.instance._gpb.b) {
							ControllerPad.instance._gpb.d = i; break; 
						}
					}
				} return 0;
			}
			if(ControllerPad.instance._gpb.s == -1) {
				ControllerPad.instance._createRequestDiv(ControllerPad.instance.requestForSButton);
				pads = (navigator && navigator.getGamepads) ? navigator.getGamepads() : 0; l = pads ? pads.length : 0; i = 0;
				for(i;i<l;i++) { pad = pads[i]; if(pad) { break; } }
				
				if(pad && pad.buttons) { i = 0; l = pad.buttons.length;
					for(i;i<l;i++) {
						if(pad.buttons[i].pressed && i != ControllerPad.instance._gpb.a && i != ControllerPad.instance._gpb.c && i != ControllerPad.instance._gpb.b && i != ControllerPad.instance._gpb.d) {
							ControllerPad.instance._gpb.s = i; break; 
						}
					}
				} return 0;
			}
			if(ControllerPad.instance._gpb.st == -1) {
				ControllerPad.instance._createRequestDiv(ControllerPad.instance.requestForSTButton);
				pads = (navigator && navigator.getGamepads) ? navigator.getGamepads() : 0; l = pads ? pads.length : 0; i = 0;
				for(i;i<l;i++) { pad = pads[i]; if(pad) { break; } }
				
				if(pad && pad.buttons) { i = 0; l = pad.buttons.length;
					for(i;i<l;i++) {
						if(pad.buttons[i].pressed && i != ControllerPad.instance._gpb.a && i != ControllerPad.instance._gpb.c && i != ControllerPad.instance._gpb.b && i != ControllerPad.instance._gpb.d && i != ControllerPad.instance._gpb.s) {
							ControllerPad.instance._gpb.st = i; break; 
						}
					}
				} return 0;
			}
			
			ControllerPad.instance.gamePadButtons.a = ControllerPad.instance._gpb.a;
			ControllerPad.instance.gamePadButtons.b = ControllerPad.instance._gpb.b;
			ControllerPad.instance.gamePadButtons.c = ControllerPad.instance._gpb.c;
			ControllerPad.instance.gamePadButtons.d = ControllerPad.instance._gpb.d;
			ControllerPad.instance.gamePadButtons.s = ControllerPad.instance._gpb.s;
			ControllerPad.instance.gamePadButtons.st = ControllerPad.instance._gpb.st;
			ControllerPad.instance._createRequestDiv("",1);
			ControllerPad.instance.gamePadButtonsUserDefined = 1;
			
			ControllerPad.instance.buttons.start = 1;//so that pause is not called when start button is first pressed for defining.
			
			return 1;
		};
		/**
		*
		*  Call during your game loop, after movement has already happened.
		*  Basic GamePad functionality. Should produce correct directional response from any pad,
		*  But each game pad is different and each may send out different index values for the specific buttons.
		*  Directional input is done by axsis therefore it should work for all pads,
		*  button input however may vary more, best thing is to let the user set the buttons (not directionals)
		*  call configureGamePadButtons during your game loop, until it returns 1 or until gamePadButtonsUserDefined is 1.
		*  then start calling handleGamePad, for example; 
		*
		*   	 	if(!controller.gamePadButtonsUserDefined) {
		*				controller.configureGamePadButtons();
		*			} else {
		*				controller.handleGamePad();
		*			}
		*  @memberof ControllerPad.prototype
        *  @method handleGamePad
		*
		*/
		ControllerPad.prototype.handleGamePad = function() { // call during the game loop
			var pads, pad, i, l, inst, hoff, voff, doff, boff, aoff, coff;
			hoff = 1; voff = 1; doff = 1; boff = 1; aoff = 1; coff = 1;
			pads = (navigator && navigator.getGamepads) ? navigator.getGamepads() : []; l = pads.length; i = 0;
			for(i;i<l;i++) { pad = pads[i]; if(pad) { break; } }
			if(pad) { inst = ControllerPad.instance; 
				if(pad.axes && pad.axes[0]) { //horizontal
					if(pad.axes[0] >= 1) { //right 
						inst.buttons.right = 1;inst.buttons.left = 0;inst.usingGamePad = 1; hoff = 0;
					}
					if(pad.axes[0] <= -1) {
						inst.buttons.left = 1;inst.buttons.right = 0;inst.usingGamePad = 1; hoff = 0;
					}
					if(pad.axes[0] < 1 && pad.axes[0] > -1 && inst.usingGamePad == 1) {
						inst.buttons.right = 0;inst.buttons.left = 0; hoff = 1;
					}
				}
				if(pad.axes && pad.axes[1]) { //vertical 
					if(pad.axes[1] >= 1) { //down
						inst.buttons.down = 1;inst.usingGamePad = 1; voff = 0;
					}
					if(pad.axes[1] <= -1) {
						inst.buttons.up = 1;inst.usingGamePad = 1; voff = 0;
					}
					if(pad.axes[1] < 1 && pad.axes[1] > -1 && inst.usingGamePad == 1) {
						inst.buttons.up = 0;inst.buttons.down = 0; voff = 1;
					}
				}
				if(pad.buttons && pad.buttons[inst.gamePadButtons.d]) { // existence checks
					if(pad.buttons[inst.gamePadButtons.d].pressed) { //'pressed' is what pads send out, also 'value' 0.0 to 1.0.
						inst.buttons.d = 1;inst.usingGamePad = 1; doff = 0;
					} else { if(inst.usingGamePad == 1) { inst.buttons.d = 0; doff = 1;} }
				}
				if(pad.buttons && pad.buttons[inst.gamePadButtons.b]) { // 
					if(pad.buttons[inst.gamePadButtons.b].pressed) {
						inst.buttons.b = 1;inst.usingGamePad = 1; boff = 0;
					} else { if(inst.usingGamePad == 1) { inst.buttons.b = 0; boff = 1;} }
				}
				if(pad.buttons && pad.buttons[inst.gamePadButtons.c]) { // 
					if(pad.buttons[inst.gamePadButtons.c].pressed) {
						inst.buttons.c = 1;inst.usingGamePad = 1; coff = 0;
					} else { if(inst.usingGamePad == 1) { inst.buttons.c = 0; coff = 1;} }
				}
				if(pad.buttons && pad.buttons[inst.gamePadButtons.a]) { // 
					if(pad.buttons[inst.gamePadButtons.a].pressed) {
						inst.buttons.a = 1;inst.usingGamePad = 1; aoff = 0;
					} else { if(inst.usingGamePad == 1) {inst.buttons.a = 0; aoff = 1;} }
				} //with my controller (radioshack playstation controller to usb adapter)
				//the button indexes are as above (gamePadButtons)
				//however,as noted, different game controllers may send out different indexes for each button.
				//when controller buttons are needed, call configureGamePadButtons in your loop first,
				//until gamePadButtonsUserDefined is 1. configureGamePadButtons will ask the user to press each button
				//and stores the indexes in gamePadButtons
				
				//start
				if(pad.buttons && pad.buttons[inst.gamePadButtons.st]) { // 
					if(pad.buttons[inst.gamePadButtons.st].pressed ) {
						if(inst.buttons.start == 0) inst.dispatchEvent(new tabageos.Event("padStart"));
						inst.buttons.start = 1;inst.usingGamePad = 1; 
					} else { inst.buttons.start = 0; }
				}
				
				//select
				if(pad.buttons && pad.buttons[inst.gamePadButtons.s]) { // 
					if(pad.buttons[inst.gamePadButtons.s].pressed) {
						if(inst.buttons.back == 0) inst.dispatchEvent(new tabageos.Event("padBack"));
						inst.buttons.back = 1;inst.usingGamePad = 1; 
					} else { inst.buttons.back = 0; }
				}
				
				if(hoff && voff && doff && boff && coff && aoff) { inst.usingGamePad = 0; }
			} 
			
		};
		/**
        * Used internally
        *
        * @memberof ControllerPad.prototype
        * @method _selfStyle
        *
        */
		ControllerPad._selfStyle = function(customStyleName, customStyleData) {
			
			var controllerCss = 'div#basicController {position:relative;z-index:9999999999999999999999; background: no-repeat url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoEAAACQCAYAAAB3RrGvAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nO3deViUVf8/8PcAsskiIm6giIoKKCiguOCOAQJuD27V456PZGmZv6+mldqTqJVrUZKWa6WSqGCouZVZkiQooSiLu4SKjGwi28zvjx7IaUZhxpm5Z3m/rqvr0nPuc98fnJj5zLnP/TmiVcv+lIKIiIiIjMbQMGljE6GDICIiIiLtYxJIREREZITMnvzLmZSP8OBhtlCxEBEREZEGONh3QL9eC2TaZJLAkkf5eFh0XZsxEREREZGGNTKzlmvj7WAiIiIiI8QkkIiIiMgIMQkkIiIiMkJMAomIiIiMEJNAIiIiIiPEJJCIiIjICDEJJCIiIjJCTAKJiIiIjBCTQCIiIiIjZFb/IUSkD9q0GgFIhY7CeBSXZaOoJFPoMIiIVMYkkMhAdGo3E4BI6DCMxvU7e5gEEpFe4+1gIiIiIiPEmUAiA+TS1hxW1vyOp253blXiUZlE6DCIiNSCSSCRARo5tgk6drIQOgyDs3H9fVy59FjoMIiI1ELlJNDe1hPurlPVGQvV427Bz7iVn6Dx69jZdEandjM0fh36273CZNzM2yt0GEREZERUTgLNG9nB3tZTnbFQPUrKcrVynUZmtnxttays/KbQIRARkZHhoiEiIiIiI6S2NYHNW5jBqjFzSnWSSoCb1yuFDgNOLcxgzddW7W5cFf61JSIi46W2JDDiX03Q1cdKXacjAJUVUiyYc1voMDB8pD26+1kLHYZBkUiAt6JuCR0GEREZMT4dTEQkCBH6dN8odBB653FlAdIuLVb7eX26vAdrS2e1n9fQnU2fixqJep+Y79h2Kpya9lbrOY1BRvZHKCnLUWoMk0AiIgGIRCJYW7kIHYbeMTFppJHzWlq04OuhApGJCaDm0pnm5k35WqjA1ET5smBc6EVERERkhDgTSESkA9q1N0cbV3Ohw9BJ2ZcrkP9nldau16y5GTy8LLV2PX2Sd7sKudkVWruelbUJ/AO4Jl2Rooc1SE8rf65zMAkkMmLl5eWwshL2ga6amhqYmpoKNl5XeHlbISjUTugwdNK32wq1mgS6tDHHmAkOWruePjl1okSrSaCNjQlfi6fIzapgEkhEDXP37l1s2rQJR48eRWZmJu7fv1/XZ2trC3d3dwwYMACvvPIKPD3/LhZ+7Ngx3LypWjHrAQMGoGPHjnV/v3HjBuLi4pCQkIDc3Fzcu3cPEokEzZs3R9u2bREeHo7IyEh4eHgoPF9FRQWSkpKwd+9enD17Fnl5eSgrK4OtrS2cnZ3Rr18/REZGYtiwYTKJ4fbt21FdXa3SzzB+/Hg0btxYpbFERLqMSSCREUhISMBLL72E0tJShf0lJSVITU1FamoqPvnkE6xduxavv/46AGD9+vU4ePCgStfdsmULOnbsCIlEgkWLFmHNmjWoqpKf0cnPz0d+fj7Onj2LJUuWYPr06YiJiYG5+d+3R3/99VdMmjQJubnyO+eUlJTg8uXLuHz5Mr788kv4+vpi165dcHd3BwDMmjUL5eWqfWMOCgpiEkhEBokPhhAZuHv37ilMAFu0aIHRo0ejTZs2Mu01NTV44403kJycrLYYli5dilWrVsklgE5OTmjdurVMm1QqxebNmxEVFVXXdu3aNYSEhMglgA4ODvDz84Olpez6rdTUVAQFBaGsrExtPwMRkaHhTCCRgTt8+LDCGcAzZ87Azc0NYrEYHh4euHv3bl2fRCJBbGwsevfujcjISHh5ecmMjYmJkTunt7c3QkNDZdq6desGiUSCtWvXyl1/1KhR+O6772Bqaor58+dj9erVMv1bt27FqlWr0KxZM8TGxqKkpESm39LSEpmZmWjRogWSk5PRt29fSKXSuv6bN28iLi4OU6ZMwfz581FZ+fcOLQ8ePMDmzZvlYoqIiJC5FQ4A9vb2cscRERkCJoFEBu7evXtybba2tnBzcwPw12xaWFgYvvrqK5ljUlNTAQCTJ0+WG799+3a5JNDf3x8rV66UOzY/P19hEtqvX7+6dXsDBw6USwIlEgmuXbuGZs2a4erVq3LjW7RogRYtWgAAevfuDS8vL2RkZMgck5PzV+HU999/X6Y9MzNTYRI4fvx4vPTSS3LtRESGiLeDiQzck7NjT2tzdpbfKaGgoEAt16+pqVHYLhKJFP5Z0ViJpP5qtP+8rdzQcURExopJIJERKi0tlZkhbNRIfhcGfUugzMx4Y4OISBlMAokMnKOjo8L2L774QsuREBGRLuFXZyIDFxISgkaNGsk9mfvBBx9g6NCh6NOnD2bMmIHhw4fL9CuaHdRljx/Lb2L/ZIkZIiKSxSSQyMC1bt0aixYtwrJly2TaKyoqEBISgvj4eAwdOhStWrUSKMLnV1BQgLS0NLn2fz7VTEREf+PtYCIj8N5772HSpEly7cXFxQgODsYHH3ygd2sAKysrcezYMXz66acIDAyEWCyW6ff09ERYWJhA0RER6T7OBGqARCJBYWEhmjVrJnQoOkMsFiMm5jO89dY8wfeqNUYmJibYunUrfH19MX/+fJkt1GpqavDuu+/i5MmT+Oabb+rKrmjad999h6ysLABQaVu6P//8E8OGDZNps7a2hpeXF0aOHIm5c+fC2pobzxMRPQ1nAtXsxIkT8PLqge+//17oUHRKdXU1oqNXoXPn7ti2bYfCsiWkWSKRCHPnzsWRI0fQvHlzuf4TJ07A398fZ86c0Uo8ycnJ+OKLL/DFF1/g8OHDaj13TU2NynsFExEZC84EqsmVK1fw2mtv4fbNUojgKnQ4Oqll8/YI6r8ZMRvW4+OPNiDms9UYMGCA0GEZnSFDhiA1NRUTJkzA6dOnZfpu376NoKAgJCQkYOjQoQJF2DBOTk748MMPceXKFXz11Ve4d+8eHj16hJSUFKSkpGDr1q04d+4cHBwchA5Vp9XU1ODGjRu4f/8+SkpKUFZWBpFIBGtra9jb26N58+Zo27btU2s5knqJxWLcvn0blZWVEIvFqKysRFVVFRo3bgxbW1uYm5ujZcuWer2Gl3QHk8DnVFhYiP/+dxXi9x5Ety6vI2RQGH6/sEbosHRWY+sW6OcfjXsFGZgx7W24tnPAxtj16NChg9ChGRVnZ2ecPHkSr732GmJjY2X6Hj16hHHjxiE9PV1hEWl1mTRpEsLDwwH8tTuJot1GnsXa2hpTpkwBAIwZMwa9evWS6b927RoSEhIU7nhizG7fvo3jx4/jxIkTSElJQW5ursyWeopYWVnB3d0dffr0wZAhQzBkyBAud1GDgoICHD16FMeOHcPFixeRk5ODBw8eNGisjY0N3N3d0aVLFwQFBSE0NJSJ4XO4ffs2MjMzkZOTg9zcXOTl5aGqqgoPHz6s+/2wsbFB48aN4eDggFatWqFbt27w8fFB+/btYWKinzdWmQSqqKqqCps2fYWVK1ajfdtIjAxOhKmJfpXUEFLzZl0RNnQXbuWdxpDBoxAaOhgrV72PJk2aCB2awVm+fDl+/PFHufZDhw5h48aNsLa2ltvbt7CwEBs2bMCqVas0Fpe3tzfGjh0LAM+9TtTf3x8mJiZyD7fUrjk0dhUVFYiPj8fmzZtx8uRJpZdjlJeXIz09Henp6YiNjUWjRo0QFhaGGTNmIDQ0VG8/AIVy5MgRrFy5EqdOnVL5gazS0lKkpaUhLS0N3377LUQiEXr37o2FCxciIiKCM7f1kEqlOHr0KBISEnD06NHneq+wt7fH6NGjMXHiRAwdOrRuO0x9wN9cFSQkJKJTp27Y9mUKwoP2oUfXKCaAKmrTOhCjghNwPdsZXb16YfnylfXOSpByMjIycOzYMbn/ahOBjz76SGEpFUUlV3SVSCRS+KFn7GtPpVIptm/fjk6dOuHFF1/EiRMn1PJvUlVVhf379yM8PBw+Pj44cuSIGqI1fBcuXEBAQABCQkLw448/qvWJfKlUijNnzmDkyJHw9/fH5cuX1XZuQ7N792706NEDwcHBiImJee4vi0VFRdi6dSuCg4Ph5uaGL7/8Um/ee5gEKiE1NRUBvQZg4f99gsG9N6Ov/xJYmNsJHZbeMzExg4f7ixgxLB6HEm/D08MXe/bECR2W0TA1NcXAgQPl2vlghX57+PAhIiIiMHnyZJWevm6ojIwMhISEYObMmfwC9wzx8fEICAjA2bNnNX6t1NRU9O7dG0lJSRq/lj4pKSnB+PHjMWHCBFy4cEEj17h16xZmzJiBoUOHymzNqauYBDbAnTt3MHnSKxj7r1fg2nIOggd+CXs7PvyhbhYW9ujpswD9e36G6P/uQL++Q3D+/Hmhw9J7Ddn5g/vuGpYHDx4gMDBQq1UKNm3ahLCwMFRUVGjtmvri1KlTmDhxolb/bYqKijBmzBgkJydr7Zq6TCwWo1+/ftizZ49Wrnfy5En06dMHd+7c0cr1VMUk8BkePXqED/67Er0DhuDPWx0RMSwezq0ChA7L4DWxd8PgvjFo5fgfjBo5BePH/Rt//vmn0GHprZYtWypsf/JWVElJiVy/Pq1rob9JpVKMHz8eFy9e1Pq1jx07hjlz5mj9urqsoqICU6dOFWSWtKKiAtOmTeOsPoAZM2bgjz/+0Oo1r169ivDwcJ3+YsQkUAGJRILdu/fAy9MXPxy6j1HBB+HV6UWIRPzn0qY2rftiVPABlBf1Q0//QXhr3gKUlpYKHZbeCQoKUth+6NAhAEBubq7CGaO2bdtqNC7SjG+++QbHjx9XepyZmRkCAwMxadIk/Pvf/0afPn1UeuBj06ZN+O2335QeZ6i++eYbXL16VelxVlZWmDJlClauXIkNGzZg6tSpsLS0VPo8mZmZ2L9/v9LjDMmpU6cQHx+v0ti+fftiypQpmD59OgYPHqz078T58+cRHR2t0rW1gfeA/uGvshlvwdy0A4b1/waNrZ2EDsmoiUQm6NAuDK4uQ5CWsg2enn5YtGgeZs58hU8kNtCwYcMwaNAguSeER48eDTs7OxQXF8uNMTExqSu/Qvrlk08+UXpM27Zt8cMPP6Bz584y7RcuXEBwcDDu3r3b4HNJpVJ8+umnCAjgXRMAiItTfn2zq6srTp06JfdF7PXXX8egQYMU/s4+y969exEZGal0HIZi8+bNSo9xcHDAgQMH0L9/f5n28+fPIywsDHl5eQ0+15o1azBnzhw4OjoqHYem8VP0f7KzsxEeHomo/yxBD48VGNRnDRNAHWJmZgUfz1kIHrATX206DR/vAJw6dUrosPSCSCTCvn37EBoaKten6MPE2toasbGxcm9+pPvEYjFSUlKUHhcdHS2XAAKAj48PlixZovT5jh49qvQYQ6XKbfnZs2crnInv0aMHPvjgA63EYEh++eUXpcfMnTtX4Xtg9+7d8e677yp1rtLSUuzevVvpGLTB6GcCxWIx3n9/ZV2x59DB3HBel9k0bsli0ypo0qQJkpKScPr0acTFxeH8+fO4ffs2iouLYWNjAzs7O7i7u2PgwIGYMGECnJye/QVo27ZtePz4sUzb024fN2vWTGFS4O7uXvfn3r17KzzGw8MDAPDee+9h1qxZMn3/vDV25MgRubIM7dq1UxhTmzZtkJCQINfu6+ur8Hh9kZOTo1LZEX9/f5X6nubu3bsoLi6GnZ1xV0+QSCQqrWf29PR8at+UKVMwf/58pdYY6vrDCZoklUpV+vm7d+/+1D4/Pz+lz3fw4EG8+uqrSo/TNKNNAlnsWb/VFpu+dvMYBvQfjhEjg7FiBYtN1ycwMBCBgYHPfZ5hw4Y1+FgLC4unrkus1axZs2ce4+3tXe91lNnmzsbGBhEREQ0+Xl+oumb2Wbt/KNpnuiGKioqMPgksKipCVVWV0uOeVTzd1tYWPXr0UGrdZWFhIWpqaozyYa/CwkKVHsx41naTqmxFqcoMvTYY5e3go0ePoauXP4s9GwC3tkGIDDuMa1dYbJpIlwrU6lIsQtHUv0HHjh2VHmOsr4euPBn94MEDnfxsMqoksLbY89zXP0Q/vxgWezYQtcWmI4btxaHE2/Dy9GOxaSIyWPb29kKHQEqSSqW4f/++0GHIMYokMC8vj8WejYClRRP09FmAfv6f1hWb1lRVeCIioVhYWAgdAqngwYMHQocgx6CTwNpizwG9BiOfxZ6NhoN9+7pi0yMiJmH8uH8jPz9f6LCIiNRCV25xknLUuVe0uhhkEiiVSuuKPScl3sLIFw7Ak8WejU6b1n0xOiThf8WmB+KdxUtQXl4udFhERM9FlYdNiBQxuKzo5MmT6NrVDyuXx2FY/68R0GMhGjVqLHRYJJDaYtOjghPx66lqdO7cHRs3xurkNzIioobgTCCpi8EkgbLFnqP/V+xZtdIGZHj+WWy6u09v/Pzzz0KHRUSkNCaBpC56nwSKxWK8+eYCBA0dBVFlEEIHfw0nRy+hwyIdVVtsulunpZg+dSGGBYUjNzdX6LCIiBpM2STQzMzMKGsEUv30NgmsqqrCZ5/Fwsc7AGkpphgZnIiObtztgxqmebNuCBu6C40b/QsD+g9HVNQcPHz4UOiwiIjqVVhYqNTxTk5OEIlEGoqG9Jle7hhy9OgxvP7aW7C19sbwIXGwsmwqdEikp9zaBsHVZRCuXNmDrl698Oa8VzF37mswM9PLX4062zc9gJ7/CDqppIRrSUlY1dXVSE1NVWpM165dNRQN6Tu9+phITU3Fq1FvorjIAn19Y1jrj9Sitti0W9vh2BcXi42f98Dy6PcwbtxYoUNTWUlxjdAhEJEGxMTEKF3yasSIERqKxjiZmpqqtHWcLt6S14skMC8vD28vXILTP6fCr9vbcO7OWn+kfrXFpsVFYxH939VYv+5zfPb5Wvj4+AgdGhEZufLycqxevRpLly5ValybNm0wbdo0zQRlpNzc3JS+Ja+rdDoJfPToEdas2YDYjVvg6T4NEcPeYa0/0rjaYtO38n7FiIhJ6N3bG+s3fISWLVsKHdoznb+8DFz1oz2PyvOEDoEMVFZWFuzs7FBQUIDr16/jt99+w8GDB1FQUKDUeaysrLBz505YW1trKFLSdzqZBEqlUuzZE4e3Fy5Bq+ZDMPKFA6z1R1rXpnVfuLRKQFbuPvj26Idp017G4ncWwsrKSujQFHogThE6BCJSg6ioqOc+R7t27bBt2zYMGDBADRGRodK5abXk5GT4+fXFh9FxCArciV7dWeyZhCMSmaBzx39hzPAkFpsmIp3n7u6O1atX448//mACSPXSmZnA7OxszHvzbWRduYuePktY6490SiMza/h4zkIH11HYsmkDPov5EjGfrUb//v2FDo2IjFinTp0wcOBA9O3bF/3790eHDh2EDon0iOBJoFgsxvvvr0T83oPw7vI6hg9hrT/SXTaNW6KvfzTuFfyBaVMXoJ1bU8TGbkD79u2FDo1IZR07dnxqHTnOeuu2rKwsZGVlYf/+/QgMDMQLL7yA8ePHq/T0KhkfwW4HyxV7fiGBxZ5JbzRv1g3hQ3ejsdm/0D8wFFFRc1BUVCR0WEQqefjwIcRiscL/+P+1frh//z727duHqKgotG7dGm+++SYL4FO9BEkCjx49hm5d/bFl02kMHxKHHl5RMDU1FyIUoufi1jYIkWGHkX3JER5demDNmnXc15OIBPX48WOsW7cOPXr0QFZWltDhkA7TahKYmpqK3gEDMff1D9HH91ME9ormbh+k90xMzNCtyzSMDD6AfXE58OjSA3v2xAkdFhHpqePHj0MqlaK4uBi3bt3CDz/8gDfeeAOWlpZKnef69esIDQ1FWVmZhiIlfaeVJPDu3buYOHEyxoyehrYtXkfwwC/RxK6dNi5NpDWWFk3g770ArZpF4OWXXsa+ffuEDomI9JitrS1cXFwwbNgwrF27Fj/++CMsLCyUOsfVq1exbt06DUVI+k4rSWCTJk3g4+2F6poyFJXkQCrlllZkeArF2Tjy0xRIzH5D2vlUjB49WuiQiMiABAQEYOrUqUqP++677zQQDRkCrSSBFhYWWPj2/yE9/Td4+oix71A4rt08ro1LE2lc2aN7+OX3RTh38f/w2cZ3cfr0cXh5scQREalfUFCQ0mNycnI0EAkZAq2WiGnatCnWrluFWVHT8Na8xTh0cgt6+ixGs6Ye2gyDSC2qq8txMWsbcm58h0WL5uGVV7YKukG4U9PeADeO05pH5bdRVn5L6DDU4ty5c2jSpInCvjt37rDosA5RZfvK0tJSVFdXw8xM8KpwpGME+T+ic+fOOPj9dzh+/Dhef+0tWJi5o1ePRbC2aiZEOERKkiL3ehLSLq7D2HEjcSDpd9ja2godFLw7vwMmgdpz/c4e5N7cJnQYauHq6gpHR0eFfUJ+sSF5fD2Ed+3aNfj5+Sk97qeffkK3bt00EJHqBP1aMHToUGRcTMX2bTvwzruRcHMZhe5do2BmqtzCVyJtyb+XhpQLy+Hp1QanfzkCV1dXoUMiIiItqqmpgVgsVmmcrhF8btjExARTpk7G2HGRiI7+EFu+CoGP52vo0nEMOKtBuqKk9A7SMlZDIrqFnd+sR+/evYUO6Znsm5iiUSP+/qhb0cMaVFVJhQ6DiEgtBE8CazVu3BjLly9DVNQrWLRoGRKP7oRft0Vo3bKn0KGREauoLEZ65ufIv/8jolcswbhxY4UOqUFenu6Ijp04o65uG9ffx5VLj4UOg4hILQTbNu5pXFxcsH37JuzasxFX76zBkZ+mo6j4ptBhkZGRSKqRmf0NEn4YjdAIF1y8dE5vEkAiIqKG0JmZwH/y9/dHyu+nkZCQiLlzpqG5Y3/4ec+DhbnwC/DJsN3KO43fL6zAoMEB2LH7Fzg5OQkdEhERkdrp3EzgP40YEYGs7AyMf7Er9h8OR/qlryCRcG9WUr/Chzk48tNU5Is34/tD32Lrtk1MAImIyGDpfBIIAI0aNcK8t95AxsXf4e71APGHwlhsmtSm/HEhfktbhnMZ/w8xn7/DYs9ERGQU9CIJrNW0aVNs3LgBx47vQ7XJQRw6+TIKCjOFDov0VHX1Y1y4tBFJJ8dh0rSeuJD+GwYPHiR0WERERFqhs2sCn4XFpun56GaxZyIiTTAzM2ORaVJIL5PAWiw2TcrKv5eGlPRoeHq6sNgzERkFJycniESsG0ry9Op2sCK1xaavXEnHgKE22Pt9CC7n7AXAgq70t5LSOziVPA+Xr0Vjx861SEj8jgkgEWmUriRezZs3FzoE0lF6nwTWqi02fTblRzi1vojEY/9CXn6K0GGRwCoqi5FyYRVOnpmOBYvHIe18Mvr06SN0WERkBOzt7dGoUSOlxxUWFqrU9zTt2rVTeoyhUHWpz6NHj1Tq00QsmmQwSWAtFxcXbN+xCbt2f45reWtx4pfZKC65JXRYpGX/LPZ8KTOVxZ6JSKtMTEzQqlUrpcelpaWp1Pc0AwcOVHqMobC2toaDg4PS465cufLUvsxM5R9IFYlEcHZ2Vnqcpun1msBn8ff3x9mUn/9XbHoqi00bERZ7Vp5EIkFiYiIOHz6M9PR05Ofno6ioCBYWFrCzs0P79u3Rr18/TJw4EW5ubgrPIRaLkZiYiIMHD+LmzZvIy8uDiYkJWrdujXbt2mHkyJEYPnz4U78N37hxA7t27cKvv/6K7OxslJSU4PHjx7Czs0ObNm3g7++PCRMmwN/fX2ZcdnY2bty4IdNmYmKCIUOGyLRlZmbizp07Mm0ODg7w8/NT9p+LqMG8vLxw86Zyu17FxMRg1KhR6NlTdtvUc+fOYd26dUqdy8TEBJGRkUqNMTTt2rWDWCxWaszGjRsxdepU2NnZybRXVFQo/RoAQKtWrWBpaan0OE0z2CSw1ogREQgJCcann3yGjz8Oh0fHyejaZRJMTAz+Rzc6hQ9zkHJhOZo2k+L7Q9+y1l8DXb16FWPGjMGFCxcU9ufl5eHy5ctISkrC0qVLsXTpUixatKiuXyqVYvny5YiOjkZ5ebnc+Bs3buDMmTP49ttvYWdnh+joaMyePVvmmOjoaCxduhRVVVVy4wsKCnD16lX89NNPWL16NV5++WVs3rwZFhZ/PQC2efNmfPjhhzJjLCws8Pjx33v81tTUIDw8HFevXpU5bsWKFUwCSaPGjRuHQ4cOKTWmqKgIffr0wcCBA9G5c2eYmZnh8uXLOH78OCQSidLXb9OmjVJjDM0LL7yg9Azq5cuX0b17d0yfPh2dO3eGqakpsrOzsW3bNly6dEnpGEJCQpQeow1GkQmZm5tj3ltvYPKUf2Px4mWIPxgGf+8FaNdmSP2DSeeVPy7EhUufoECcjPUbPsLw4aFCh6Q3JBIJRo4ciYyMDLm+5s2bo7CwENXVf+/QU1VVhcWLF6NLly4YM2YMAGDx4sVYsWKF3HhTU1NIpVKZD63i4mK89tprqK6uxty5cwEAe/fuxeLFi+XGu7q6ws3NDSkpKSgrK6tr37lzJywsLLB58+YG/5zx8fFyCaC1tTVeeeWVBp+DSBUvvvgiVqxYgaysLKXG1dTU4MSJEzhx4oTK17azs8PKlStVHm8oZs2ahbVr16KyslKpcdeuXcM777zz3NcXiURyX3x1hcGtCXwWR0fHumLTVaLE/xWbvix0WKSiJ4s9T57eE5evXGACqKTk5GSFCeBHH32Eu3fv4ubNm3BxcZHr/+qrrwD8ldStWbNGrn/cuHEoKytDSUkJwsLC5PqXLVtWlxxu3bpVrt/V1RVZWVk4efIkDh48KNe/ZcsWpW6xKYpx0qRJcHR0bPA5iFRhbm6O7du3w8rKSqvXNTU1xdatW1kFAX/dDl6wYIFg1585cyZ8fX0Fu/6zGFUSWKu22HTM5+/hXMb/w4+/zsOj8gKhw6IGkyLn2vfYfyQC3XtW4+LF3zFr1n9YDFUFT0ukBg8eDOCvdSwvvviiXP/169cB/PVNuaKiQq4/PDwcFhYWsLa2Rnh4uFy/WCxGfn4+AMit0wOADh06wNzcHADg6ekp1y+RSHDq1Kmn/FSyfv31VyQnJ8u0iUQizJkzp0HjiZ5XQEAADh06hBYtWvXSKUcAAAn/SURBVGjlehYWFti5cydGjx6tlevpgyVLlmDsWO0/HBgUFKTSGkJtMcoksFZtsem588Lx/YlI/H5hHapr5D/QSHfk30tD4rFxEFkcw+lfjmDNmlU6+di9vnjyVu+Tnqxv1rZtW7n+mpoaAFC4hg+ATEL+tOS8dqyiNU4Nqa929+7deo8BgLVr18q1hYSEwMPDo0HjidRh4MCBOHfuHMLDwzVaP7Bnz544e/YsJkyYoLFr6CNTU1Ps3r0bK1euhImJdlKfmTNnIikpSScfCKllFGsCn6W22PTYcZGIjv4QW7eEwttjNrp0HANANwp90l/FntMyVqMGN7Fj5zrW+tMibb1hKutpCeiTrl+/jv3798u1v/nmm5oISXDOzs6YOXOm0uOe9SFlY2Oj0jltbGyUHmPonJ2dkZiYiAsXLuDjjz9GYmIiioqKnvu85ubmCAkJwdSpUzFy5EidKVKta0QiERYsWICgoCB88MEHOHDgAKRS9W8sMWzYMLzzzjsYMGCA2s+tbkafBNaqLTYdFfUK5r25EAd+2Ime3ovRuqV//YNJY6qqypB+eRNu/3kYK1ctxdixkXyD07LaWb8n6ctrsH79ernZTi8vLwQFBQkUkWZ17twZsbGxaj2no6Oj2s9p7Hx8fLBjxw5UV1cjOTkZx44dw6VLl5CTk4OcnByUlJQ8c7yjoyN8fHzQtWtX+Pr6YsSIESrVwjNWfn5+2LdvHzIzM7F//34cOnQIZ86ceeqdkfqYmJjA398foaGhGDVqFLp3767miDWHSeA/uLi4YE/cTqSkpGD2q/NwOdcB/t4LYWdr3I/Ya5tEUo3LOXtwMetLRL06DfPnp9aVBCHtysvLk2vThx0IiouLsWXLFrn2N954Q2+SWDJsZmZmCAwMRGBgoEx7UVERKioqUFpairKyMkgkEtja2qJJkyawsbGpWy9Lz8fDwwMeHh54++23UVpaiqysLGRnZyM7Oxt37typew1KSkoglUphZ2cHa2trWFpaolWrVnB3d4e7uzs6deoEe3t7oX8clTAJfIqePXvKFZv2934L5ua8xaFpssWeT3PfS4HU1NTg8OHD2Lhxo1yfooc9NMXR0RG5ubly7U2bNn3muC+++ELuVpuTkxNeeukltcZHpG61CQXf+7THxsYGvr6+OvsUr6YwCayHbLHpMHh0nIxuHpMhEvFJVHUrfJiD39Oj4eAoYbFngYWGhtbNRjzJwcEBb7/9NqKiorQWi6mpKdq3b6/UGIlEgk8++USufebMmVov1UFEpKuYBDbAP4tN7z04nMWm1YjFnnXPvXv3ZP5ubm6O0NBQTJ8+HWFhYfXeTt21axfS09MB4Kk7kWhSVVWVwvI3ip50JiIyVrr52J+OYrFp9aqRVCHjypa/ij1PY7FnXTJgwAAMGjSorvxOZWUlDhw4gBEjRqBHjx71lmdJTEzEqlWrsGrVKhw+fFgbIcuwsLBA586d5dp37Nih9ViIiHQVk0AV1Bab/vSzd5F6aQFOpyxisWml/FXsed+hMHTzLUNGRgpmRbHYsy5Zu3YtTp48iUuXLsntqpGeni5o9f2GUlQn7fTp00pv30VEZKh4O/g5BAUF4Y8/fsf2bTvwzruRcHMZhe5dtbdWSh/l3zuPlPTl8PR0wc+nD+nFU6bGzMXFBQEBAUhKSpJpP3fu3DPHTZgwoa5MwtmzZxEfH69yDOXl5Qpn8Hr16vXMUgwvv/wyli1bJtf+9ddfK2wnIjI2TAKfU22x6TH/Go3334/Gnt3hMBU5AtCfOkHacuvOJTg1/wi798TAz89P6HCogaytreXa6qunFRERUbfd3KZNm54rCSwpKcF//vMfufYVK1Y8Mwns2LEj/Pz85BLWbdu2YcmSJTpbBJuISFv4LqgmdnZ2+Pjjlfj59BH08GvDOmT/YGlpid27d+G3s6eYAJLWTJw4Ua7txo0b+PnnnwWIhohItzAJVDNXV1fE79ul8MPHmNna2mLMmDFCh0FGZuLEiQrXmm7btk2AaIiIdAuTQA1p1KiR0CEQaYy+zHS3bt1a4f6dcXFxKC0tFSAiIiLdwSSQyIg9bV3ck5uqK9pg/Z9PDKs7BolEovDPT2ro0+SKZuVLS0tx4MCBBkZIRGSYmAQSGbEWLVoobD9//jyAv+oDZmRkyPX36tVLbTG4uLjItf3xxx/Iz88HAPzwww8Kx7Vp07D9vCMjIxXuO81bwkRk7JgEEhmx/v37w9nZWa595syZ8PX1hZubG65cuSLTZ2lpiVdffVVtMSjay7egoACurq5o2bIlJk+eLNfv6OiI0NCGFRZ3cHBASEiIXPvx48dx69Yt5QMmIjIQTAKJjJi5uTni4+PRqlUrmXaJRIK0tDTk5eXJtNvb2yMuLg4dOnRQWwzjx4/HwoUL5dYZVlZWKtyZxNHREfHx8bC3t2/wNRTdEpZIJPj666+VD5iIyECwTiCRkevVqxeuXLmC7du3IykpCRcvXsStW7fq1uI5OjqiS5cuCA0NxYwZM2RuIbu6uiI2NlbhOWv1799f4TFPritcsWIFJk6ciK1bt+LUqVPIzs5GcXFxXb+zszO8vLwQHByMadOmoUmTJnV9Y8aMkUtK/7leMCIiQmEMimZBiYiMBZNAIoKtrS1mz56N2bNn17VVV1fDzOzZbxFOTk6YOXPmM4/p0qULunTpUm8M3t7eWLNmjUxbVVVVvU/aBwQEICAg4JnHWFtb1xun0P44Xw5xYY3QYeik67kVWr3erRuViPtarNVr6os/71Rp9XolJRK+Fk9RXPT87xdMAolIofoSQG0wplJLN69X4ub1SqHDIAAPCqrx6ymWENIFj8slfC00iGsCiYiIiIyQ8F/1iYiMkFQqRemj60KHoXcqKgs0ct7yx3c0cl5DJ31KHc/nUVF5n78bKqiRPFZ6DJNAIiJBSPHbhdn1H0ZakX4lWugQ6H9yb25H7s3tQodhFNSWBB6Ie4gjB4vrP5AaTNFODUI4GF+E44dLhA6DiIiI1EhtSWDB/Wp1nYp0zIMCvrZERESGhg+GEBERERkhlWcCK6uKIC5OV2csVI+ycu0sXK6qLuZrq2Vlj7h9GRERaZfKSWBRSSZSL76tzlhIRxSXZvG1JSIiMnB8OpjIAMXvEsPKiqs91O3PPO3ulkBEpElMAokMkLa3diIiIv3DqQIiIiIiI8SZQCIDceXaZ9CR0pJGoaQsR+gQiIieC5NAIgNxOz9J6BCIiEiP8HYwERERkRFiEkhERERkhJgEEhERERkhJoFERERERohJIBEREZERYhJIREREZISYBBIREREZISaBREREREaISSARERGREZLZMcTWxhnVVeVCxUJEREREGmBn4yzXJpME9vGbp7VgiIiIiEg4vB1MREREZITMTE1EUqGDICIiIiLtcXRsKfn/MRZdjungEKgAAAAASUVORK5CYII=");}'+
						'  div#hidden {position:absolute;width:0px;height:0px;top:0px;left:0px; z-index:-9;background: white; }'+
						'  div#directionalsController {position:relative;z-index:9999999999999999999999; background: no-repeat url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAn8AAAC/CAYAAACPObpmAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAADhGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmNlNzRkNDI3LTVmYWMtZTY0Ny05ZWYwLWRmMjU4OWU1NWE3YyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFMTg3QTM3MTE0MzIxMUU3QTVGMjhGMTExRjJGNUJCMCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFMTg3QTM3MDE0MzIxMUU3QTVGMjhGMTExRjJGNUJCMCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDplMjJlZjk4Zi1kYzA1LTFkNDUtOTY3NS1mYzQ0MGIxOTNlZGEiIHN0UmVmOmRvY3VtZW50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");}'+
						'  div#standardController {position:relative;z-index:9999999999999999999999; background: no-repeat url("data:image/png;base64,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");}' +
						' ' + customStyleName ? ('div#'+customStyleName+' {position:relative;z-index:99999999999999999999999999999999; background: no-repeat url("'+customStyleData+'");};') : '';
			
			
			var head = window.document.head || window.document.getElementsByTagName("head")[0];
			var style = window.document.createElement("style");
			head.appendChild(style); style.type= 'text/css';
			if (style.styleSheet){ style.styleSheet.cssText = controllerCss; } else {
			  style.appendChild(window.document.createTextNode(controllerCss));
			}
			
		};
		  //ControllerPad._selfStyle();
	tabageos.ControllerPad = ControllerPad;

})();
(function() { 
	'use strict';
    /**
    *
    *@class Event
    *
	*@classdesc
	*    A basic Event Class.
	*    
	* 
	* @param [type="event"] {String} The type of Event 
	* @param [potato]  {Object} An optional variable
	*  
	*/
    function Event(type, potato) {
        this.type = type || "event";
        this.potato = potato || {};
		this.target = null;
    };
	/** 
	*   
	*    The type of Event.
	*    
	* @memberof Event 
	*  
	*/
    Event.prototype.type = "";
    /** 
	*   
	*    An optional available variable.
	*    
	* @memberof Event 
	*  
	*/
    Event.prototype.potato = null;
    /** 
	*   
	*    The target of the Event.
	*    
	* @memberof Event 
	*  
	*/
    Event.prototype.target = null;
	/** 
	*   
	*    
	*    
	* @memberof Event 
	*  
	*/
    Event.prototype.constructor = Event;
	/** 
	*   
	*    Does not do anything, for override and available if needed.
	*    
	* @memberof Event.prototype 
	* @method preventDefault
    * 
	*/
    Event.prototype.preventDefault = function() {
		
	};
    tabageos.Event = Event;
})();


(function() { 
	'use strict';
    /** 
    *
    *@class EventDispatcher
	*  @classdesc
	*    A basic EventDispatcher Class.
	*    
	*  
	*  
	*/
    function EventDispatcher() {
        this._listeners = {};
    };
	/** 
	*   
	*    
	*    
	* @memberof EventDispatcher 
	*  
	*/
    EventDispatcher.prototype.constructor = EventDispatcher;
	/** 
	*   
	*    
	*    
	* @memberof EventDispatcher 
	*  
	*/
    EventDispatcher.prototype._listeners = {};
    /** 
	*   
	*    Adds a listener method to be dispatched.
	*    
	* @memberof EventDispatcher.prototype 
	* @method addEventListener
	* @param type {String} The type of Event to listen for.
	* @param listenerMethod {String} The function to call when the Event fires.
	* @param listenerObject {Object} The object that contains the function to call.
    * 
	*/
    EventDispatcher.prototype.addEventListener = function(type, listenerMethod, listenerObject) {
        if (this._listeners[type]) {
            this._listeners[type].push({
                m: listenerMethod,
                o: listenerObject
            });
        } else {
            this._listeners[type] = [{
                m: listenerMethod,
                o: listenerObject
            }];
        }
    };
    /** 
	*   
	*    Removes a listener 
	*    
	* @memberof EventDispatcher.prototype 
	* @method removeEventListener
	* @param type {String} The type of Event 
	* @param listenerMethod {String} The method to remove
	* @param listenerObject {Object} The Object that contains the method.
    * @returns {Boolean} Returns true if a listener was removed. 
	*/
    EventDispatcher.prototype.removeEventListener = function(type, listenerMethod, listenerObject) {
        var i;
        var a;
        var result;
        if (this._listeners[type]) {
            i = 0;
            a = this._listeners[type];
            result = false;
            
            for (i = 0; i < a.length; i++) {
                if (a[i].m == listenerMethod && a[i].o == listenerObject) {
                    a.splice(i, 1);
                    result = true;
                }
            }
        }
        return result;
    };
    /** 
	*   
	*    Fires the given Event.
	*    
	* @memberof EventDispatcher.prototype 
	* @method dispatchEvent
	* @param event {Event} The Event to fire. 
	* @param [applyTarget=false] {Boolean} Set this instance as the Events target. Default is false.
    * 
	*/
    EventDispatcher.prototype.dispatchEvent = function(event, applyTarget) {
        var a;
        var l;
        var caller;
        if (this._listeners[event.type]) {
            if(applyTarget) event.target = this;
            a = this._listeners[event.type];
            l = a.length;
            while (l--) {
                caller = a[l];
                if (caller.o && caller.o[caller.m]) {
					if(applyTarget && applyTarget == 2) event.target = caller.o;
                   try { caller.o[caller.m](event); } catch(e) { }
                } 
            }
        }
    };

    tabageos.EventDispatcher = EventDispatcher;
})();

(function() { 

	'use strict';
    
    /** 
    *
    *@class ExplosionFactory
    *
    *  @classdesc
	*   Controlls the display of explosions (quick animations) onto a given CanvasObject.
	*    
	*    
	* 
	* @param eWidth {Number} The default explosion width.
	* @param eHeight {Number} The defauly explosion height.
	* @param countStop {Number} The default explosion frame amount.
	* @param spriteSheetX {Number} The default x position in the sprite sheet to draw from.
	* @param spriteSheetY  {Number} The default y position in the sprit sheet to draw from.
	* @param [poolAmount=51] {Number} The amount of explosions to pool. Default is 51.
	*  
	*/
    function ExplosionFactory(eWidth, eHeight, countStop, spriteSheetX, spriteSheetY, poolAmount) {
        this.explosionRect = new tabageos.Rectangle(0,0,eWidth,eHeight);
        this.explosionPoint = new tabageos.MoverPoint();
        this.explosions = [];
        this.explosionHold = [];
        this.eWidth = eWidth;
        this.eHeight = eHeight;
        this.sFromX = spriteSheetX || 96;
        this.sFromY = spriteSheetY || 0;
        this.countStop = countStop;
        this.readyExplosions(poolAmount || 51);
    };
	/** 
	*   
	*    
	*    
	* @memberof ExplosionFactory 
	*  
	*/
    ExplosionFactory.prototype.constructor = ExplosionFactory;
    /** 
	*   
	*    @private
	*    
	* @memberof ExplosionFactory 
	*  
	*/
    ExplosionFactory.prototype.eWidth;
    /** 
	*   
	*    @private
	*    
	* @memberof ExplosionFactory 
	*  
	*/
    ExplosionFactory.prototype.eHeight;
    /** 
	*   
	*    @private
	*    
	* @memberof ExplosionFactory 
	*  
	*/
    ExplosionFactory.prototype.countStop = 6;
    /** 
	*   
	*    @private
	*    
	* @memberof ExplosionFactory 
	*  
	*/
    ExplosionFactory.prototype.explosions = [];
    /** 
	*   
	*    @private
	*    
	* @memberof ExplosionFactory 
	*  
	*/
    ExplosionFactory.prototype.explosionRect;
    /** 
	*   
	*    @private
	*    
	* @memberof ExplosionFactory 
	*  
	*/
    ExplosionFactory.prototype.explosionPoint;
    /** 
	*   
	*   @private SpirteSheet from x 
	*    
	* @memberof ExplosionFactory 
	*  
	*/
    ExplosionFactory.prototype.sFromX = 96;
    /** 
	*   
	*   @private  
	*    
	* @memberof ExplosionFactory 
	*  
	*/
    ExplosionFactory.prototype.sFromY = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof ExplosionFactory 
	*  
	*/
    ExplosionFactory.prototype.explosionHold = [];
    /** 
	*   
	*    @private
	*    
	* @memberof ExplosionFactory.prototype 
	* @method readyExplosions
	* @param amount 
    * 
	*/
    ExplosionFactory.prototype.readyExplosions = function(amount) {
        while (amount > 0) {
            amount -= 1;
            this.explosionHold.push({
                x: 0,
                y: 0,
                count: 1,
                fromX: 0,
				fromY: 0,
				width: 0,
				height: 0,
				throttle: 1
            });
        }
    };

    
    /** 
	*   Add an explosion to be displayed.
	*    ex and ey must be defined, the other values will default to what was set during construction.
	*    
    *   call displayExplosions to display each added explosion.
    *
	* @memberof ExplosionFactory.prototype 
	* @method addExplosion
	* @param ex {Number} The x location to display the explosion
	* @param ey {Number} The y location to display the explosion.
	* @param ecount {Number} the frame to start from, when it reaches countStop (defined during construction) the animation stops. Default is 1.
	* @param fromX {Number} the x location to draw from the sprite sheet, will default to what was defined during construction.
	* @param fromY {Number} the y location to draw from the sprite sheet, will default to what was defined during construction.
	* @param width {Number} the width of the animation
	* @param height {Number} the height of the animation.
	* @param throttle {Number} Speed of the animation, default is 1.
    * 
	*/
    ExplosionFactory.prototype.addExplosion = function(ex, ey, ecount, fromX, fromY, width, height, throttle) {
        this.explosions[this.explosions.length] = this.explosionHold.pop();
        this.explosions[this.explosions.length - 1].x = ex;
        this.explosions[this.explosions.length - 1].y = ey;
        this.explosions[this.explosions.length - 1].count = ecount || 1;
        this.explosions[this.explosions.length - 1].fromX = fromX || 0;
        this.explosions[this.explosions.length - 1].fromY = fromY || 0;
		this.explosions[this.explosions.length - 1].width = width || 0;
        this.explosions[this.explosions.length - 1].height = height || 0;
		this.explosions[this.explosions.length - 1].throttle = throttle || 1;
    };
    
    /** 
	*   
	*    Displays the addeded explosions onto the CanvasObject given, using the image source given.
	*   This method should be called during a loop. 
	*	
	* @memberof ExplosionFactory.prototype 
	* @method displayExplosions
	* @param canvasObject {CanvasObject} The CanvasObject to draw to.
	* @param source {Image} The sprite sheet to draw from, an image.
    * 
	*/
    ExplosionFactory.prototype.displayExplosions = function(canvasObject, source) {
        var i = 0;
        var l = this.explosions.length;
        var eo;
        for (i; i < l; i++) {
            eo = this.explosions[i];
            if (eo) {
                this.explosionRect.x = (eo.fromX || this.sFromX) + (Math.round(eo.count) * (eo.width || this.eWidth) );
                this.explosionRect.y = eo.fromY || this.sFromY;
				this.explosionRect.width = eo.width || this.eWidth;
				this.explosionRect.height = eo.height || this.eHeight;
                this.explosionPoint.x = eo.x;
                this.explosionPoint.y = eo.y;
                canvasObject.copyPixels(source, this.explosionRect, this.explosionPoint, this.explosionRect.width, this.explosionRect.height);
                eo.count += eo.throttle || 1;
                if (eo.count >= this.countStop) {
					tabageos.GeometricMath.splice(this.explosions, this.explosions.indexOf(eo));
					this.explosionHold[this.explosionHold.length] = eo;
                    continue;
                }
            }
        }
    };
    tabageos.ExplosionFactory = ExplosionFactory;
})();

(function() { 
	'use strict';
	
	/** 
	*   
	*    Constructs a new GameSkeleton instance, this constructor should generally not be used.
	*		To use the GameSkeleton class you should extend it. Create a class that will extend GameSkeleton and within that class constructior call  GameSkeleton.call(this, specs);
	*
	*		function MyGame() {
	*			var specs = { ... };//see below for details of the specs Object.
	*			tabageos.GameSkeleton.call(this, specs);
	*		}
	* 		MyGame.prototype = Object.create(tabageos.GameSkeleton.prototype);
	*		MyGame.prototype.setupSpecifics = function() {
	*			//your game setup specifics, all properties of GameSkeleton available via 'this'
	*			//skin related stuffs would happen here, title styling, level setup, etc...
	*		};
	*		MyGame.prototype.loop = function(ts) {
	*			//your specific game mechanics, all properties of GameSkeleton available via 'this'
	*			//the meat of the game goes here, stuff that should happen every frame.
	*		};
	*	 	new MyGame();
    *
    *       OR
    *
    *       class MyGame extends tabageos.GameSkeleton {
    *           constructor() {
    *                super();
    *                var gameSpecs = {...};
    *                this.initialConstruction(gameSpecs);
    *           }
    *           setupSpecifics = function() {
    *
    *           }
    *           loop = function(ts) {
    *            
    *           }
    *
    *       }
    *       new MyGame();
	*
	*
	* @class GameSkeleton
	* @classdesc Game framework Class. Organizes the use of the various tabageos Classes for the creation of a game with title screen, main camera and game over screen.
    *                               Has just about everything needed for the framing of any game.
	*    The way it should be used is to extend it via the Object.create method, then in the constructor function you call; GameSkeleton.call(this,specs);
	*    When set up, all the properties and methods of this class would be available to your extending class via "this".
	* @constructor
	*
	*		
	*
	*
	*
	* @param specs {Object} An Object defining the specifics of the game.
	*		
	*      The default value is:
	*		{ gWidth:640, gHeight:320,cameraWidth:320, cameraHeight:320, 
	*		cameraFollowOffsetX:-160, cameraFollowOffsetY:0,  tileW:16, tileH:16, 
	*		spriteSheetImage: null, containerDivId:"container", rootDivId:"root",
	*		controllerDivId:"controller", gameScale:2, useScreenOrganizer:true,startWidth:50, startHeight:25,
	*		controllerHeight:144, initialLives:3, initPlayerPosition:new tabageos.MoverPoint(32,32), 
	*		gameLoop:null,initializationSpecifics:null, 
	*		addedResizeMethod:null, sceneResetSpecifics:null,fullResetSpecifics:null, additionalSceneResetSpecifics:null, 
	*		positionResetSpecifics:null, cameraType:2, backgroundColor:"#FFFFFF" }  
	*         	
	*			
	*			@param specs.gWidth {Number} The total width of the game play area. 
	*					If set to more than 4000 it is assumed that setupForRenderFromMap is going to be used. This number should be less than 4000 unless your making an endless runner style game and therefore using the setupForRenderFromMap method on layer 2, the display layer.
	*					To accomplish an endless not auto moving scene, you can use just 1 scene, when the player goes out of camera view left or right it would loop back,
	*					or you can make many different scenes being sure to add each one to the sceneChanger using sceneChanger.addScene.
	*			@param specs.gHeight {Number} The total height of the game play area. This number should be less than 4000.
	*			@param specs.camearWidth {Number} The cameras width, if gWidth is bigger than this, the camera only shows what is within its viewport, and would need to move to show more. 
	*			@param specs.cameraHeight {Number} The cameras height, if gHeight is bigger, the camera only shows what is within its viewport, and would need to move to show more.
	*			@param specs.cameraType {Number} defines if the camera should automatically move. 
	*				Setting camearType to 1 would make it follow the player around, by default the camera does not move, cameraType is 2 by default for the justRender method of the camera.
	* 				To move it yourself in your loop method, you would set cameraType to 0, and in your loop method reference the camera as 'this.camera'.
	* 				See BasicCamera for the various camera movement methods available, by default when cameraType is 1, this class will use the tweenedBlitLayerRender method of the camera.
	*			@param specs.cameraFollowOffsetX {Number} defines the horizontal camera offset when following the player, the default is negative half the camera width.
	*			@param specs.cameraFollowOffsetY {Number} defines the vertical camera offset when following the player, the default is 0, by default the camera only moves horizontally.
	*						When cameraHeight and gHeight are the same, the camera does not need to move vertically. Same is true for horizontal gWidth and cameraWidth. 
	*			@param specs.backgroundColor {String} An html color value string that will be the background color of backgroundLayer. You can also draw to backgroudLayer to change the background. 			
	*			@param specs.tileW {Number} defines the width of each tile in your sprite sheet. Default is 16.
	*			@param specs.tileH {Number} defines the height of each tile in your sprite sheet. Default is 16.
	*			@param specs.controllerHeight {Number} defines the height of the controller, the width will be the same as the cameraWidth.			
	*			@param specs.initialLives {Number} The initial amount of lives the player has, default is 3.
	*			@param specs.initPlayerPosition {MoverPoint} A MoverPoint defining the initial player position on screen. 		
	*			@param specs.spriteSheetImage {String} The name of your image, use the full path if it is not in the same folder as the games code. If this is null it is assumed to just draw squares.
	*			                                       To streamline the loading of your sprite sheet this value needs to be set to 'streamline' and then you would use tabageos.loadSpriteSheetAndStart.
    *           @param specs.containerDivId {String} The id of the html div that is the container of both root and controller.
	*			@param specs.rootDivId {String} The id of the html div that is the games root, it should be inside of the container div and have nothing inside of it.
	*			@param specs.controllerDivId {String} The id of the html div that will be the controller, it should be inside of container and underneath, not in, root. If this value is not set a controller is not created.
	*			
	*			
	*	<div id="container" style="position:absolute;width:640px;">
	*	  <div id="root" style="position:relative;width:640px;height:272px;"></div>
	*	  <div id="controller" > </div>
	*	</div>
	*			
	*			@param specs.gameScale {Number} The scale of the game, 0 for no scale, 1 for full screen, greater than 1 for less than full screen, 2 is half size. 3 is smaller
	*			@param specs.useScreenOrganizer {Boolean} Default is true, whether to use a ScreenOrganizer or not, if false no title screen or game over screen is set up.
	*			@param specs.startWidth {Number} The width of the start button on the title screen. You can reference the start button itself with "this.startButton"
	*											the start button is an html div element.
	*			@param specs.startHeight {Number} The height of the start button on the title screen.
	* 			@param specs.startLocations {MoverPoint} A MoverPoint defining the left and top position of the start button. The start button is a div referenced with this.startButton
	*			@param specs.gameLoop {Function} your loop method that defines the specific mechanics of the game. 
	* 			@param specs.initializationSpecifics {Function} a method that does additional setup related things. Typically you would setup the player and levels in this method.
	*			@param specs.addedResizeMethod {Function}  a method that does additional resizie related things, it would happen after the default resizing happens.
	*														By default the game will fill the screen if gameScale is 1, it will not scale if gameScale is 0, and it will be smaller from values greater than 1.
	*														when the game is smaller than the page it will be in the middle.
	*														addedResizeMethod is sometimes needed in cases where you have other stuff on the page besides the game.
	* 			@param specs.sceneResetSpecifics {Function} A method that would happen just before the scene is reset.
	*														By default nothing happens on reset just the ScreenOrganizer will show the transition.
	*														To have something happen create a method that does things (this method happens before the transition starts)
	*														and pass it as this param or as specs.additionalSceneResetSpecifics. As with all these methods, the 'this' inside of them would be able to reference all GameSkeleton properties.
	*
	*	
	*			@param specs.fullResetSpecifics {Function} A method that would happen as the game is reseting to the title screen. Typically you would use this to clear out Objects you have created and to stop event listeners you have made.
	*														If you have not added any objects other than defining the player, you would not have to worry about this method.
	*														if you have for example many enemies made, this method would be used to destroy them before the game resets.
	*	
	*			@param specs.additionalSceneResetSpecifics {Function} A method that is similar to sceneResetSpecifics but would happen when the transition covers the screen.
	*															sceneResetSpecifics would happen before the transition, and additionalSceneResetSpecifics would happen when the screen is covered.
	*
	*
	*			@param specs.topDownSceneChange {Number} If set to 1 then up and down scene changes will happen automatically as well. By default, when there is a sceneChanger being used, only left and right scene changes happen.		
	*			@param specs.underCoverSpecifics {Function} A method that would happen after the levelComplete method is used and the screen is covered. See levelComplete.
	*			@param specs.useSceneChanger {Boolean} Default is true, by default a TileSceneChanger is being used referenced with this.sceneChanger. If you have more than one scene, or you want your character to be able to loop your one scene, scenes need to be added to the sceneChanger using this.sceneChanger.addScene.
	*
	*			@param specs.initForISO {Number} This needs to be set as 1 if your making an isometric scene using the iso classes.
	*			@param specs.disableBackgroundAlpha {Number} Disable the backgroundLayer alpha, default is 1, it is disabled by default, by default the background has no alpha, if your doing parallax, or need background alpha you want to set this to 0.
	*			@param specs.positionResetSpecifics {Function} A method that would change the position of the player during reset. By default the position of the player does not change on reset.
	*
	*			@param specs.beforeStartGameLoop {Function} An optional method to call that would happen just before the game loop is started
	*			
	*			@param specs.tweenLimitX {Number} Optional defining of the cameras horizontal tween limit, default is 0.
	*			@param specs.tweenLimitY {Number} Optional defining of the camera vertical tween limit, default is 0.
	*
	*			@param specs.cameraTweenType {String} Optional defining of the camera tween type default is 'InOutLinear'.
	*			@param specs.enableGamePad {Boolean} Default is false, when true and the user has a usb game pad plugged in, when they press any directional button on their pad for the first time they will then be promted to assign each non-directional button. And then they'll be playing with their controller.
	*													When usb game pad use is needed, instruct the user to press one of the directionals (not other buttons) and then to follow the on screen propmpts.
	*													The GameSkeleton is using enableGamePad to control a call to ControllerPad.gamePadButtonsUserDefined and ControllerPad.handleGamePad. For more info about how usb game pad input works see ControllerPad.js
	*													You can ignore this property and use the ControllerPad Class for yourself if for example you want to use predefined button configurations that you know all your users will have.
	*			@param specs.frameRate {Number} Optional frameRate definition, default is 60.
	*			@param specs.hudScale {Number} Default is same as gameScale, can be used to scale the hud differently
	*			@param specs.walkthroughLink {String} Link for the question mark hud button. Default is an empty string. It would open in a new page. when this is not defined nothing happens when the question mark is selected.
	*           @param specs.sceneChangeSpecifics {Function} An optional method that would happen as part of a BlitMath.dispatchFunctionAssignments call, it would be the method to act on each value in the map used in the sceneChagner.
    *                                                           This method would receive a PatternActionEvent that would have tileValue, and x and y location in the map. The sceneChanger automatically changes scene maps in a default GameSkeleton setup. 
    *                                                           You add maps to the sceneChanger, define BlitMath.functionAssignments Array of tile values, and decalre what this function is ready to receive PatternActionEvents. This is normally the main setup method of each levels specifics.
	*			@param specs.priorToSceneChange {Function} An optional method that would happen before a scene change. [not reset]
	*			@param specs.afterSceneChange {Function} An optional method that would happen after a scene change. A scene reset is reseting the current scene, a scene change is changing to a different scene either by walking off screen or using the moveBackOneScene/FowardOneScene/gotoSceneByDoor/transitionToSceneByDoor methods.
	*			@param specs.specialControllerUse {Boolean} If true then the controller is not automatically resized, and no buttons are set up. Default is false.
	*														By default ControllerPad.basicControllerButtonSetup is used and ControllerPad.assignStartAndBackMethods is used to assign this.maybeStartGame and this.maybeGoBack to the start and back controller buttons.
    *           @param specs.onSelectLevel {Function} An optional method that would happen when a level is selected from the built in level select screen.
    *
	*/
    function GameSkeleton(specs) {
		if(specs) {
			this.initialConstruction(specs);
		}
		tabageos.EventDispatcher.call(this);

	};
    GameSkeleton.prototype = Object.create(tabageos.EventDispatcher.prototype);
    
    
    /**
    *
    * 
    *  The actual class construction method, for use after a super call, it is used during construction or a super call if specs are passed.
    *  To extend the GameSkeleton with es6 class syntax and the use of 'this' in the specs Object, first call super without a param, then this method with a specs Object.
    *
    * @memberof GameSkeleton.prototype
    * @method initialConstruction
    *
    * @param specs {Object}
    */
    GameSkeleton.prototype.initialConstruction = function(specs) {
		
		
		if(GameSkeleton.game) {
			throw "An instance of GameSkeleton has been created already.";
		}
		
		this.gameWidth = specs.gWidth || 640; this.gameHeight = specs.gHeight || 320;
		this.tileWidth = specs.tileW || 16; this.tileHeight = specs.tileH || 16;
		this.lives = specs.initialLives || 3;
		this.controllerHeight = specs.controllerHeight || 144;
		this.initialPlayerPosition = specs.initPlayerPosition || new tabageos.MoverPoint(32,32);
		this.cameraWidth = specs.cameraWidth || (this.gameWidth/2); this.cameraHeight = specs.cameraHeight || (this.gameHeight+1-1);
        
        if(!specs.cameraFollowOffsetX && specs.cameraFollowOffsetX != 0) {
           this.cameraFollowOffsetX = -(this.cameraWidth/2);
        } else {
            this.cameraFollowOffsetX = specs.cameraFollowOffsetX;
        }
       
		this.cameraFollowOffsetY = specs.cameraFollowOffsetY || 0;
		this._initLives = specs.initialLives || 3;
		this._scaleRectRef = new tabageos.Rectangle();
		this.gameFunction = specs.gameLoop;
		this.addedInitializationMethod = specs.initializationSpecifics;
		this.addedResizeMethod = specs.addedResizeMethod;
		this.sceneResetSpecifics = specs.sceneResetSpecifics;
		this.sceneChangeSpecifics = specs.sceneChangeSpecifics;
		this.fullResetSpecifics = specs.fullResetSpecifics;
		this.additionalSceneResetSpecifics = specs.additionalSceneResetSpecifics;
		this.positionResetSpecifics = specs.positionResetSpecifics;
        this._cameraType = specs.cameraType || 0; 
		this.backgroundColor = specs.backgroundColor || "#FFFFFF";
        
		this.disableBackgroundAlpha = (specs.disableBackgroundAlpha === 0 ? 0 : (specs.disableBackgroundAlpha || 1));
		
		this.initForISO = specs.initForISO || 0;
		
		this.beforeStartGameLoop = specs.beforeStartGameLoop || null;
		
		this.useSceneChanger = specs.useSceneChanger === 0 ? 0 : 1;
		
		this.tweenLimitX = specs.tweenLimitX || 0;
		this.tweenLimitY = specs.tweenLimitY || 0;
		
		this.cameraTweenType = specs.cameraTweenType || "InOutLinear";
		this.frameRate = specs.frameRate || 60;
		
		this._helperPoint = new tabageos.MoverPoint();
		this._helperRect = new tabageos.Rectangle(0,0,this.tileWidth, this.tileHeight);
		this.gameScale = specs.gameScale || 1.01;
		this.hudScale = specs.hudScale || this.gameScale;
		this.walkthroughLink = specs.walkthroughLink || "";
		
		this.topDownSceneChange = specs.topDownSceneChange || 0;
		
		this.startLocations = specs.startLocations || null;
		
		this.enableGamePad = specs.enableGamePad || 0;
		this.underCoverSpecifics = specs.underCoverSpecifics || null;
		
		this.priorToSceneChange = specs.priorToSceneChange || null;
		
		this.afterSceneChange = specs.afterSceneChange || null;
		this.autoPause = (specs.autoPause && specs.autoPause === 0 ? 0 : 1);

		this._manuelControllerUse = specs.specialControllerUse || 0;
        GameSkeleton.game = this;
		this.__specs = specs;
        if(!specs.controllerDivId) {
            window.console.log("GameSkeleton: no controller div id given, a ControllerPad will not be created");
        }
        GameSkeleton.establish(this, specs.spriteSheetImage || null, specs.containerDivId || "container", specs.rootDivId || "root", specs.controllerDivId , specs.gameScale === 0 ? 0 : (specs.gameScale||2), specs.useScreenOrganizer === false ? false : true, specs.startWidth || 50, specs.startHeight || 25);

		
	};
    

	GameSkeleton.STANDARD_CAMERA = 1;
	GameSkeleton.STILL_CAMERA = 2;
	/** 
	*   
	*    The left and top location, as x and y, for the start button on the html page.
	* @type MoverPoint
	* @memberof GameSkeleton 
	*  
	*/
	GameSkeleton.prototype.startLocations = null;
    /** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype._cameraType = 0;
    /** 
	*   
    *   If 1 or true then game pad is reeady for use.
    *   When true, then when a player presses one of the directional buttons of their game pad, it would prompt for them to define all buttons.
	*    @type Number
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.enableGamePad = 0;
	/** 
	*   
	*    The default color for the backgroundLayer, default is "#ffffff".
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.backgroundColor = "#FFFFFF";
	/** 
	*   
	*    Disable alpha for the backgroundLayer default is true.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.disableBackgroundAlpha = 1;
	/** 
	*   Use a TileSceneChanger, default is true.
	*    
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.useSceneChanger = 1;
    
	/** 
	*   
	*    If 1 then the device being used is a touch device.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.device = 0;
	/** 
	*   
	*    Denotes if the game is paused. Use the pause method to pause and unpause the game.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.paused = 0;
	/** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton.prototype  
	*  
	*/
    GameSkeleton.prototype._thrott = 0;
	/** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton.prototype  
	*  
	*/
    GameSkeleton.prototype._aid;
	/** 
	*   @private
	*    
	*    
	* @memberof GameSkeleton.prototype  
	*  
	*/
    GameSkeleton.prototype._pr;
	/** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton.prototype  
	*  
	*/
    GameSkeleton.prototype._ts = 0;
	/** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton.prototype  
	*  
	*/
    GameSkeleton.prototype._textTime = 4000;
	/** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton.prototype  
	*  
	*/
    GameSkeleton.prototype._doReset = 0;
	/** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton  
	*  
	*/
    GameSkeleton.prototype._doAlternate = 0;
    /**
    *
    * The instance of the constructed GameSkeleton, this is set during construction.
    * @type GameSkeleton
    *
    * @memberof GameSkeleton
    *
    */
	GameSkeleton.game = null;
	
	/** 
	*   The displayed CanvasObject controlled by the camera.
	*    @type CanvasObject
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.cameraLayer;
	/** 
	*   The background, bottom most layer added as a layer for the camera to draw from.
	*    @type CanvasObject
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.backgroundLayer;
	/** 
	*   The display is where the scene is drawn it is on top of background, camera draws from it after backgroundLayer.
	*    @type CanvasObject
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.display;
	/** 
	*   
	*    charLayer is where characters and projectiles and scenery objects are drawn it's drawn on top of display.
    *  @type CanvasObject
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.charLayer;
	/** 
	*    The width of the game, set in specs during construction.
	*    @type Number
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.gameWidth;
	/** 
	*   
	*    The height of the game, set in specs during construction.
	*    @type Number
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.gameHeight;
	/** 
	*   
	*    @type BasicCamera
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.camera = null;
	/** 
	*   
	*    
	*    @type TileSceneChanger
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.sceneChanger = null;
	/** 
	*   
	*    The width of the camera view.
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.cameraWidth;
	/** 
	*   
	*    The height of the camera view.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.cameraHeight;
	/** 
	*   
	*    The horizontal offset amount the camera should follow the player
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.cameraFollowOffsetX;
	/** 
	*   
	*    The vertical offset amount the camera should follow the player
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.cameraFollowOffsetY;
	/** 
	*   This CanvasObjectContainer gets added as the first screen to the ScreenOrganizer.
    *   cameraLayer is added as the second screen and gameOverContainer is the last screen.
    *   You can add html to the div property of a CanvasObjectContainer,
    *   or you can draw to its floor property which is a CanvasObject.
    *
	*    @type CanvasObjectContainer
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.title;
	/** 
	*   The html div that is the start button
	*    It gets added to the div property of the title CanvasObjectContainer.
	*    
	* @memberof GameSkeleton  
	*  
	*/
    GameSkeleton.prototype.startButton;
	/** 
	*   
	*    The height for the controller
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.controllerHeight;
	/** 
	*   
	*    The html div element that is the container of the root and controller html elements.
	*    
	* @memberof GameSkeleton  
	*  
	*/
    GameSkeleton.prototype.container;
	/** 
	*   
	*    The html element where the game will display, should be inside of the container element.
    *    When using a screenOrganizer (which by default a screenOrganizer is used) this property will reference a CanvasObjectContainer that has the actual element as its div property.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.root;
	/** 
	*   A reference to the ControllerPad instance
	*    
    *  @type ControllerPad
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.controller;
	/** 
	*   
	*    The scale of the game, default is 1.01, this is set using the specs param during construction.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.gameScale = 1.01;
    /** 
	*   
	*    The scale of the hud, default is 1.01, this is set using the specs param during construction.
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.hudScale = 1.01;
	/** 
	*   
	*    The width of eath tile in maps, default is 16.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.tileWidth = 16;
	/** 
	*   The height of each tile in maps, default is 16.
	*    
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.tileHeight = 16;
	
	/** 
	*   This CanvasObjectContainer gets added as the last screen to the screenOrganizer.
    *   
	*    @type CanvasObjectContainer
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.gameOverContainer;
	/** 
	*   
	*    A property ready to reference something showing credits, its not used by default.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.creditsContainer;
	/** 
	*   
	*    A html textarea that is added to/removed from container during the showText/hideText methods.
    *   The showText method has params for styling the speechBubble.
    *   The methods associated with this property are showText hideText textIsShown and textFinished
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.speechBubble;
	
	/** 
	*   
	*    The player property needs to be defined. 
    *    Normally you would define this property during initializationSpecifics.
    *    This property is referenced by various methods and needs to be a MapMover/MapTraveler or extension of.
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.player = null;
	/** 
	*   An optional MoverPoint defining the inital x and y location of the player.
	*    Set during construction as part of the specs param.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.initialPlayerPosition;
	/** 
	*   
	*    The lives of the player, default is 3.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.lives = 3;
	/** 
	*   
	*    The inital lives that the game started with, default is 3.
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype._initLives = 3;
	
	/** 
	*   By default this gets set up as a IrisScreenOrganizer with title, cameraLayer, and gameOverContainer screens.
	*    @type ScreenOrganizer
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.screenOrganizer = null;
	/** 
	*   
	*   A reference to the sprite sheet being drawn from. This is defined in the specs Object during construction as spriteSheetImage, see the specs Object in the constructor.
    *
    *   You can also load an Img into this param however you want, this property is what is used as the sprite sheet for the game.
    *
    *   see also tabageos.loadSpriteSheetAndStart
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype._image = null;
	
	/** 
	*   
	*    When 1 the it is assumed that root is being resized on a desktop.
    *
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.resizeRootForNoTouch = 0;
	/** 
	*   
	*    Don't resize vertically during resize, default is 0.
	*    
	* @memberof GameSkeleton  
	*  
	*/
    GameSkeleton.prototype.dontResizeVertical = 0;
	/** 
	*   
	*    Don't resize horizontally during resize, default is 0.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.dontResizeHorizontal = 0;
	
	/** 
	*   
	*    When set to greater than 0 the camera will constantly move horizontal instead of following the player.
	*    
	* @memberof GameSkeleton  
	*  
	*/
    GameSkeleton.prototype.horizontalCameraMove = 0;
	/** 
	*   
	*    When set to greater than 0 the camera will constantly move vertically instead of following the player.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.verticalCameraMove = 0;
	
	/** 
	*   The type of tween the camera will use, default us InOutLinear
	*    
	*    @type String
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.cameraTweenType = "InOutLinear";
	/** 
	*   
	*    The frame rate for the game, default is 60.
	*    @type Number
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.frameRate = 60;
	/** 
	*   
	*   The frame time, calculated based on frameRate. 
	*    @type Number
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.frameTime = (1000/60) * (60 / (60) ) - (1000/60) * 0.5;
	
	/** 
	*   Optionally set as part of the specs Object during construction
	*    
	*    @type Function
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.addedInitializationMethod = null;
	
	
	/** 
	*   A method that does additional resizie related things, it would happen after the default resizing happens.
	*  By default the game will fill the screen if gameScale is 1, it will not scale if gameScale is 0, and it will be smaller from values greater than 1.
	*	when the game is smaller than the page it will be in the middle.
	*	addedResizeMethod is sometimes needed in cases where you have other stuff on the page besides the game.
	* 			
	*    This method is typically defined during construction as part of the specs param.
	*    @type Function
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.addedResizeMethod = null;
	
	
	/** 
	*   
	*    your loop method that defines the specific mechanics of the game
	*    @type Function
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.gameFunction = null;
	
	
	/** 
	*   A method that would happen just before the scene is reset.
	*	By default nothing happens on reset just the ScreenOrganizer will show the transition.
	*	To have something happen create a method that does things (this method happens before the transition starts)
	*	and pass it as this param or as specs.additionalSceneResetSpecifics. As with all these methods, the 'this' inside of them would be able to reference all GameSkeleton properties.
	*    See the specs param of the constructor.
	*    @type Function
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.sceneResetSpecifics = null;
	
	
	/** 
	*   A method that would happen as the game is reseting to the title screen. Typically you would use this to clear out Objects you have created and to stop event listeners you have made.
	*	If you have not added any objects other than defining the player, you would not have to worry about this method.
	*	if you have for example many enemies made, this method would be used to destroy them before the game resets.
	*	See the specs param of the constructor.
	*    @type Function
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.fullResetSpecifics = null;
	
	
	/** 
	*   
	*    A method that is similar to sceneResetSpecifics but would happen when the transition covers the screen.
	*	sceneResetSpecifics would happen before the transition, and additionalSceneResetSpecifics would happen when the screen is covered.
    * See the specs param of the constructor.
	* @type Function
	*    
	* @memberof GameSkeleton  
	*  
	*/
    GameSkeleton.prototype.additionalSceneResetSpecifics = null;
	
	
	/** 
	*   A method that would change the position of the player during reset. By default the position of the player does not change on reset.
	* See the specs param of the constructor.
	*    @type Function
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.positionResetSpecifics = null;
	
	
	/** 
	*   A method that will replace the loop method,
    *      and   methods utilize this functionality.
	*    @type Function
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.alternateLoopMethod = null;
	
	/** 
	*   
	*    See the specs param of the constructor.
	*    @type Function
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.sceneChangeSpecifics = null;
	
	/** 
	*   See the specs param of the constructor.
	*    @type Function
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.priorToSceneChange = null;
	
	/** 
	*   See the specs param of the constructor.
	*    
	*    @type Function
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.afterSceneChange = null;
	
	/** 
	*   
	*    See the specs param of the constructor.
	*    @type Function
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.beforeStartGameLoop = null;
	
    /** 
	*   
	*    A reference to the html div element that is the games hud in the right hand upper corner.
    *    It has pause mute reset exit and help buttons.
    *    It is automatically set up as part of construction.
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype._HUD = null;
    /** 
	*   
	*    An html div that is part of the hud.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.hPause = null;
    /** 
	*   
	*    An html div that is part of the hud.
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.hReset = null;
    /** 
	*   
	*    An html div that is part of the hud.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.hMute = null;
    /** 
	*   
	*    An html div that is part of the hud.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.hExit = null;
    /** 
	*   
	*    An html div that is part of the hud.
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.hWalkthrough = null;
	
	/** 
	*   
	*    An html div that is in the top left corner that contains the _healthBar and _scoreTextDisplay html divs.
    *    use showHealthBar/hideHealthBar showScoreText/hideScoreText to show/hide and style the playerHUD area. 
	*     
	* @memberof GameSkeleton  
	*  
	*/
    GameSkeleton.prototype._playerHUD = null;
	/** 
	*   
	*    Inside of _playerHUD by default on the top left of the screen.
	*    
	* @memberof GameSkeleton  
	*  
	*/
    GameSkeleton.prototype._healthBar = null;
	/** 
	*   
	*    Inside of _playerHUD by default on the top left of the screen.
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype._scoreTextDisplay = null;
	/** 
	*   
	*    
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype._manuelControllerUse = 0;
	/** 
	*   
	*    This needs to be set as 1 if your making an isometric scene using the iso classes.
	*			
	*    @type Number
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.initForISO = 0;
	/** 
	*    A helper MoverPoint ready to be used.
	*    @type MoverPoint
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype._helperPoint = null;
	/** 
	*   
	*    A helper Rectangle ready to be used.
	*    @type Rectanlge
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype._helperRect = null;
    /** 
	*   
	*    
	*    @type String
	* @memberof GameSkeleton 
	*  
	*/
	GameSkeleton.prototype.walkthroughLink = "";
	/** 
	*   See the specs param of the constructor.
	*    @type Function
	*    
	* @memberof GameSkeleton 
	*  
	*/
	GameSkeleton.prototype.underCoverSpecifics = null;
    /** 
	*   
	*    If set to 1 then up and down scene changes will happen automatically as well. 
    *   By default, when there is a sceneChanger being used, only left and right scene changes happen.		
	*			
	*    @type Number
	* @memberof GameSkeleton 
	*  
	*/
	GameSkeleton.prototype.topDownSceneChange = 0;
    
    /** 
	*   
	*    
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.__specs = null;
    /**
	*   
	*    see tabageos.loadSpriteSheetAndStart in Utils.
	*    
	* @memberof GameSkeleton
	*  
	*/
	GameSkeleton._str = ["","","","","","","","","",""];
    
    
    
	/**
    *
    *
    * @memberof GameSkeleton
    * @type SoundSystem
    *
    *
    */
	GameSkeleton.prototype.soundSystem = null;
    /**
    *
    *  If 1 then sounds and music will not be heard.
    *   Change with the muteUnmute method.
    *
    * @memberof GameSkeleton
    *
    *
    *
    */
	GameSkeleton.prototype._mute = 0;
    
    /**
    *
    *  By default the game will auto pause when focus is lost (for example going to another tab)
    *  You can change this property in your extending class after calling super but before calling initialConstruction.
    *  Or by passing it as part of the specs Object during construction. Default is 1, use 0 to not autoPause.
    *
    * @memberof GameSkeleton
    *
    *
    *
    */
    GameSkeleton.prototype.autoPause = 1;
    /**
    *
    *
    * an offscreen canvas used to display light areas, initializeLights creates it.
    *
    * @memberof GameSkeleton
    * @type CanvasObject
    */
    GameSkeleton.prototype._lightCanvas = null;
	/**
	* Call this first to set up lighting.
	*  Then just call readyLights or animateLights,
	*  and then readyAdditionalLights or animateAdditionalLights if needing more than 1 light.
	*  a dim as 1 and composion as 1 causes the whole screen to be black except for the light areas.
	*  Performance actually increases significantly when that is done because most of the screen becomes just black.
	*  But a 2 composition and decimal dim values will slow down the game if used in too large of an area or with too many lights.
	*  But if what your after is a grey day effect or some similar color application to the whole scene a decimal dim and some color value with a 2 composition is what to use.
	*  If you want for example fire to be lit around the player, a dim of 1 with red as the color and 2 as composition would allow for that, and you'd have a colored fire animation that you'd then pass to animateLights.
	*  
    *  @memberof GameSkeleton.prototype 
	*  @method initializeLights
    *  @param dim {Number}
    *  @param color {Number}
    *  @param composition {Number}
    *
    */
	GameSkeleton.prototype.initializeLights = function(dim, color, composition) {
		var ths = tabageos.GameSkeleton.game;
		
		ths._lightCanvas = new tabageos.CanvasObject(null,ths.gameWidth, ths.gameHeight);
		ths._lightCanvas.context.fillStyle = color;
		ths.changeLightShade(dim,color);
		ths._lightCanvas.context.fillRect(0,0,ths.gameWidth,ths.gameHeight);
		ths._lightComp = ths.lightType(composition || 1);
		
		return true;
	};
	GameSkeleton.prototype._lightDim = .5;
    /**
    *
    * @memberof GameSkeleton.prototype
    * @method changeLightShade
    *
    * @param dim {Number} Will be the globalAlpha value of the lightCanvas context.
    * @param color {Number} Will be the fillStyle of the lightCanvas context.
    */
	GameSkeleton.prototype.changeLightShade = function(dim,color) {
		if(!tabageos.GameSkeleton.game._lightCanvas) return;
		if(dim || dim === 0) {
			tabageos.GameSkeleton.game._lightDim = dim;
		}
		if(color) {
			tabageos.GameSkeleton.game._lightCanvas.context.fillStyle = color;
		}
		
	};
    /**
    *
    * Sets _lightCanvas globalAlpha to dim or _lightDim and clears the _lightCanvas
    *
    *
    * @memberof GameSkeleton.prototype
    * @method turnOffLights
    *
    * @param dim {Number}  
    * @param apply {Boolean}
    */
	GameSkeleton.prototype.turnOffLights = function(dim, apply) {
		if(!tabageos.GameSkeleton.game._lightCanvas) return;
		dim = dim || tabageos.GameSkeleton.game._lightDim;
		tabageos.GameSkeleton.game._lightCanvas.context.globalAlpha  = dim;
		tabageos.GameSkeleton.game._lightCanvas.context.clearRect(0,0,tabageos.GameSkeleton.game.gameWidth,tabageos.GameSkeleton.game.gameHeight);
		tabageos.GameSkeleton.game._lightCanvas.context.globalAlpha  = dim;
		if(dim && dim != 1) {
			tabageos.GameSkeleton.game._lightCanvas.context.fillRect(0,0,tabageos.GameSkeleton.game.gameWidth,tabageos.GameSkeleton.game.gameHeight);
		}
		if(apply) {
			tabageos.GameSkeleton.game.applyLights();
		}
	};
    /**
    *
    *   Draws from this._image onto the _lightCanvas, and applies _lightCanvas if the apply param is set.
    *   This method is used by readyLights and readyAdditionalLights, animateLights and animateAdditionalLights.
    *
    * @memberof GameSkeleton.prototype
    * @method turnOnLights
    *
    * @param fromRect {Rectangle}
    * @param toX {Number}
    * @param toY {Number}
    * @param apply {Boolean}
    */
	GameSkeleton.prototype.turnOnLights = function(fromRect,toX,toY, apply) {
		if(!tabageos.GameSkeleton.game._lightCanvas) return;
		var ths = tabageos.GameSkeleton.game;
		ths._helperPoint.x = toX; ths._helperPoint.y = toY;
		ths._lightCanvas.copyPixels(ths._image, fromRect, ths._helperPoint);
		
		if(apply) {
			ths.applyLights();
		}
		
	};
    /**
    *
    *  Determines the initial composition mode for lighting. Default is 'destination-in'.
    *
    * @memberof GameSkeleton
    *
    *
    *
    */
	GameSkeleton.prototype._lightComp = 'destination-in';//'multiply';
    /**
    *
    *  will return the current composition type when nothing is passed.
    *
    * @memberof GameSkeleton.prototype
    * @method lightType
    *
    * 
    * @param number {Number} 1 is 'destination-in' and 2 is 'multiply' 0 would have it return whatever _lightComp is currently set to.
    * @return {String} 
    * 
    */
	GameSkeleton.prototype.lightType = function(number) {
		if(!number) {
			return tabageos.GameSkeleton.game._lightComp;
		}
		if(number != 1) {
			return 'multiply';
		} else {
			return 'destination-in';
		}
	};
    /**
    *
    *  After calling initializeLights, call this method to turn on and apply one instance of lights.
    *  
    *
    * @memberof GameSkeleton.prototype
    * @method readyLights
    *
    * @param fromRect {Rectangle} Where in the _image to copy the lights from.
    * @param toX {Number} x location to place the light
    * @param toY {Number} y location to place the light
    * @param composition {Number} 1 for destination-in  2 for multiply. To define another do not pass this property and instead change the _lightComp protperty.
    */
	GameSkeleton.prototype.readyLights = function(fromRect,toX,toY, composition) {
		if(tabageos.GameSkeleton.game._lightCanvas) {
			tabageos.GameSkeleton.game._lightComp = tabageos.GameSkeleton.game.lightType(composition);
			tabageos.GameSkeleton.game.turnOffLights();
			tabageos.GameSkeleton.game.turnOnLights(fromRect,toX,toY);
			tabageos.GameSkeleton.game.applyLights();
		}
		
	};
    /**
    *
    *  To turn on additional lights, after initializeLights and readyLights have been used, call this method.
    *  readyLights turns on the first instance of a light, calling it again will first turn off any lights
    *
    * @memberof GameSkeleton.prototype
    * @method readyAdditionalLights
    *
    * @param fromRect {Rectangle}
    * @param toX {Number}
    * @param toY {Number}
    * @param composition {Boolean}
    */
	GameSkeleton.prototype.readyAdditionalLights = function(fromRect,toX,toY, composition) {
		if(tabageos.GameSkeleton.game._lightCanvas) {
			tabageos.GameSkeleton.game._lightComp = tabageos.GameSkeleton.game.lightType(composition);
			tabageos.GameSkeleton.game.turnOnLights(fromRect,toX,toY);
			tabageos.GameSkeleton.game.applyLights();
		}
		
	};
    /**
    *
    * This method turns on the first instance of animated light. 
    *  To display the animation call this method during a loop.
    *
    * @memberof GameSkeleton.prototype
    * @method animateLights
    *
    * @param canvasAnimation {CanvasAnimation} A CanvasAnimation defining the lights animation from the _image
    * @param toX {Number} the x position of where to place the light
    * @param toY {Number} the y placement of the light
    * @param speed {Number} The desired speed of the animation, default is .5
    * @param composition {Boolean} 1 for destination-in  2 for multiply. To define another do not pass this property and instead change the _lightComp protperty.
    */
	GameSkeleton.prototype.animateLights = function(canvasAnimation,toX,toY, speed, composition) {
		if(tabageos.GameSkeleton.game._lightCanvas) {
			tabageos.GameSkeleton.game._lightComp = tabageos.GameSkeleton.game.lightType(composition);
			tabageos.GameSkeleton.game.turnOffLights();
			canvasAnimation.animate(speed || .5);
			tabageos.GameSkeleton.game.turnOnLights(canvasAnimation.fromRect,toX,toY);
			tabageos.GameSkeleton.game.applyLights();
		}
		
	};
    /**
    *
    *  Displays and animates additional animated light.
    *  To display the animation call this method in a loop.
    *
    *  For multiple animated lights the methods used would be
    *   initializeLights, then animateLights then as many calls to animateAdditionalLights for each additional light. 
    *   And both animateLights and the animateAdditionalLights calls would need to repeat in the main loop.
    *
    * @memberof GameSkeleton.prototype
    * @method animateAdditionalLights
    *
    * @param canvasAnimation {CanvasAnimation}
    * @param toX {Number}
    * @param toY {Number}
    * @param speed {Number}
    * @param composition {Boolean}
    */
	GameSkeleton.prototype.animateAdditionalLights = function(canvasAnimation,toX,toY, speed, composition) {
		if(tabageos.GameSkeleton.game._lightCanvas) {
		
			tabageos.GameSkeleton.game._lightComp = tabageos.GameSkeleton.game.lightType(composition);
			canvasAnimation.animate(speed || .5);
			tabageos.GameSkeleton.game.turnOnLights(canvasAnimation.fromRect,toX,toY);
			tabageos.GameSkeleton.game.applyLights();
		}
	};
	GameSkeleton.prototype._doLights = 0;
    /**
    *
    * @memberof GameSkeleton.prototype
    * @method applyLights
    *
    * 
    */
	GameSkeleton.prototype.applyLights = function() {
		if(!tabageos.GameSkeleton.game._lightCanvas) return;
		tabageos.GameSkeleton.game._doLights = 1;
	};
    /**
    *
    * if applyLights has been called (readyLights, animateLights and related methods all call applyLights internally)
    * this method happens in _loop after the cameras tweenedBlitLayerRender method 
	* cameras cameraLayer globalCompositeOperation is changed to this._lightComp then it copys the _lightCanvas
	* then its globalCompositeOperation is changed back to source-over.
    *
    * @memberof GameSkeleton.prototype
    * @method _actualApplyLights
    *
    * 
    */
	GameSkeleton.prototype._actualApplyLights = function() {
		var ths = tabageos.GameSkeleton.game;
		
		if(ths._doLights) {
		
			ths._helperRect.x= 0;ths._helperRect.y = 0;ths._helperRect.width = ths.gameWidth; ths._helperRect.height = ths.gameHeight;
			ths._helperPoint.x = 0; ths._helperPoint.y = 0;
			ths.cameraLayer.context.globalCompositeOperation = ths._lightComp;//'multiply';//'destination-in';
			ths.cameraLayer.copyPixels(ths._lightCanvas.canvas, ths._helperRect, ths._helperPoint );
			ths.cameraLayer.context.globalCompositeOperation = 'source-over';
			ths._doLights = 0;
		} 
		
	};
    
    
    /**
    *
    *   Used to see if two 1d Arrays match, can be used with Numbers as well
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method valuesMatch
    * @param v1 {Array} 
    * @param v2 {Array} 
    * @return {Boolean}
    * 
    * 
    */
    GameSkeleton.prototype.valuesMatch = function(v1,v2) {
		return tabageos.BlitMath.valuesMatch(v1,v2);
	};
    
    
	GameSkeleton.prototype.__buttons = [];
	
    
    /**
    *
    *   Returns the button with the given name.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method getButton
    * @param name {String}
    * @return {HTMLDivElement}
    * 
    * 
    */
	GameSkeleton.prototype.getButton = function(name) {
		
		var i = 0;var b = null;
		var l = this.__buttons.length;
		for(i; i < l;i++) {
			b = this.__buttons[i];
			if(b.id && b.id == name) {
				break;
			}
		}
		return b;
	};
	/**
    *
    *   Creates a clickable/touchable button.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method makeButton
    * @param name {String} The name for the button, must be unique
    * @param x {Number} The x location of the button on the whole game size.
    * @param y {Number} The y location of the button
    * @param width {Number} The width of the button
    * @param height {Number} The height of the button
    * @param methodToCallString {String} The name of the method to call when the button is selected. This method should exist on an extension of GameSkeleton or be one of the GameSkeleton methods, for example pause.
    * @param altString {String} The string to show when a player hovers over the button
    * @param linkString {String} a link string to a website, if this is set then the button will be an 'a' element instead of a div element, and the link would open in a new page.
    * @param forTitle {Boolen} If this is set the button will be labeled to be on the title screen instead of the main container.
    * 
    * 
    * 
    */
	GameSkeleton.prototype.makeButton = function(name, x,y,width,height,methodCallString,altString,linkString, forTitle) {
		
		var bttn = (linkString ? document.createElement("a") : document.createElement("div"));
		bttn.setAttribute("style", "position:absolute; left:"+x+"px;top:"+y+"px;width:"+width+"px;height:"+height+"px;cursor:pointer;z-index:99999999999999999999999999999999999999999999999999999999999999999999999999");
		bttn.setAttribute("title", altString || "");
		bttn.setAttribute("id", name );
		bttn.setAttribute("name", (forTitle ? "ForTitleScreen" : ""));
		bttn.setAttribute("alt", altString);
		if(methodCallString && methodCallString.indexOf("()") == -1) {
			throw "the makeButton methodCallString param needs to be in the with parens 'methodName()' format";
			return;
		}
		if(!linkString) {
			bttn.setAttribute("onclick", methodCallString);
		} else {
			bttn.setAttribute("target", "_blank");
			bttn.setAttribute("href", linkString);
			
		}
		var i = 0;var b;var na = 0;
		var l = this.__buttons.length;
		for(i; i < l;i++) {
			b = this.__buttons[i];
			if(b.id && b.id == name) {
				na = 1; break;
			}
			
			
		}
		
		if(!na) {
			
			this.__buttons.push(bttn);
		} else {
			window.console.log("makeButton: Button name, " + name + ", is not unique, button not created");
		}
		
	};
	/**
    *
    *   Removes all buttons including the start button.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method removeAllButtons
    * 
    * 
    * 
    */
	GameSkeleton.prototype.removeAllButtons = function() {
		
		var i = 0;var b;
		var l = this.__buttons.length;
		for(i; i < l;i++) {
			b = this.__buttons[i];
			if(b && b.id) {	
				if(this.title.div.contains(b)) {
					this.title.div.removeChild(b);
				} else if(this.container.contains(b)) {
					this.container.removeChild(b);
				}
			}	
		}
		
		if(this.title.div.contains(this.startButton)) { 
			this.title.div.removeChild(this.startButton);
		}
		
		
	};
    /**
    *
    *   Replaces all buttons including the start button.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method replaceAllButtons
    * 
    * 
    * 
    */
	GameSkeleton.prototype.replaceAllButtons = function() {
		
		var i = 0;var b;
		var l = this.__buttons.length;
		for(i; i < l;i++) {
			b = this.__buttons[i];
			if(b && b.id) {	
				if(b.name && b.name.indexOf("ForTitleScreen") != -1) {
					this.title.div.appendChild(b);
				} else if(!this.container.contains(b)) {
					this.container.appendChild(b);
				}
			}	
		}
		
		if(!this.title.div.contains(this.startButton)) { 
			this.title.div.appendChild(this.startButton);
		}
		
		
	};
    /**
    *
    *   Trashes the button with the given name, it would have to be remade.
    *  Call removeButton first if your trying to destroy the button.
    * 
    * @memberof GameSkeleton.prototype
    * @method trashButton
    * @param name {String} The name of the button to trash
    * 
    * 
    * 
    */
	GameSkeleton.prototype.trashButton = function(name) {
		var i = 0;var b = null;
		var l = this.__buttons.length;
		for(i; i < l;i++) {
			b = this.__buttons[i];
			if(b.id && b.id == name) {
				this.__buttons.splice(this.__buttons.indexOf(b), 1);
				break;
			}
		}
		
	};
    /**
    *
    *   Trashes all buttons. Call removeAllButtons first in order to destroy all buttons.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method trashAllButtons
    * 
    * 
    * 
    * 
    */
	GameSkeleton.prototype.trashAllButtons = function() {
		
		this.__buttons = [];
		
	};
    /**
    *
    *   Removes the default start button from the title screen
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method removeStartButton
    * 
    * 
    * 
    * 
    */
	GameSkeleton.prototype.removeStartButton = function() {
		if(this.title.div.contains(this.startButton)) { 
			this.title.div.removeChild(this.startButton);
		}
		
	};
    /**
    *
    *   Appends the default start button on the title screen.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method appendStartButton
    * 
    * 
    * 
    * 
    */
	GameSkeleton.prototype.appendStartButton = function() {
		if(!this.title.div.contains(this.startButton)) { 
			this.title.div.appendChild(this.startButton);
		}
	};
	/**
    *
    *   Removes the button with the given name.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method removeButton
    * @param name {String} The name of the button to remove
    * @param fromTitle {Boolean} optionally signify that the button is on the title screen
    * 
    * 
    * 
    */
	GameSkeleton.prototype.removeButton = function(name, fromTitle) {
		
		
		var i = 0;var b;
		var l = this.__buttons.length;
		for(i; i < l;i++) {
			b = this.__buttons[i];
			if(b && b.id && b.id == name) { fromTitle = fromTitle || (b.name && b.name.indexOf("ForTitleScreen") != -1);
				if(fromTitle) {
					
					if(this.title.div.contains(b)) {
						this.title.div.removeChild(b);
					}
				} else {
					if(this.container.contains(b)) {
						this.container.removeChild(b);
					}
					
					
				}
				
				break;
			}
			
			
		}
		
		
	};
	/**
    *
    *   Appends the button with the given name.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method appendButton
    * @param name {String} The name of the button to append
    * @param toTitle {Boolean} optionally signify that the button is to be on the title screen
    * 
    * 
    * 
    */
	GameSkeleton.prototype.appendButton = function(name, toTitle) {
		
		var i = 0;var b;
		var l = this.__buttons.length;
		for(i; i < l;i++) {
			b = this.__buttons[i];
			if(b && b.id && b.id == name) {toTitle = toTitle || (b.name && b.name.indexOf("ForTitleScreen") != -1);
				if(toTitle) {
					
					if(!this.title.div.contains(b)) {
						this.title.div.appendChild(b);
					}
				} else {
					if(!this.container.contains(b)) {
						this.container.appendChild(b);
					} 
					
					
				}
				
				break;
			}
			
			
		}
		
		
	};
	/**
    *
    *   Sets up pause, home, mute, and link buttons.
    *   After calling this method, use appendStandardButtons to place them, and removeStandardButtons to remove them.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method setupStandardButtons
    * @param pauseX {Number} x location of pause
    * @param pauseY {Number} y location of pause
    * @param pw {Number} width of pause, default is 16
    * @param ph {Number} height of pause, default is 16
    * @param homeeX {Number} x location of home button
    * @param homeY {Number} y location of home
    * @param hw {Number} width of home, default is 16
    * @param hh {Number} height of home, default is 16
    * @param muteX {Number} x location of mute button
    * @param muteY {Number} y location of mute
    * @param mw {Number} width of mute, default is 16
    * @param mh {Number} height of mute, default is 16
    * @param linkX {Number} x location of link button
    * @param linkY {Number} y location of link
    * @param lw {Number} width of link, default is 16
    * @param lh {Number} height of link, default is 16
    * @param linkaltstring {String} A string for the link title
    * @param thelink {String} The http link string, for example https://www.tabageos.com
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    * 
    * 
    */
	GameSkeleton.prototype.setupStandardButtons = function(pauseX,pauseY,pw,ph,homeX,homeY,hw,hh,muteX,muteY,mw,mh,linkX,linkY,lw,lh, linkaltstring, thelink) {
		
		if(!this.getButton("pauseButton") && !this.getButton("muteButton") && !this.getButton("homeButton") && !this.getButton("linkButton")) {
			
			this.makeButton("pauseButton", pauseX, pauseY, pw || 16, ph || 16, "tabageos.GameSkeleton.game.pause()", "pause unpause");
			
			this.makeButton("homeButton", homeX, homeY, hw || 16, hh || 16, "tabageos.GameSkeleton.game.fullResetToTitle()", "exit to title");
			
			this.makeButton("muteButton", muteX, muteY, mw || 16, mh || 16, "tabageos.GameSkeleton.game.muteUnmute()", "mute unmute");
			
			if(linkaltstring && thelink) {
				this.makeButton("linkButton", linkX, linkY, lw || 16, lh || 16, null, linkaltstring, thelink);
			}
			
		}
		
		
	};
    /**
    *
    *   
    *   After calling setupStandardButtons, use appendStandardButtons to place them, and removeStandardButtons to remove them.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method appendStandardButtons
    *
    *
    */
	GameSkeleton.prototype.appendStandardButtons = function() {
		
		this.appendButton("pauseButton");
		this.appendButton("homeButton");
		this.appendButton("muteButton");
		this.appendButton("linkButton");
		
	};
    /**
    *
    *   
    *   After calling setupStandardButtons, use appendStandardButtons to place them, and removeStandardButtons to remove them.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method removeStandardButtons
    *
    *
    */
	GameSkeleton.prototype.removeStandardButtons = function() {
		this.removeButton("pauseButton");
		this.removeButton("homeButton");
		this.removeButton("muteButton");
		this.removeButton("linkButton");
		
	};
	
	/**
    *
    *   
    *   Use to setup a Level Select (named "levelSelect") button on the title screen and initialize level select functionality.
    *   Your GameSkeleton extension needs to be using a sceneChanger (which is the default) in order for level select to work.
    * 
    * @memberof GameSkeleton.prototype
    * @method setupLevelSelect
    * @param lsButtonX {Number} x location of the level select button
    * @param lsButtonY {Number} y location of the level select button
    * @param lsButtonWidth {Number} width of the level select button
    * @param lsButtonHeight {Number} height of the level select button
    * @param amountOfLevels {Number} amount of levels, default max is 38, see the __levelSelectSpriteSheetString property.
    * @param titleScreenFromRect {Rectangle} a rectangle defining where to draw from in the sprite sheet for the title background (the actual button image would be part of the background)
    * @param setupMethodString {String} a string defining the setup method, this method name should be the name of the method used for sceneChangeSpecifics (as defined in the specs Object during construction of a GameSkeleton extension)
    * @param dontAppend {Boolean} If true the level select button would get made but not appended to the title screen, default is false.
    *
    */
	GameSkeleton.prototype.setupLevelSelect = function(lsButtonX,lsButtonY,lsButtonWidth,lsButtonHeight, amountOfLevels, titleScreenFromRect, setupMethodString, dontAppend) {
		
		if(this.getButton("levelSelect")) {
			this.trashButton("levelSelect");
		}
		
		this.makeButton("levelSelect", lsButtonX, lsButtonY, lsButtonWidth,lsButtonHeight, "tabageos.GameSkeleton.game.showLevelSelect()", "Level Select");
		
		
		
		if(!this.__levelSelectSpriteSheet) {
			
			this.__levelSelectSpriteSheet = new Image();
			this.__levelSelectSpriteSheet.src = this.__levelSelectSpriteSheetString;
			
		}
		
		this.addedInitializationMethodString = setupMethodString || "setup";
		
		if(titleScreenFromRect) {
			this.__titleScreenRect = titleScreenFromRect;
		}
		this._levelSelectAmount = amountOfLevels || 10;
		if(!dontAppend) { this.appendButton("levelSelect", 1); }
		
		
	};
    /**
    *
    *   
    *   Remove the level select button.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method removeLevelSelect
    *
    */
	GameSkeleton.prototype.removeLevelSelect = function() {
		
		this.removeButton("levelSelect", 1);
		
	};
	
	GameSkeleton.prototype._levelSelectAmount = 10;
    /**
    *
    *   A base64 string defining the level select sprite sheet.
    *   The default sheet has up to 38 levels.
    *   You can bring the default sprite sheet into an editor like gimp or photoshop to edit it.
    *   Save your edits, and bring it back to base64 and replace this string with your updated bsae64 string to change what level select looks like.
    *
    *   One way to have more than 38 levels is to copy the sprite sheet, and change the numbers, you could use just 1-30 then make another sheet with 31-60 in the same  places as the 1-30 numbers.
    *   When the level reaches 30 during onSelectLevel change the __levelSelectSpriteSheetString to the image with numbers 31-60 and set this.__levelSelectSpriteSheet to null and call setupLevelSelect.
    *   Then during the onSelectLevel method, when the level is more than 30 you would add 30 to this.sceneChanger.currentScene and then call this.sceneChanger.changeCurrentMap(this.sceneChanger.currentScene);
    *
    *   This is the default level select sprite sheet base64 string:
    *
    *
    *   "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAu4AAALuCAYAAADxHZPKAAAgAElEQVR4Xuy9C5dtTVnfO3evXr2/ApGY5JiYkOSYIZc3mheMGEMIURARRdHjMSfJyMVxvsXJ9ZhELoIgBCRKIKISEQkh3IVouHjBC0nGON/j3d29+4yqOWuuWrWey/+pOVfvXrv/e8DY++1Zs+qpfz016/c8XbPmg4F/qAAVoAJUgApQASpABagAFbjzCjy48xbSQCpABagAFaACVIAKUAEqQAUGgjudgApQASpABagAFaACVIAKnIACBPcTGCSaSAWoABWgAlSAClABKkAFCO70ASpABagAFaACVIAKUAEqcAIKENxPYJBoIhWgAlSAClABKkAFqAAVILjTB6gAFaACVIAKUAEqQAWowAkoQHA/gUGiiVSAClABKkAFqAAVoAJUgOBOH6ACVIAKUAEqQAWoABWgAiegAMH9BAaJJlIBKkAFqAAVoAJUgApQAYI7fYAKUAEqQAWoABWgAlSACpyAAgT3ExgkmkgFqAAVoAJUgApQASpABQju9AEqQAWoABWgAlSAClABKnACChDcT2CQaCIVoAJUgApQASpABagAFSC40weoABWgAlSAClABKkAFqMAJKEBwP4FBoolUgApQASpABagAFaACVIDgTh+gAlSAClABKkAFqAAVoAInoADB/QQGiSZSASpABagAFaACVIAKUAGCO32AClABKkAFqAAVoAJUgAqcgAIE9xMYJJpIBagAFaACVIAKUAEqQAUI7vQBKkAFqAAVoAJUgApQASpwAgoQ3E9gkGgiFaACVIAKUAEqQAWoABUguNMHqAAVoAJUgApQASpABajACShAcD+BQaKJVIAKUAEqQAWoABWgAlSA4E4foAJUgApQASpABagAFaACJ6AAwf0EBokmUgEqQAWoABWgAlSAClABgjt9gApQASpABagAFaACVIAKnIACBPcTGCSaSAWoABWgAlSAClABKkAFCO70ASpABagAFaACVIAKUAEqcAIKENxPYJBoIhWgAlSAClABKkAFqAAVILjTB6gAFaACVIAKUAEqQAWowAkoQHA/gUGiiVSAClABKkAFqAAVoAJUgOBOH6ACVIAKUAEqQAWoABWgAiegAMH9BAaJJlIBKkAFqAAVoAJUgApQAYI7fYAKUAEqQAWoABWgAlSACpyAAgT3ExgkmkgFqAAVoAJUgApQASpABQju9AEqQAWoABWgAlSAClABKnACChDcT2CQaCIVoAJUgApQASpABagAFSC40weoABWgAlSAClABKkAFqMAJKEBwP4FBoolUgApQASpABagAFaACVIDgTh+gAlSAClABKkAFqAAVoAInoADB/QQGiSZSASpABagAFaACVIAKUAGCO32AClABKkAFqAAVoAJUgAqcgAIE9xMYJJpIBagAFaACVIAKUAEqQAUI7vQBKkAFqAAVoAJUgApQASpwAgoQ3E9gkGgiFaACVIAKUAEqQAWoABUguNMHqAAVoAJUgApQASpABajACShAcD+BQaKJVIAKUAEqQAWoABWgAlSA4E4foAJUgApQASpABagAFaACJ6AAwf0EBokmUgEqQAWoABWgAlSAClABgjt9gApQASpABagAFaACVIAKnIACBPcTGCSaSAWoABWgAlSAClABKkAFCO70ASpABagAFaACVIAKUAEqcAIKENxPYJBoIhWgAlSAClABKkAFqAAVILjTB6gAFaACVIAKUAEqQAWowAkoQHA/gUGiiVSAClABKkAFqAAVoAJUgOBOH6ACVIAKUAEqQAWoABWgAiegAMH9BAaJJlIBKkAFqAAVoAJUgApQAYI7fYAKUAEqQAWoABWgAlSACpyAAgT3ExgkmkgFqAAVoAJUgApQASpABQju9AEqQAWoABWgAlSAClABKnACChDcT2CQaCIVoAJUgApQASpABagAFSC40weoABWgAlSAClABKkAFqMAJKEBwP4FBoolUgApQASpABagAFaACVIDgTh+gAlSAClABKkAFqAAVoAInoADB/QQGiSZSASpABagAFaACVIAKUAGCO32AClABKkAFqAAVoAJUgAqcgAIE9xMYJJpIBagAFaACVIAKUAEqQAUI7vQBKkAFqAAVoAJUgApQASpwAgoQ3E9gkGgiFaACVIAKUAEqQAWoABUguNMHqAAVoAJUgApQASpABajACShAcD+BQaKJVIAKUAEqQAWoABWgAlSA4E4foAJUgApQASpABagAFaACJ6AAwf0EBokmUgEqQAWoABWgAlSAClABgjt9gApQASpABagAFaACVIAKnIACBPcTGCSaSAWoABWgAlSAClABKkAFCO70ASpABagAFaACVIAKUAEqcAIKENxPYJBoIhWgAlSAClABKkAFqAAVILjTB6gAFaACVIAKUAEqQAWowAkoQHA/gUGiiVSAClABKkAFqAAVoAJUgOBOH6ACVIAKUAEqQAWoABWgAiegAMH9BAaJJlIBKkAFqAAVoAJUgApQAYI7fYAKUAEqQAWoABWgAlSACpyAAgT3ExgkmkgFqAAVoAJUgApQASpABQju9AEqQAWoABWgAlSAClABKnACChDcT2CQaCIVoAJUgApQASpABagAFSC40weoABWgAlSAClABKkAFqMAJKEBwP4FBoolUgApQASpABagAFaACVIDgTh+gAlSAClABKkAFqAAVoAInoADB/QQGiSZSASpABagAFaACVIAKUAGCO32AClABKkAFqAAVoAJUgAqcgAIE9xMYJJpIBagAFaACVIAKUAEqQAUI7vQBKkAFqAAVoAJUgApQASpwAgoQ3E9gkGgiFaACVIAKUAEqQAWoABUguNMHqAAVoAJUgApQASpABajACShAcD+BQaKJVIAKUAEqQAWoABWgAlSA4E4foAJUgApQASpABagAFaACJ6AAwf0EBokmUgEqQAWoABWgAlSAClABgjt9gApQASpABagAFaACVIAKnIACBPcTGCSaSAWoABWgAlSAClABKkAFCO70ASpABagAFaACVIAKUAEqcAIKENxPYJBoIhWgAlSAClABKkAFqAAVILjTB6gAFaACVIAKUAEqQAWowAkoQHA/gUGiiVSAClABKkAFqAAVoAJUgOBOH6ACVIAKUAEqQAWoABWgAiegAMH9BAaJJlIBKkAFqAAVoAJUgApQAYI7fYAKUAEqQAWoABWgAlSACpyAAgT3ExgkmkgFqAAVoAJUgApQASpABQju9AEqQAWoABWgAlSAClABKnACChDcT2CQaCIVoAJUgApQASpABagAFSC40weoABWgAlSAClABKkAFqMAJKEBwP4FBoolUgApQASpABagAFaACVIDgTh+gAlSAClABKkAFqAAVoAInoADB/QQGiSZSASpABagAFaACVIAKUAGCO32AClABKkAFqAAVoAJUgAqcgAIE9xMYJJpIBagAFaACVIAKUAEqQAUI7vQBKkAFqAAVoAJUgApQASpwAgoQ3E9gkGgiFaACVIAKUAEqQAWoABUguNMHqAAVoAJUgApQASpABajACShAcD+BQaKJVIAKUAEqQAWoABWgAlSA4E4foAJUgApQASpABagAFaACJ6AAwf0EBokmUgEqQAWoABWgAlSAClABgjt9gApQASpABagAFaACVIAKnIACBPcTGCSaSAWoABWgAlSAClABKkAFCO70ASpABagAFaACVIAKUAEqcAIKENxPYJBoIhWgAlSAClABKkAFqAAVILjTB6gAFaACVIAKUAEqQAWowAkoQHA/gUGiiVSAClABKkAFqAAVoAJUgOBOH6ACVIAKUAEqQAWoABWgAiegAMH9BAaJJlIBKkAFqAAVoAJUgApQAYI7fYAKUAEqQAWoABWgAlSACpyAAgT3ExgkmkgFqAAVoAJUgApQASpABQju9AEqQAWoABWgAlSAClABKnACChDcT2CQaCIVoAJUgApQASpABagAFSC40weoABWgAlSAClABKkAFqMAJKEBwP4FBoolUgApQASpABagAFaACVIDgTh+gAlSAClABKkAFqAAVoAInoADB/QQGiSZSASpABagAFaACVIAKUAGCO32AClABKkAFqAAVoAJUgAqcgAIE9xMYJJpIBagAFaACVIAKUAEqQAUI7vQBKkAFqAAVoAJUgApQASpwAgoQ3E9gkGgiFaACVIAKUAEqQAWoABUguNMHqAAVoAJUgApQASpABajACShAcD+BQaKJVIAKUAEqQAWoABWgAlSA4L6iD7zoJc/erFgdq6ICVIAKHCjw1S9/kc9t+gUVoAJU4J4qwAWgc+AJ6Z3C8TYqQAVWV4Awv7qkrJAKUAEqcCcVILgHhoWwHhCLRakAFXgiChDin4jsbJQKUAEqcCsKENwdmQnrt+KHbIQKUIEjKECIP4KorJIKUAEq8AQVILgr4q8B7F/50hee4NCyaSpABZ4GBV78zEsXd4MAv1hCVkAFqAAVuBMKENybYegFdkL6nfBnGkEF7oUCvTBPgL8X7sFOUgEq8BQrQHCvBjcK7RFY///+1xeG7cVm2J6fD0NSfen5Mz11tPdY/713LRkruIp0f9Gz3FL307O5vl7+Pf9sqlC1+WYYHjzQdZXqRie2ZrdVZ5ErOs4PbobhptZa6LenY+kXYjeqgVdOakvTR7XfGUOrX5be0bGQyluaW/1J8wYdr9S/qe3nfcNLPMXn61GIJ7zD0rIgFaACVODOKUBwH4YhAuwIrP/2b31s2G43w3Z7PmzP098jsKe/HyS4jP4xoWECvRZ0czMT9O1B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"
    *   
    *
    * 
    * @memberof GameSkeleton
    * 
    *
    */
	GameSkeleton.prototype.__levelSelectSpriteSheetString = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAu4AAALuCAYAAADxHZPKAAAgAElEQVR4Xuy9C5dtTVnfO3evXr2/ApGY5JiYkOSYIZc3mheMGEMIURARRdHjMSfJyMVxvsXJ9ZhELoIgBCRKIKISEQkh3IVouHjBC0nGON/j3d29+4yqOWuuWrWey/+pOVfvXrv/e8DY++1Zs+qpfz016/c8XbPmg4F/qAAVoAJUgApQASpABagAFbjzCjy48xbSQCpABagAFaACVIAKUAEqQAUGgjudgApQASpABagAFaACVIAKnIACBPcTGCSaSAWoABWgAlSAClABKkAFCO70ASpABagAFaACVIAKUAEqcAIKENxPYJBoIhWgAlSAClABKkAFqAAVILjTB6gAFaACVIAKUAEqQAWowAkoQHA/gUGiiVSAClABKkAFqAAVoAJUgOBOH6ACVIAKUAEqQAWoABWgAiegAMH9BAaJJlIBKkAFqAAVoAJUgApQAYI7fYAKUAEqQAWoABWgAlSACpyAAgT3ExgkmkgFqAAVoAJUgApQASpABQju9AEqQAWoABWgAlSAClABKnACChDcT2CQaCIVoAJUgApQASpABagAFSC40weoABWgAlSAClABKkAFqMAJKEBwP4FBoolUgApQASpABagAFaACVIDgTh+gAlSAClABKkAFqAAVoAInoADB/QQGiSZSASpABagAFaACVIAKUAGCO32AClABKkAFqAAVoAJUgAqcgAIE9xMYJJpIBagAFaACVIAKUAEqQAUI7vQBKkAFqAAVoAJUgApQASpwAgoQ3E9gkGgiFaACVIAKUAEqQAWoABUguNMHqAAVoAJUgApQASpABajACShAcD+BQaKJVIAKUAEqQAWoABWgAlSA4E4foAJUgApQASpABagAFaACJ6AAwf0EBokmUgEqQAWoABWgAlSAClABgjt9gApQASpABagAFaACVIAKnIACBPcTGCSaSAWoABWgAlSAClABKkAFCO70ASpABagAFaACVIAKUAEqcAIKENxPYJBoIhWgAlSAClABKkAFqAAVILjTB6gAFaACVIAKUAEqQAWowAkoQHA/gUGiiVSAClABKkAFqAAVoAJUgOBOH6ACVIAKUAEqQAWoABWgAiegAMH9BAaJJlIBKkAFqAAVoAJUgApQAYI7fYAKUAEqQAWoABWgAlSACpyAAgT3ExgkmkgFqAAVoAJUgApQASpABQju9AEqQAWoABWgAlSAClABKnACChDcT2CQaCIVoAJUgApQASpABagAFSC40weoABWgAlSAClABKkAFqMAJKEBwP4FBoolUgApQASpABagAFaACVIDgTh+gAlSAClABKkAFqAAVoAInoADB/QQGiSZSASpABagAFaACVIAKUAGCO32AClABKkAFqAAVoAJUgAqcgAIE9xMYJJpIBagAFaACVIAKUAEqQAUI7vQBKkAFqAAVoAJUgApQASpwAgoQ3E9gkGgiFaACVIAKUAEqQAWoABUguNMHqAAVoAJUgApQASpABajACShAcD+BQaKJVIAKUAEqQAWoABWgAlSA4E4foAJUgApQASpABagAFaACJ6AAwf0EBokmUgEqQAWoABWgAlSAClABgjt9gApQASpABagAFaACVIAKnIACBPcTGCSaSAWoABWgAlSAClABKkAFCO70ASpABagAFaACVIAKUAEqcAIKENxPYJBoIhWgAlSAClABKkAFqAAVILjTB6gAFaACVIAKUAEqQAWowAkoQHA/gUGiiVSAClABKkAFqAAVoAJUgOBOH6ACVIAKUAEqQAWoABWgAiegAMH9BAaJJlIBKkAFqAAVoAJUgApQAYI7fYAKUAEqQAWoABWgAlSACpyAAgT3ExgkmkgFqAAVoAJUgApQASpABQju9AEqQAWoABWgAlSAClABKnACChDcT2CQaCIVoAJUgApQASpABagAFSC40weoABWgAlSAClABKkAFqMAJKEBwP4FBoolUgApQASpABagAFaACVIDgTh+gAlSAClABKkAFqAAVoAInoADB/QQGiSZSASpABagAFaACVIAKUAGCO32AClABKkAFqAAVoAJUgAqcgAIE9xMYJJpIBagAFaACVIAKUAEqQAUI7vQBKkAFqAAVoAJUgApQASpwAgoQ3E9gkGgiFaACVIAKUAEqQAWoABUguNMHqAAVoAJUgApQASpABajACShAcD+BQaKJVIAKUAEqQAWoABWgAlSA4E4foAJUgApQASpABagAFaACJ6AAwf0EBokmUgEqQAWoABWgAlSAClABgjt9gApQASpABagAFaACVIAKnIACBPcTGCSaSAWoABWgAlSAClABKkAFCO70ASpABagAFaACVIAKUAEqcAIKENxPYJBoIhWgAlSAClABKkAFqAAVILjTB6gAFaACVIAKUAEqQAWowAkoQHA/gUGiiVSAClABKkAFqAAVoAJUgOBOH6ACVIAKUAEqQAWoABWgAiegAMH9BAaJJlIBKkAFqAAVoAJUgApQAYI7fYAKUAEqQAWoABWgAlSACpyAAgT3ExgkmkgFqAAVoAJUgApQASpABQju9AEqQAWoABWgAlSAClABKnACChDcT2CQaCIVoAJUgApQASpABagAFSC40weoABWgAlSAClABKkAFqMAJKEBwP4FBoolUgApQASpABagAFaACVIDgTh+gAlSAClABKkAFqAAVoAInoADB/QQGiSZSASpABagAFaACVIAKUAGCO32AClABKkAFqAAVoAJUgAqcgAIE9xMYJJpIBagAFaACVIAKUAEqQAUI7vQBKkAFqAAVoAJUgApQASpwAgoQ3E9gkGgiFaACVIAKUAEqQAWoABUguNMHqAAVoAJUgApQASpABajACShAcD+BQaKJVIAKUAEqQAWoABWgAlSA4E4foAJUgApQASpABagAFaACJ6AAwf0EBokmUgEqQAWoABWgAlSAClABgjt9gApQASpABagAFaACVIAKnIACBPcTGCSaSAWoABWgAlSAClABKkAFCO70ASpABagAFaACVIAKUAEqcAIKENxPYJBoIhWgAlSAClABKkAFqAAVILjTB6gAFaACVIAKUAEqQAWowAkoQHA/gUGiiVSAClABKkAFqAAVoAJUgOBOH6ACVIAKUAEqQAWoABWgAiegAMH9BAaJJlIBKkAFqAAVoAJUgApQAYI7fYAKUAEqQAWoABWgAlSACpyAAgT3ExgkmkgFqAAVoAJUgApQASpABQju9AEqQAWoABWgAlSAClABKnACChDcT2CQaCIVoAJUgApQASpABagAFSC40weoABWgAlSAClABKkAFqMAJKEBwP4FBoolUgApQASpABagAFaACVIDgTh+gAlSAClABKkAFqAAVoAInoADB/QQGiSZSASpABagAFaACVIAKUAGCO32AClABKkAFqAAVoAJUgAqcgAIE9xMYJJpIBagAFaACVIAKUAEqQAUI7vQBKkAFqAAVoAJUgApQASpwAgoQ3E9gkGgiFaACVIAKUAEqQAWoABUguNMHqAAVoAJUgApQASpABajACShAcD+BQaKJVIAKUAEqQAWoABWgAlSA4E4foAJUgApQASpABagAFaACJ6AAwf0EBokmUgEqQAWoABWgAlSAClABgjt9gApQASpABagAFaACVIAKnIACBPcTGCSaSAWoABWgAlSAClABKkAFCO70ASpABagAFaACVIAKUAEqcAIKENxPYJBoIhWgAlSAClABKkAFqAAVILjTB6gAFaACVIAKUAEqQAWowAkoQHA/gUGiiVSAClABKkAFqAAVoAJUgOBOH6ACVIAKUAEqQAWoABWgAiegAMH9BAaJJlIBKkAFqAAVoAJUgApQAYI7fYAKUAEqQAWoABWgAlSACpyAAgT3ExgkmkgFqAAVoAJUgApQASpABQju9AEqQAWoABWgAlSAClABKnACChDcT2CQaCIVoAJUgApQASpABagAFSC40weoABWgAlSAClABKkAFqMAJKEBwP4FBoolUgApQASpABagAFaACVIDgTh+gAlSAClABKkAFqAAVoAInoADB/QQGiSZSASpABagAFaACVIAKUAGCO32AClABKkAFqAAVoAJUgAqcgAIE9xMYJJpIBagAFaACVIAKUAEqQAUI7vQBKkAFqAAVoAJUgApQASpwAgoQ3E9gkGgiFaACVIAKUAEqQAWoABUguNMHqAAVoAJUgApQASpABajACShAcD+BQaKJVIAKUAEqQAWoABWgAlSA4L6iD7zoJc/erFgdq6ICVIAKHCjw1S9/kc9t+gUVoAJU4J4qwAWgc+AJ6Z3C8TYqQAVWV4Awv7qkrJAKUAEqcCcVILgHhoWwHhCLRakAFXgiChDin4jsbJQKUAEqcCsKENwdmQnrt+KHbIQKUIEjKECIP4KorJIKUAEq8AQVILgr4q8B7F/50hee4NCyaSpABZ4GBV78zEsXd4MAv1hCVkAFqAAVuBMKENybYegFdkL6nfBnGkEF7oUCvTBPgL8X7sFOUgEq8BQrQHCvBjcK7RFY///+1xeG7cVm2J6fD0NSfen5Mz11tPdY/713LRkruIp0f9Gz3FL307O5vl7+Pf9sqlC1+WYYHjzQdZXqRie2ZrdVZ5ErOs4PbobhptZa6LenY+kXYjeqgVdOakvTR7XfGUOrX5be0bGQyluaW/1J8wYdr9S/qe3nfcNLPMXn61GIJ7zD0rIgFaACVODOKUBwH4YhAuwIrP/2b31s2G43w3Z7PmzP098jsKe/HyS4jP4xoWECvRZ0czMT9O1B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";
	
    
    
    /**
    *
    *   The sprite sheet Img used for level select display, it is built from __levelSelectSpriteSheetString during setupLevelSelect if this property is null.
    * 
    * @memberof GameSkeleton
    * 
    *
    */
    GameSkeleton.prototype.__levelSelectSpriteSheet = null;
	GameSkeleton.prototype.__latestLevel = 1;
	GameSkeleton.prototype.__levelSelectDivs = [];
	GameSkeleton.prototype.addedInitializationMethodString = "setup";
	GameSkeleton.prototype.__titleScreenRect = null;
	GameSkeleton.prototype.__gameOverScreenRect = null;
	GameSkeleton.prototype.__lsShown = 0;
	
	/**
    *
    *   First call setupLevelSelect to setup everything.
    *
    *   Then this method pauses the game and shows the level select display, 
    *   if already displayed this method would hide the level select display.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method showLevelSelect
    * @param latestLevel {Number} The latest level that can be selected, default is 1.
    *
    */
	GameSkeleton.prototype.showLevelSelect = function(latestLevel) {
		
		if(this.__lsShown == 0) {
			this.__lsShown = 1;
			this.paused = 0;
			this.pause();
			latestLevel = latestLevel || this.__latestLevel;
			var ti = 0; var cplyr = null;
			var lsBackTo = new tabageos.MoverPoint(this.cameraWidth/2 - (352/2), this.gameHeight/2 - (240/2));
			if(GameSkeleton.game.screenOrganizer && GameSkeleton.game.screenOrganizer.currentScreen == 0) { //title
				ti = 1;
				cplyr = this.title.floor;
				this.title.floor.copyPixels(this.__levelSelectSpriteSheet, new tabageos.Rectangle(48,144,352,240), lsBackTo);
				this.removeStartButton();
				
			} else {
				ti = 0;this.__lsShown = 2;lsBackTo.x += this.camera.v.x; lsBackTo.y += this.camera.v.y;
				cplyr = this.charLayer;
				this.charLayer.copyPixels(this.__levelSelectSpriteSheet, new tabageos.Rectangle(48,144,352,240), lsBackTo);
			
				
				
			} 
			var i = 1;var xi = 1;var yi = 1;var lstrs;var col;var loff = 0;var row;
				
			for(i; i <= this._levelSelectAmount; i+=1) { 
				if(i == 10) { col = 0; } else if(i == 20) { col = 1; } else if (i == 30) { col = 2; } else { 
					col = Math.floor( (i / 10) ); 
				}
				if(col <0) {col=0;} 
				
				if(i == 10 || i == 20 || i == 30) {
					row = 9;
				} else {
					row = (i == 0 ? 0 : (i % 10) - 1);
					if(i >= 31) {
						row += 1;
					}
				}
				
				
				cplyr.copyPixels( this.__levelSelectSpriteSheet, new tabageos.Rectangle(416 + (row*32),176 + (col*48),32,48), new tabageos.MoverPoint(lsBackTo.x + 16 + (row*32), lsBackTo.y + 32 + (col*48) ) );
				
				if(!this.__levelSelectDivs[i]) {
					this.__levelSelectDivs[i] = document.createElement("div");
					this.__levelSelectDivs[i].setAttribute("style", "position:absolute;width:32px;height:32px;top:"+(lsBackTo.y + 32 + (col*48))+"px;left:"+(lsBackTo.x + 16 + (row*32))+"px;cursor:pointer");
					this.__levelSelectDivs[i].setAttribute("id", "l"+i);
					
				}
				
			}
			
			this.placeLevelSelectDivs(ti);
			return;
		
		} else {
			
			this.hideLevelSelect();
			
			
			this.__lsShown  = 0;
			return;
		}
		
		
			
			
		
		
	};
	
	/**
    *
    *   This method is automatically setup during showLevelSelect as a handler for each levels button.
    *   the display is cleared, sceneChanger.changeCurrentMap is called
    *   then onSelectLevel is called (which can be setup during construction as part of the specs Object)
    *   then BlitMath.specificPatternBlit is called with the sceneChanger currentMap, 
    *   then BlitMath.dispatchFunctionAssignments is called with the sceneChangeSpecifics string method name passed during setupLevelSelect, this is the name of the method used for sceneChangeSpecifics.
    *   the changeToMainCamera is called.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method _selectLevel
    * @param e {Event}
    *
    */
	GameSkeleton.prototype._selectLevel = function(e) {
		
		var lv = Number(e.target.id.replace("l",""));
		var ths = tabageos.GameSkeleton.game;
		ths.display.clearRect(0,0,ths.gameWidth,ths.gameHeight);
		ths.sceneChanger.currentScene = lv;
		ths.sceneChanger.changeCurrentMap(lv);
		if(ths.__lsShown) {
			
			ths.hideLevelSelect();
		}
		
		if(ths.onSelectLevel) {
			ths.onSelectLevel();
		}
		
		
		tabageos.BlitMath.specificPatternBlit(ths.display, ths._image, ths.sceneChanger.currentMap);//drawing of the level.
		tabageos.BlitMath.dispatchFunctionAssignments(ths,ths.addedInitializationMethodString,ths,ths.sceneChanger.currentMap,ths.tileWidth,ths.tileHeight);
		
		tabageos.GameSkeleton.game.changeToMainCamera();
		
		
	};
	/**
    *
    *   hides the level select display. This method is called by showLevelSelect if the level select display is already shown.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method hideLevelSelect
    * 
    *
    */
	GameSkeleton.prototype.hideLevelSelect = function() {
		var ti = 0;
		if(!this.title.div.contains(this.startButton)) { ti = 1;
			this.title.floor.copyPixels(this._image, this.__titleScreenRect, new tabageos.MoverPoint());
			this.title.div.appendChild(this.startButton);
		}
		this.removeLevelSelectDivs();
		this.__lsShown = 0;
		if(this.paused) {
			this.pause();
		}
	};
	
	/**
    *
    *   places each clickable/touchable level select div. This method is called as part of showLevelSelect.
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method placeLevelSelectDivs
    * @param ontitle {Boolean} If true the divs get added to title.div instead of container.
    *
    */
	GameSkeleton.prototype.placeLevelSelectDivs = function(ontitle) {
						
		var i = 1;var l = this.__levelSelectDivs.length;
		for(i;i<=l;i++) {
			
			if(ontitle && this.__levelSelectDivs[i] && !this.title.div.contains(this.__levelSelectDivs[i])) {
				this.__levelSelectDivs[i].removeEventListener("click", tabageos.GameSkeleton.game._selectLevel, false);
				this.__levelSelectDivs[i].addEventListener("click", tabageos.GameSkeleton.game._selectLevel, false);
				this.title.div.appendChild(this.__levelSelectDivs[i]);
			}
			
			if(!ontitle && this.__levelSelectDivs[i] && !this.container.contains(this.__levelSelectDivs[i])) {
				this.__levelSelectDivs[i].removeEventListener("click", tabageos.GameSkeleton.game._selectLevel, false);
				this.__levelSelectDivs[i].addEventListener("click", tabageos.GameSkeleton.game._selectLevel, false);
				this.container.appendChild(this.__levelSelectDivs[i]);
			}
			
		}
		
	};
	/**
    *
    *   removes each clickable/touchable level select div. This method is called as part of hideLevelSelect
    *
    * 
    * @memberof GameSkeleton.prototype
    * @method removeLevelSelectDivs
    * @param fromtitle {Boolean} Denotes if they are on the title screen or not
    *
    */
	GameSkeleton.prototype.removeLevelSelectDivs = function(fromtitle) {
	
		var i = 1;var l = this.__levelSelectDivs.length;
		for(i;i<=l;i++) {
			if(this.__levelSelectDivs[i] && this.title.div.contains(this.__levelSelectDivs[i])) {
				this.__levelSelectDivs[i].removeEventListener("click", tabageos.GameSkeleton.game._selectLevel, false);
				this.title.div.removeChild(this.__levelSelectDivs[i]);
			} else if(this.__levelSelectDivs[i] && this.container.contains(this.__levelSelectDivs[i])) {
				this.__levelSelectDivs[i].removeEventListener("click", tabageos.GameSkeleton.game._selectLevel, false);
				this.container.removeChild(this.__levelSelectDivs[i]);
			}
		
		}
		
	};
	
	

    
    
    
    
    
    
    /**
    *
    *
    * When either localSave or getLocalSaved are called and they fail, this property will be the error message.
    *
    * @memberof GameSkeleton
    * 
    *
    *
    */
    GameSkeleton.prototype.saveError = "";
	/**
    *
    *
    * Uses localStorage to save the data.
    * If the save fails, this method will return 0 and saveError will have any error message.
    *
    * @memberof GameSkeleton.prototype
    * @method localSave
    * @param saveName {String} The name to use for the localStorage item
    * @param saveData {String} The data to save.
    * 
    *
    *
    */
	GameSkeleton.prototype.localSave = function(saveName, saveData) {
		var ret = 1;
		try {
			
			window.localStorage.setItem(saveName, saveData);
			tabageos.GameSkeleton.game.saveError = "";
			
		} catch(e) {
			
			tabageos.GameSkeleton.game.saveError = e.message;
			ret = 0;
		}
		
		return ret;
	};
    /**
    *
    *
    * Get the data of a localStorage item. 
    * If it can't, this method will return 0 and saveError will have any error message.
    *
    * @memberof GameSkeleton.prototype
    * @method getLocalSaved
    * @param saveName {String} The name of the localStorage item
    * 
    * 
    *
    *
    */
	GameSkeleton.prototype.getLocalSaved = function(saveName) {
		var ret = -1;var str = "";
		try {
			ret = 1;
			str = window.localStorage.getItem(saveName);
			
		} catch(e) {
			
			tabageos.GameSkeleton.game.saveError = e.message;
			ret = 0;
		}
		return (ret === 0 ? ret : str);
		
	};
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    /** 
	*   
    *
	*    Creates _HUD and _playerHUD as html div elements,
	*    _HUD gets appended to the document body.
    *    _playerHUD gets appened to container. _playerHUD containes _healthBar and _scoreTextDisplay.
    *
    *    This method is automatically called as part of construction of a GameSkeleton.
    *
    *    Use the showHUD hideHUD removeHUD, showHealthBar hideHealthBar, showScoreText, hideScoreText and changeHUDBackgroundImage methods
    *     to manipulate the HUD and playerHUD.
    *
	* @memberof GameSkeleton.prototype 
	* @method createHud
    * 
	*/
    GameSkeleton.prototype.createHud = function() {

        var listnfr = tabageos.seekTouch() ? "touchstart" : "click";
        var gref = GameSkeleton.game;
			
        gref._HUD = document.createElement("div");
        gref._HUD.setAttribute("id", "headsUpDisplay");
        gref._HUD.setAttribute("style", "position:absolute; top:0px;width:160px;height:32px;z-index:999999999999999999999999999999999999999999999999999999999999999999999999999999999999;background: no-repeat url('data:image/png;base64,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'");

        document.body.appendChild(gref._HUD);
        gref.hPause = document.createElement("div");
        gref.hPause.setAttribute("style", "position:absolute;top:0px;left:0px;width:32px;height:32px;background:rgba(255,255,255,0.1)");
        gref._HUD.appendChild(gref.hPause);
        gref.hPause.addEventListener(listnfr, gref.pause, false);
        
        gref.hReset = document.createElement("div");
        gref.hReset.setAttribute("style", "position:absolute;top:0px;left:32px;width:32px;height:32px;background:rgba(255,255,255,0.1)");
        gref._HUD.appendChild(gref.hReset);
        gref.hReset.addEventListener(listnfr, gref.goBack, false);
        
        gref.hMute = document.createElement("div");
        gref.hMute.setAttribute("style", "position:absolute;top:0px;left:64px;width:32px;height:32px;background:rgba(255,255,255,0.1)");
        gref._HUD.appendChild(gref.hMute);
        gref.hMute.addEventListener(listnfr, gref.muteUnmute, false);
        
        gref.hExit = document.createElement("div");
        gref.hExit.setAttribute("style", "position:absolute;top:0px;left:96px;width:32px;height:32px;background:rgba(255,255,255,0.1)");
        gref._HUD.appendChild(gref.hExit);
        gref.hExit.addEventListener(listnfr, gref.hudExit, false);
        
        gref.hWalkthrough = document.createElement("div");
        gref.hWalkthrough.setAttribute("style", "position:absolute;top:0px;left:128px;width:32px;height:32px;background:rgba(255,255,255,0.1)");
        gref._HUD.appendChild(gref.hWalkthrough);
        gref.hWalkthrough.addEventListener(listnfr, gref.hudToWalkthrough, false);

		gref._playerHUD = document.createElement("div");
		gref._playerHUD.setAttribute("id", "playerStatDisplay");
        gref._playerHUD.setAttribute("style", "position:absolute; top:0px;width:"+(gref.cameraWidth)+"px;height:90px;z-index:999999999999999999999999999999999999999999999999999999999999999999999999999999999999;");
		gref._healthBar = document.createElement("div");
		gref._scoreTextDisplay = document.createElement("div");
		
		gref._playerHUD.appendChild(gref._healthBar);
		gref._playerHUD.appendChild(gref._scoreTextDisplay);
		
		this.container.appendChild(gref._playerHUD);

    };
	
	/** 
	*   
	*    Will be 1 if health bar is displayed.
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.healthBarIsDisplayed = 0;
	/** 
	*   
	*    Will be 1 if score text is displayed.
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.scoreTextIsDisplayed = 0;
    
    
    
    
    /** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype._playerHudParts = [0];
   
    
    GameSkeleton._volumeSliderFimg = null;
	GameSkeleton._volumeSliderBimg = null;	
	GameSkeleton._volumeSliderFront = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAQCAYAAACBSfjBAAAA00lEQVRYR2NkYGD4zzAKyA4BRg4evv+hwelYDVi9diZYfFQed/jAA9DLVRclELftvsyAHICj8tjDZzQAoTmM3AQyGoCUBqCmgMB/E/9UBmwxcGbjbHC2HpXHHT6MowFIWQIZDUAKcxjWALx19TLDzkNnGd5fPYc1C4/KI8IHIwBBgQMCuAJwVB41fFACEBY4uAJwVB4SeMjhAw5AQW0jBnc7Y5SGNHIKHJXHHT6jAcjAwEBJAhkNQGoFILbRBFgtDIqhUXnMEACFD+PocBbZI1lgjQDrfnmQJjfmSAAAAABJRU5ErkJggg==";
	GameSkeleton._volumeSliderBack = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAQCAYAAADpunr5AAABb0lEQVRYR+2YsUoDQRCG57oIEiLCYashQoKVIBYhjTaSNu/gQ+Ud0oqNNpJCBCu5gKK2ISAGEUx38l8yce8yE8ztlrPd7r93xf/NzuxOREQp2fBxIPL6uLJdTU9bR+I/7pOnbN103Z/Z99cSwE68lwXz52QsQpH0iAE0DnZzEF7ePsgFYLrsDwOAuaPLY3p/HVL3ZmsFAvSr8x/ar7ep2X9c6gZgccLLBhgAsPkcwUUIrvm8hyEYgEAAOLqLEDDXNKSqqFmrpfFhi6QImDwn2f9M1/0ZTadZvpeiHCcBA2lHOx0GwDPAGIAGwS2sUn0wAAEBrIOgFWcRwOD2gXpnJzS8vhNTkOl//rgnIAgAmIuhATA970/QFMTmagBMn5vv+hOkCLcvOuSaWwRguu4PAGg3IDzI/nUNNYPLByADwCu41EMM7wAD4AeAi2+pVgQDyDWCFhO+BQGQ6asOwJ9iEcaujZpx1o4WY2uTRa929C8sYfw+WfhqmQAAAABJRU5ErkJggg==";
	GameSkeleton._volumeSliderCords = {x:0,y:0};
	
    /** 
	*   
    *
	*   You can use this method after initVolumeSliderAnimation to change the volume slider position.
    *
	* @memberof GameSkeleton.prototype 
	* @method volumeSliderPosition
    * 
    * 
	*/
	GameSkeleton.prototype.volumeSliderPosition = function(x,y) {
		
		GameSkeleton._volumeSliderCords.x = x+1-1;
		GameSkeleton._volumeSliderCords.y = y+1-1;
		
	};
	GameSkeleton.prototype._volumeSliderAnimation = null;
	GameSkeleton.prototype._volumeSliderDiv = null;
	GameSkeleton._volumeSliderHandler = function(e) {
		
		var xoff = e.offsetX;
		
		if(xoff > 85) { 
			if(GameSkeleton.game._volumeSliderDiv && GameSkeleton.game.container.contains(GameSkeleton.game._volumeSliderDiv)) {
				GameSkeleton.game._volumeSliderDiv.removeEventListener("click", GameSkeleton._volumeSliderHandler);
				GameSkeleton.game.container.removeChild(GameSkeleton.game._volumeSliderDiv);
			}
			if(GameSkeleton.game._volumeSliderAnimation._canvas == GameSkeleton.game.charLayer) {
				GameSkeleton.game.charLayer.context.clearRect(0,0,GameSkeleton.game.gameWidth,GameSkeleton.game.gameHeight);
				GameSkeleton.game.callCamera(1);
			}
			
			GameSkeleton.game._doAlternate = 0;
			return;
		}
		
		if(xoff > 80) { xoff = 80; }
		if(xoff < 0) { xoff = 0; }
		GameSkeleton.game.soundSystem.changeVolume( (xoff/8)/10 );
		
	};
    
    
    
    
    /** 
	*   
    *
	*   Use this method to remove the volume slider after having called initVolumeSliderAnimation and volumeSliderLoop
    *
	* @memberof GameSkeleton.prototype 
	* @method removeVolumeSliderAnimation
    * 
    * 
	*/
	GameSkeleton.prototype.removeVolumeSliderAnimation = function() {
		
		if(GameSkeleton.game._volumeSliderDiv && GameSkeleton.game.container.contains(GameSkeleton.game._volumeSliderDiv)) {
			GameSkeleton.game._volumeSliderDiv.removeEventListener("click", GameSkeleton._volumeSliderHandler);
			GameSkeleton.game.container.removeChild(GameSkeleton.game._volumeSliderDiv);
		}
		
		
	};
	/** 
	*   
    *
	*   Call this to establish the volume slider.
    *   
    *
	* @memberof GameSkeleton.prototype 
	* @method initVolumeSliderAnimation
    * @param x {Number} the x position to place the volume slider
    * @param y {Number} the y position to place the volume slider
    * @param clayer {CanvasObject} the CanvasObject to draw the volume slider animation on.
    * @param nox {Boolean} To not show an x for closing the volume slider loop, default is false, an x is shown, if your showing the slider as part of a different screen, then you might not need the x.
    * 
	*/
	GameSkeleton.prototype.initVolumeSliderAnimation = function(x,y, clayer, nox) {
		var ths = GameSkeleton.game;
		if(GameSkeleton.game._volumeSliderDiv) {
			GameSkeleton._volumeSliderHandler({offsetX:90});
			GameSkeleton.game._volumeSliderAnimation = null;
		}
		if(!ths._volumeSliderAnimation) {
			GameSkeleton._volumeSliderBimg = new Image();
			GameSkeleton._volumeSliderBimg.src = GameSkeleton._volumeSliderBack;
			GameSkeleton._volumeSliderFimg = new Image();
			GameSkeleton._volumeSliderFimg.src = GameSkeleton._volumeSliderFront;
			var millis = 15 + 24 * 9 * 7 + 4 + Math.PI + 51;
			
			ths._volumeSliderAnimation = new tabageos.CanvasAnimation(GameSkeleton._volumeSliderBimg,clayer || ths.charLayer,new tabageos.Rectangle(0,0,(nox ? 80 : 96),16),0,0,(nox ? 80 : 96),16);
			ths._volumeSliderAnimation.nox = nox || 0 ;
		}
		ths.volumeSliderPosition(x,y);
		ths._volumeSliderAnimation.x= x;
		ths._volumeSliderAnimation.y= y;
		
	};
    
    
    /** 
	*   
    *
	*   Use this as a levelComplete method or call during a loop to show the volume slider control,
    *   after first calling initVolumeSliderAnimation once.
    *
	* @memberof GameSkeleton.prototype 
	* @method volumeSliderLoop
    * 
    * 
	*/
    GameSkeleton.prototype.volumeSliderLoop = function(ts) {
		
		var ths = GameSkeleton.game;
		if(ths.controller) {
			if(ths.controller.buttons.left) {ths.controller.buttons.left = 0;
				if(ths.soundSystem._globalVolume > 0.1) {
					ths.soundSystem.changeVolume(ths.soundSystem._globalVolume - .1);
				}
			}
			if(ths.controller.buttons.right) {ths.controller.buttons.right = 0;
				if(ths.soundSystem._globalVolume < .9) {
					ths.soundSystem.changeVolume(ths.soundSystem._globalVolume + .1);
				}	
			}
		}
		
		if(!GameSkeleton.game._volumeSliderDiv) {
			ths._volumeSliderDiv = document.createElement("div");
			ths._volumeSliderDiv.setAttribute("style", "cursor:pointer;position:absolute;top:"+GameSkeleton._volumeSliderCords.y+"px;left:"+GameSkeleton._volumeSliderCords.x+"px;width:96px;height:16px;z-index:9999999999999999999999999999999999999999999999999999999999999999999");
			ths._volumeSliderDiv.removeEventListener("click", GameSkeleton._volumeSliderHandler);
			ths._volumeSliderDiv.addEventListener("click", GameSkeleton._volumeSliderHandler);
			ths.container.appendChild(ths._volumeSliderDiv);
		} else if(!GameSkeleton.game.container.contains(ths._volumeSliderDiv)) {
			ths._volumeSliderDiv.setAttribute("style", "cursor:pointer;position:absolute;top:"+GameSkeleton._volumeSliderCords.y+"px;left:"+GameSkeleton._volumeSliderCords.x+"px;width:96px;height:16px;z-index:9999999999999999999999999999999999999999999999999999999999999999999");
			ths._volumeSliderDiv.removeEventListener("click", GameSkeleton._volumeSliderHandler);
			ths._volumeSliderDiv.addEventListener("click", GameSkeleton._volumeSliderHandler);
			ths.container.appendChild(ths._volumeSliderDiv);
		}
		
		if(!GameSkeleton.game._volumeSliderAnimation) { 
			GameSkeleton._volumeSliderBimg = new Image();
			GameSkeleton._volumeSliderBimg.src = GameSkeleton._volumeSliderBack;
			GameSkeleton._volumeSliderFimg = new Image();
			GameSkeleton._volumeSliderFimg.src = GameSkeleton._volumeSliderFront;
			var millis = 15 + 24 * 9 * 7 + 4 + Math.PI + 51;
			ths._volumeSliderAnimation = new tabageos.CanvasAnimation(GameSkeleton._volumeSliderBimg,ths.charLayer,new tabageos.Rectangle(0,0,96,16),0,0,96,16);
			ths._volumeSliderAnimation.x= GameSkeleton._volumeSliderCords.x +1-1;
			ths._volumeSliderAnimation.y= GameSkeleton._volumeSliderCords.y +1-1;
		}
		
		ths._volumeSliderAnimation._source = GameSkeleton._volumeSliderBimg;
		ths._volumeSliderAnimation.fromRect.width = ths._volumeSliderAnimation.nox ? 80 : 96;
		ths._volumeSliderAnimation.blit();
			
		ths._volumeSliderAnimation._source = GameSkeleton._volumeSliderFimg;
		ths._volumeSliderAnimation.fromRect.width = (GameSkeleton.game.soundSystem._globalVolume * 80);
		ths._volumeSliderAnimation.blit();
		
		//ths.pixelParagraph(GameSkeleton._volumeSliderCords.x,GameSkeleton._volumeSliderCords.y + 17,10,"Arrows to change.A to go back.");
		
		
		ths.callCamera(ts);
	};
    
    
    
    
	
	/** 
	*   
	*    Shows and styles the _healthBar. _healthBar is an html div element.
	*    
	* @memberof GameSkeleton.prototype 
	* @method showHealthBar
	* @param health {Number} The amount of health, also the width of the healthbar.
	* @param firstColor {String} an html color value
	* @param secondColor {String} am html color value
	* @param height {Number} the height of the health bar
    * @param replacementStyle {String} An optional style that would replace the default style, thereby the firstColor and secondColor and height params would not be used. Use this param to style the health bar yourself.
    * @param additionalStyle {String} A style that would be added to the default style.
    * 
	*/
    GameSkeleton.prototype.showHealthBar = function(health, firstColor, secondColor, height, replacementStyle, additionalStyle) {
		
		if(height && height > 80) { height = 80; }
		GameSkeleton.game._healthBar.setAttribute("style", replacementStyle || "position:absolute; top:0px;width:"+(health||100)+"px;height:"+(height||10)+"px;border:thin solid black;background:linear-gradient("+(firstColor||'red')+","+(secondColor||'#ffc8c8')+","+(firstColor||'red')+");"+additionalStyle);
		GameSkeleton.game.healthBarIsDisplayed = 1;
	};
	/** 
	*   
	*    Hides the health bar.
	*    
	* @memberof GameSkeleton.prototype 
	* @method hideHealthBar
	* 
    * 
	*/
	GameSkeleton.prototype.hideHealthBar = function() {
		GameSkeleton.game._healthBar.setAttribute("style", "display:none");
		GameSkeleton.game.healthBarIsDisplayed = 0;
	};
	/** 
	*   
	*    Shows and styles score text in the _scoreTextDisplay html div element.
	*    
	* @memberof GameSkeleton.prototype 
	* @method showScoreText
	* @param value {String}
	* @param topPosition {Number}
	* @param width {Number}
	* @param height {Number}
	* @param additionalStyle {String}
    * 
	*/
    GameSkeleton.prototype.showScoreText = function(value, topPosition, width, height,additionalStyle) {
		
		GameSkeleton.game._scoreTextDisplay.setAttribute("style", "position:absolute; top:"+(topPosition||0)+"px;width:"+(width||160)+"px;height:"+(height||70)+"px;"+additionalStyle);
		GameSkeleton.game._scoreTextDisplay.innerHTML = value + "";
		GameSkeleton.game.scoreTextIsDisplayed = 1;
	};
	/** 
	*   
	*    Hides score text.
	*    
	* @memberof GameSkeleton.prototype 
	* @method hideScoreText
    * 
	*/
	GameSkeleton.prototype.hideScoreText = function() {
		GameSkeleton.game._scoreTextDisplay.setAttribute("style", "display:none");
		GameSkeleton.game.scoreTextIsDisplayed = 0;
	};
	/** 
	*   
	*    Changes the HUD background image.
	*    
	* @memberof GameSkeleton.prototype 
	* @method changeHUDBackgroundImage
	* @param imageString {String} The base64 string of the image
    * 
	*/
    GameSkeleton.prototype.changeHUDBackgroundImage = function(imageString) {
		
		GameSkeleton.game._HUD.setAttribute("style", "position:absolute; top:0px;width:160px;height:32px;z-index:999999999999999999999999999999999999999999999999999999999999999999999999999999999999;background: no-repeat url('"+imageString+"')");

	};

	/** 
	*   
	*    After you call this method, escape can be pressed to reset position in scene.
    *    a transistion would happen and positionResetSpecifics would be called if it is defined.
	*    
	* @memberof GameSkeleton.prototype 
	* @method establishKeyEventsForReset
    * 
	*/
    GameSkeleton.prototype.establishKeyEventsForReset = function() {
		
		window.removeEventListener("keyup", this.reset, false);
		window.addEventListener("keyup", this.reset, false);
	};
	
	/** 
	*   
	*    Default is 32.
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.mouseMoveOffset = 32;
	/** 
	*   When setupMouseTouchHandle has been used, this MoverPoint will have the location of the mouse/touch.
	*    @type MoverPoint
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.mousePoint = null;
	/** 
	*   
	*    Sets up everything such that the mousePoint MoverPoint has the cords of where the game is being moved moused over or touched moved.
	*    If the handleMouseHeldDown param is true then also mouseIsDown will be available.
    *
	* @memberof GameSkeleton.prototype 
	* @method setupMouseTouchHandle
	* @param handleMouseHeldDown {Boolean} Default is false. If true then mouseIsDown will be set up, then if the game is being touched or clicked mouseIsDown would be 1.
    * 
	*/
    GameSkeleton.prototype.setupMouseTouchHandle = function(handleMouseHeldDown) {
		this.mousePoint = new tabageos.MoverPoint();
		this.container.removeEventListener("mousemove", this.handleMouseTouchMove, false);
		this.container.removeEventListener("touchmove", this.handleMouseTouchMove, false);
        this.container.addEventListener("mousemove", this.handleMouseTouchMove, false);
		this.container.addEventListener("touchmove", this.handleMouseTouchMove, false);
		
		this.container.removeEventListener("pointermove", this.handleMouseTouchMove, false);
       
		
		this.container.addEventListener("pointermove", this.handleMouseTouchMove, false);
		
		if(handleMouseHeldDown) {
			this.container.removeEventListener("mousedown", this.handleMouseDown, false);
			this.container.addEventListener("mousedown", this.handleMouseDown, false);
			this.container.removeEventListener("pointerdown", this.handleMouseDown, false);
			this.container.addEventListener("pointerdown", this.handleMouseDown, false);
			this.container.removeEventListener("pointerup", this.handleMouseUp, false);
			this.container.addEventListener("pointerup", this.handleMouseUp, false);
			this.container.removeEventListener("mouseup", this.handleMouseUp, false);
			this.container.addEventListener("mouseup", this.handleMouseUp, false);
		}
		
	};
    
    /** 
	*   
	*    Remove mouse/touch cord capture ability.
	*    
	* @memberof GameSkeleton.prototype 
	* @method takeDownMouseTouchHandle
    * 
	*/
    GameSkeleton.prototype.takeDownMouseTouchHandle = function() {
		
		this.container.removeEventListener("mousemove", this.handleMouseTouchMove, false);
		this.container.removeEventListener("touchmove", this.handleMouseTouchMove, false);
        
		this.container.removeEventListener("pointermove", this.handleMouseTouchMove, false);
       
		
			this.container.removeEventListener("mousedown", this.handleMouseDown, false);
			
			this.container.removeEventListener("pointerdown", this.handleMouseDown, false);
			
			this.container.removeEventListener("pointerup", this.handleMouseUp, false);
			
			this.container.removeEventListener("mouseup", this.handleMouseUp, false);
			
		
		
	};
    
	/** 
	*   
	*    Set up by the setupMouseTouchHandle method, handles mousemove, touchmove and pointermove down/up events.
    *   Calculates the cords of the touch/mousedown position, and puts them in mousePoint.x and mousePoint.y
	*    
	* @memberof GameSkeleton.prototype 
	* @method handleMouseTouchMove
	* @param e {Event}
    * 
	*/
    GameSkeleton.prototype.handleMouseTouchMove = function(e) {
       var dmrect = tabageos.GameSkeleton.game.container.getBoundingClientRect();
		//var dmrect = tabageos.GameSkeleton.game._scaleRectRef;
		
        if(e && e.targetTouches && e.targetTouches.length) {
            var i = 0;
            for (i; i < e.targetTouches.length; i++) {
                var touches = e.targetTouches[i];
                var tx = touches.pageX;
                var ty = touches.pageY;
                tabageos.GameSkeleton.game.mousePoint.x = tx - dmrect.x + tabageos.GameSkeleton.game.camera.v.x - tabageos.GameSkeleton.game.mouseMoveOffset;  
                tabageos.GameSkeleton.game.mousePoint.y = ty - dmrect.y + tabageos.GameSkeleton.game.camera.v.y - tabageos.GameSkeleton.game.mouseMoveOffset;
            }
        } else {
 
            var upmp = tabageos.MouseController.mouseMoverPoint();
            tabageos.GameSkeleton.game.mousePoint.x = upmp.x - dmrect.x + tabageos.GameSkeleton.game.camera.v.x - tabageos.GameSkeleton.game.mouseMoveOffset;
			tabageos.GameSkeleton.game.mousePoint.y = upmp.y - dmrect.y + tabageos.GameSkeleton.game.camera.v.y - tabageos.GameSkeleton.game.mouseMoveOffset;
			
        }
    };
	/** 
	*   
	*    If setupMouseTouchHandle has been called with 1 as a param, this property denotes if the mouse/touch is being held down or not.
	*    
	* @memberof GameSkeleton
	*  
	*/
    GameSkeleton.prototype.mouseIsDown = 0;
	/** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton.prototype 
	* @method handleMouseDown
	* @param e 
    * 
	*/
    GameSkeleton.prototype.handleMouseDown = function(e) {
		
		tabageos.GameSkeleton.game.mouseIsDown = 1;
		
	};
	/** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton.prototype 
	* @method handleMouseUp
	* @param e 
    * 
	*/
    GameSkeleton.prototype.handleMouseUp = function(e) {
		
		tabageos.GameSkeleton.game.mouseIsDown = 0;
		
	};
	
	/** 
	*   
	*    This method is automatically called as part of consctruction of the class.
	*    
	* @memberof GameSkeleton.prototype 
	* @method basicInitialize
	* @param containerDivId {String}
	* @param rootDivId {String}
	* @param displayWidth {Number}
	* @param displayHeight {Number}
	* @param cameraWidth {Number}
	* @param cameraHeight {Number}
	* @param controllerDivId {String}
	* @param useScreenOrganizer {Boolean}
	* @param startWidth {Number}
	* @param startHeight {Number}
	* @param dontUseSceneChanger {Number} 
	* @param justCreateController {Number}
    *  
	*/
    GameSkeleton.prototype.basicInitialize = function(containerDivId, rootDivId, displayWidth,displayHeight, cameraWidth,cameraHeight, controllerDivId, useScreenOrganizer, startWidth,startHeight, dontUseSceneChanger, justCreateController) {
			//window.console.log("b ini");
			this.container = document.getElementById(containerDivId);
			this.root = useScreenOrganizer ? new tabageos.CanvasObjectContainer(rootDivId, cameraWidth,cameraHeight) : document.getElementById(rootDivId);
			
			this.cameraWidth = cameraWidth;
			this.cameraHeight = cameraHeight;
			this.frameTime = (1000/60) * (60 / this.frameRate ) - (1000/60) * 0.5;
			
			this.backgroundLayer = new tabageos.CanvasObject(null, displayWidth, displayHeight,0,0,GameSkeleton.game.disableBackgroundAlpha,0);
			
			this.backgroundLayer.drawRect(new tabageos.Rectangle(0,0,displayWidth, displayHeight), this.backgroundColor);
			if(displayWidth < 4000) {
				this.display = new tabageos.CanvasObject(null, displayWidth, displayHeight,0,0,0);
			} else {
				this.display = {"placeHolder":1};
			}
			
			this.charLayer = new tabageos.CanvasObject(null,displayWidth,displayHeight);
			this.cameraLayer = new tabageos.CanvasObject(null, cameraWidth, cameraHeight,0,0,1);
			if(!useScreenOrganizer) this.root.appendChild(this.cameraLayer.canvas);
			
			this.speechBubble = document.createElement("textarea");
			
			this.speechBubble.setAttribute("style", "background: #ffffffaa;border-radius:20px;width:250px;height:150px;position:absolute;border: thin solid black;display:none");
			//document.body.appendChild(this.speechBubble);
			
            if(controllerDivId && !this.controller) {
                this.controller = new tabageos.ControllerPad(justCreateController ? null : document.getElementById(controllerDivId));
                this.controller.establish( );
                if(!justCreateController) this.controller.basicControllerButtonSetup();
                this.controller.acceptWASDAndArrows();
               
                if(!justCreateController) this.controller.assignStartAndBackMethods("maybeStartGame", "maybeGoBack", GameSkeleton.game);
            }
			
            this.camera = new tabageos.BasicCamera(this.cameraLayer, this.backgroundLayer, this.display, this.charLayer);
            
			if(this.initForISO) {
				
				this.camera.viewPortWidth = cameraWidth;
				this.camera.viewPortHeight = cameraHeight;
			}
			
            if(displayWidth > cameraWidth) {
                this.camera.v.width = displayWidth - cameraWidth; 
            } else {
                this.camera.v.width = cameraWidth; 

            }
			
			this.camera.cameraFollowOffsetX = this.cameraFollowOffsetX;
			this.camera.cameraFollowOffsetY = this.cameraFollowOffsetY;

            this.camera.v.height = cameraHeight;
			
			this.cameraPoint = new tabageos.MoverPoint();
			GameSkeleton.game._doReset = 0;
			GameSkeleton.game._doAlternate = 0;
			GameSkeleton.game._endingLevel = 0;
			GameSkeleton.game.paused = 0;
			
			if(useScreenOrganizer) { 
				this.title = new tabageos.CanvasObjectContainer(null, cameraWidth,cameraHeight, null, "#ffffff");
				
				this.gameOverContainer = new tabageos.CanvasObjectContainer(null,cameraWidth,cameraHeight, null, "#ffffff"); 
				
				this.startButton = document.createElement("div");
				this.startButton.innerHTML = " Start ";
				var swid = startWidth || (cameraWidth/8); var shei = startHeight || (cameraHeight/8);
				this.startButton.setAttribute("style", "color:black;position:absolute;text-align:center;width:"+swid+"px;height:"+shei+"px;left:"+( this.startLocations ? this.startLocations.x : ((cameraWidth/2) - (swid/2)) )+"px;top:"+(this.startLocations ? this.startLocations.y : ((cameraHeight/2) - (shei/2) ))+"px;cursor:pointer;z-index:9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999");
				this.startButton.addEventListener((tabageos.seekTouch() ? (tabageos._pointerEvents ? "pointerdown" : "touchstart") : "mouseup"), GameSkeleton.game.changeToMainCamera, false);
				
				this.title.div.appendChild(this.startButton);
				
				this.screenOrganizer = new tabageos.IrisScreenOrganizer(this.root, [this.title, this.cameraLayer, this.gameOverContainer]);
				
				this.screenOrganizer.changeScreen(0);
				
				
				if(!dontUseSceneChanger) {
					this.sceneChanger = new tabageos.TileSceneChanger(this._image, this.display, this.gameWidth,this.gameHeight, this.tileWidth, this.tileHeight, this.player);
					
					
				}
			
			}

            this.createHud();
			if(!this.soundSystem) {//changes volume back to full when new
			
				this.soundSystem = new tabageos.SoundSystem();
			
			}
			this.useClintBlockFont();
			
			if(this.addedInitializationMethod) {   
				this.addedInitializationMethod(); 
				
				
				if(this.player && this.initialPlayerPosition) {  this.player.setX(this.initialPlayerPosition.x);  this.player.setY(this.initialPlayerPosition.y); }  
			
				if(this.sceneChanger) {
					
					if(this.player) {
						
						this.sceneChanger.mainChar = this.player;
						
					}
				}
            }
			this.title.floor.canvas.setAttribute("style","image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
			this.gameOverContainer.floor.canvas.setAttribute("style","image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
			
			if(this.horizontalCameraMove) {
				
				GameSkeleton.game.cameraPoint.x = -9999;
				
			}
			if(this.verticalCameraMove) {
				
				GameSkeleton.game.cameraPoint.y = -9999;
			}
			
			if(this.autoPause) {
				
				window.onblur = function(e) {
					if(!tabageos.GameSkeleton.game.paused) {
						tabageos.GameSkeleton.game.pause();
					}
					if(tabageos.GameSkeleton.game._mute == 0) {
						tabageos.GameSkeleton.game.muteUnmute();
					}
				};
				window.onfocus = function(e) {
					if(tabageos.GameSkeleton.game.paused) {
						tabageos.GameSkeleton.game.pause();
					}
					if(tabageos.GameSkeleton.game._mute == 1) {
						tabageos.GameSkeleton.game.muteUnmute();
					}
				};
			}
			
			
            if(!this.player) {
                window.console.log("a player has not been created, set this.player to some new Character Class");
            }
			
			if(!this.__worker) { 
				this.initWorkerLoop();
			}
			
	};
	/** 
	*   
	*    A see and chase routine for enemies, pass the enemy obj and other specs and the enemy will chase the player when it sees it.
    *    This routine is for platformers, for top down games simply use .chase and .update of a Traveler class.
	*    
	* @memberof GameSkeleton 
	*  @method seeAndChanseRoutine
    * @param obj {MapMover} The enemy that will chase the player
    * @param enemies {Array} optional, the Array containing obj and the other enemies, if passed, then obj will separate and align with the others in the array.
    * @param player {MoverSkeleton} the MoverSkeleton for obj to chase
    * @param helperPoint {MoverPoint} a premade MoverPoint to aid calculations, you can just pass this._helperPoint from the GameSkeleton Class.
    * @param chaseRadius {Number} The radius from player that obj must be to initiate chase, default is 128.
    * @param dontOnlyChaseToX {Boolean} default is false, by default obj will only chase the x position of player and will maintain its own y position.
    * @param separationDistance {Number} this distance to separate from other enemies found in the enemies Array, default is 48.
    * @param map {Array} optional 2D Array of tile values to collide with, values of 0 or [0,0] would be passable spots.
    * @param tw {Number} width of each tile in map, default is 16.
    * @param th {Number} height of each tile in map, default is 16.
	*/
	GameSkeleton.seeAndChaseRoutine = function(obj,enemies,player,helperPoint,chaseRadius, dontOnlyChaseToX, separationDistance, map,tw,th) {
		var blft,brght;
		
		if(map) {
            
            brght = tabageos.BlitMath.checkTileValueAt(obj.x + obj.width + 4,obj.y+obj.height+2,map,tw,th);
			blft = tabageos.BlitMath.checkTileValueAt(obj.x - 4,obj.y+obj.height+2,map,tw,th);
			
			blft = (blft[0] === 0 || blft[0]) ? (blft[0] == 0 && (!blft[1] || blft[1] == 0)) : (blft == 0);
			brght = (brght[0] === 0 || brght[0]) ? (brght[0] == 0 && (!brght[1] || brght[1] == 0)) : (brght == 0);
		}
		
		if(!obj._grounded && obj._jumps) { 
			obj._state = 3;obj._veloc.y = 4; 
		}
		
        if(obj._pRight || (map && brght)) { //collision detect and change direction
            obj.dX = obj._pLeft ? 0 : 1;
        } else if (obj._pLeft || (map && blft)) {
            obj.dX = 0;
        }
		if(tabageos.GeometricMath.testForPointInCircle(obj._pos,chaseRadius || (128),player._pos) && !obj._pRight && !obj._pLeft) {
			helperPoint.x = player.x+1-1; helperPoint.y = dontOnlyChaseToX ? player.y+1-1 : obj.y+1-1;
			obj.easeTo(helperPoint);
			obj.separationDistance = separationDistance || 48;
			if(enemies && enemies.length >=2) { obj.separate(enemies); obj.align(enemies); }
			if(!obj._pRight && !(map && brght && player.x > obj.x) && !obj._pLeft && !(map && blft && player.x < obj.x)) {
				obj.update(0,0,0);
			} else { if(obj.autoAnimation) obj.autoAnimation(); }
			if(obj.x < player.x) {
				obj.dX = 0;//opposite of ease direction
			} else if (obj.x > player.x + player.width) {
				obj.dX = 1; 
			}
			
		} else {
			if(obj._pRight || (map && brght)) {
				obj.dX = obj._pLeft ? 0 : 1;
			} else if (obj._pLeft || (map && blft)) {
				obj.dX = 0;
			}
			obj.move(obj.dX,obj.dX ? 0 : 1,0,0,0);
		}
		
	};
	
	
	/** 
	*   During basicInitialize this method is added as the start button handler of the controller.
    *    On the title screen, changeToMainCamera would be called.
    *     On the main game screen pause would get called.
    *    On the game over screen hudExit would get called.
	*    
	*    
	* @memberof GameSkeleton.prototype 
	* @method maybeStartGame
	* @param e 
    * 
	*/
    GameSkeleton.prototype.maybeStartGame = function(e) {
			
		if(tabageos.GameSkeleton.game.screenOrganizer.currentScreen === 0) {
			//title screen
			tabageos.GameSkeleton.game.changeToMainCamera(e);
		} 
		if(tabageos.GameSkeleton.game.screenOrganizer.currentScreen === 2) {
			//game over screen
			tabageos.GameSkeleton.game.hudExit();
		}
		if(tabageos.GameSkeleton.game.screenOrganizer.currentScreen === 1) {
			
			tabageos.GameSkeleton.game.pause(e);
		}
		
	};
	/** 
	*   
	*    During basicInitialize this method is added as the back button handler of the controller.
    *
    *       If the currentScreen of the screenOrganizer is the game over screen, then this method causes hudExit.
    *       If the currentScreen of the screenOrganizer is the main game screen, then this method causes goBack.
	*    
	* @memberof GameSkeleton.prototype 
	* @method maybeGoBack
	* @param e 
    * 
	*/
    GameSkeleton.prototype.maybeGoBack = function(e) {
		
		if(tabageos.GameSkeleton.game.screenOrganizer.currentScreen === 2) {
				//game over screen
			tabageos.GameSkeleton.game.hudExit();
		}
		if(tabageos.GameSkeleton.game.screenOrganizer.currentScreen === 1) {
			tabageos.GameSkeleton.game.goBack();
		}
		
	};
	
	
	/** 
	*   
	*    transitions to the main game screen and starts the main game loop.
    *    automatically called as part of a start button press from the title screen.
	*    
	* @memberof GameSkeleton.prototype 
	* @method changeToMainCamera
	* @param e 
    * 
	*/
    GameSkeleton.prototype.changeToMainCamera = function(e) {
		
		if(e) e.preventDefault();//
		GameSkeleton.game.startButton.removeEventListener((tabageos.seekTouch() ? "touchstart" : "mouseup"), GameSkeleton.game.changeToMainCamera, false);
		
		if(GameSkeleton.game.screenOrganizer) {
			GameSkeleton.game.screenOrganizer.addEventListener(tabageos.ScreenChangeEvent.COVER, "startGameLoop", GameSkeleton.game);
	
			GameSkeleton.game.screenOrganizer.switchScreen(1);
		} else { 
		
			GameSkeleton.game.startGameLoop();
		}
	
	};
	
	
	/** 
	*   
	*    Updates and resets the camera with optional offsets.
	*    
	* @memberof GameSkeleton.prototype 
	* @method updateAndResetCamera
	* @param horizontalOffset {Number}
	* @param verticalOffset {Number}
    * 
	*/
    GameSkeleton.prototype.updateAndResetCamera = function(horizontalOffset,verticalOffset) {
		if(horizontalOffset) {
			this.sceneChanger._cameraPoint.x = Math.round(this.player.x) + horizontalOffset;
			this.sceneChanger._cameraPoint.y = Math.round(this.player.y) -  this.camera.cameraFollowOffsetY;
			
			this.camera.reset( this.camera.width,this.camera.v.y );
			this.camera.tweenedBlitLayerRender(this.sceneChanger._cameraPoint, 0,0,16,"Linear",0,0);
		}
		if(verticalOffset) {
			this.sceneChanger._cameraPoint.x = Math.round(this.player.x) - this.camera.cameraFollowOffsetX;;
			this.sceneChanger._cameraPoint.y = Math.round(this.player.y) + verticalOffset;
			
			this.camera.reset( this.camera.v.x,this.camera.height );
			this.camera.tweenedBlitLayerRender(this.sceneChanger._cameraPoint, 0,0,16,"Linear",0,0);
			
		}
		
	};
	
	
	/** 
	*   
	*    Used to change the current set of enemy Objects being referenced.
    *   For example enemies = this.changeSceneEnemies(scene); would make enemies point to the array in the sceneChanger for the given scene.
	*    
	* @memberof GameSkeleton.prototype 
	* @method changeSceneEnemies
	* @param scene {Number} The number of the scene to get.
    * @returns {Array} The enemy Array in the sceneChanger referenced by the scene number
	*/
    GameSkeleton.prototype.changeSceneEnemies = function(scene) {
            
			var storedEnemies = this.sceneChanger.getEnemyArray(scene);
			var obj;var i = 0;var  tl;var enemyArray;
			if(storedEnemies) {
				enemyArray = storedEnemies; 
				
				this.updateEnemyMaps(enemyArray);
			} else {
				this.sceneChanger.addEnemyArray([], scene);
				storedEnemies = this.sceneChanger.getEnemyArray(scene);
				enemyArray = storedEnemies;
			}
			return enemyArray;
	};
	/** 
	*   
	*    Used to change the current set of SceneryObjects being referenced.
    *   For example sceneryObjects = this.changeSceneScenery(scene); would make sceneryObjects point to the array in the sceneChanger for the given scene.
	*    
	* @memberof GameSkeleton.prototype 
	* @method changeSceneScenery
	* @param scene {Number} The number of the scene to get.
    * @returns {Array} The stored Array in the sceneChanger referenced by the scene number
	*/
    GameSkeleton.prototype.changeSceneScenery = function(scene) {
		
		var storedScenery = this.sceneChanger.getStoredArray(scene);
            var sceneryArray;
			if(storedScenery) {
				sceneryArray = storedScenery;
			} else {
				this.sceneChanger.addStoredArray([], scene);
				storedScenery = this.sceneChanger.getStoredArray(scene);
				sceneryArray = storedScenery;
			}
			return sceneryArray;
	};
	
	
	/** 
	*   Update each _map property in the Array of MapMovers given to match this.player._map
	*    
	*    
	* @memberof GameSkeleton.prototype 
	* @method updateEnemyMaps
	* @param enemies {Array} An Array of MapMovers
    * 
	*/
    GameSkeleton.prototype.updateEnemyMaps = function(enemies) {
            var i = 0;var en;
            for(i;i<enemies.length;i++) {
				en = enemies[i];
				en._map = this.player._map;
            }
    };
	
	/** 
	*   
	*    Update each _map property in the Array of SceneryObject given to match this.player._map
	*    
	* @memberof GameSkeleton.prototype 
	* @method updateSceneryObjectMaps
	* @param sceneryObjects {Array} An Array of SceneryObjects
    * 
	*/
	GameSkeleton.prototype.updateSceneryObjectMaps = function(sceneryObjects) {
            var i = 0;var sco;
            for(i;i<sceneryObjects.length;i++) {
				sco = sceneryObjects[i];
				sco._map = this.player._map;
            }
    };
	
	/** 
	*   starts the main game loop, this method is automatically setup as part of what happens when the start button is pressed from the title screen.
    *   typically you don't need to call it manually. Use the beforeStartGameLoop construction specs param to define a method that would happen just before the main loop starts.
	*    
	*    
	* @memberof GameSkeleton.prototype 
	* @method startGameLoop
	* @param gameFunc {Function} If gameLoop has not been defined in specs during construction and a method is passed for this param, then it will become gameFunction. Otherwise gameLoop passed in the specs Object becomes gameFunction.
    * 
	*/
    GameSkeleton.prototype.startGameLoop = function(gameFunc) {
		
		if(GameSkeleton.game.beforeStartGameLoop) {
			
			GameSkeleton.game.beforeStartGameLoop();
		}
		
		if(gameFunc && !this.gameFunction) {this.gameFunction = gameFunc};
		
		this.charLayer.canvas.setAttribute("style","image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
		this.cameraLayer.canvas.setAttribute("style", "image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
		if(this.display && this.display.canvas) {
			this.display.canvas.setAttribute("style", "image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
		}
		this.backgroundLayer.canvas.setAttribute("style", "image-rendering: -moz-crisp-edges;image-rendering: -webkit-crisp-edges;image-rendering: pixelated;image-rendering: crisp-edges;");
			
		if(!this.__worker) {
		
			if(this._aid) { window.cancelAnimationFrame(this._aid); }
			this._aid = window.requestAnimationFrame(this._loop);
		} else {
			
			this.__workLoop = 1;
			
		}
		
	};
	/** 
	*   
	*    Readys the camera for auto horizontal movement, call this to horizontally align the camera to the player for auto horizontal movement,
    *    auto horizontal movement is achieved by setting horizontalCameraMove to a number greater than 0.
    *    in your setup method you would call this method if you have also set horizontalCameraMove to greater than 0.
    *    the camera would align with the player based on cameraFollowOffsetX and continue to move horizontally based on the vale of horizontalCameraMove.
    *
    *    If you don't call this method then the camera may not be aligned with the player when it starts auto moving.
	*    
	* @memberof GameSkeleton.prototype 
	* @method readyHorizontalCameraMove
    * 
	*/
    GameSkeleton.prototype.readyHorizontalCameraMove = function() {
		
		this.cameraPoint.x = -9999;
	};
	/** 
	*   
	*    Readys the camera for auto vertical movement, call this to vertically align the camera to the player for auto vertical movement,
    *    auto vertical movement is achieved by setting verticalCameraMove to a number greater than 0.
    *    in your setup method you would call this method if you have also set verticalCameraMove to greater than 0.
    *    the camera would align with the player based on cameraFollowOffsetY and continue to move vertically based on the vale of verticalCameraMove.
    *
    *    If you don't call this method then the camera may not be vertically aligned with the player when it starts auto moving.
	*    
	* @memberof GameSkeleton.prototype 
	* @method readyVerticalCameraMove
    * 
	*/
    GameSkeleton.prototype.readyVerticalCameraMove = function() {
		
		this.cameraPoint.y = -9999;
	};
	
	/** 
	*   
	*    
	*    The horizontal tween limit for the camera
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.tweenLimitX = 0;
	/** 
	*   
	*    
	*    The vertical tween limit for the camera
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype.tweenLimitY = 0;
	
    /** 
	*   
	*    Change the main looping method from _loop to something else.
    *    The function passed would be the only method called during each cycle and no longer gameFunction.
    *    Use the restoreMainLoopMethod function to bring back gameFunction (called from _loop) as the main looping method.
    *
    *    
    *    This method is useful for making a title/options screen loop. 
    *    In your initializationSpecs method you would call this method to swith to a title screen loop method.
    *    and then in the beforeStartGame method call restoreMainLoopMethod.
    *
    *    
	*    
	* @memberof GameSkeleton.prototype 
	* @method changeMainLoopMethod
	* @param toThis {Function}
    * 
	*/
    GameSkeleton.prototype.changeMainLoopMethod = function(toThis) {
		
		
		GameSkeleton.game.__methodForWorker = toThis;
		
	};
    /** 
	*   
	*    Restore _loop as the main cycle, which in turn is calling your gameFunction defined during construction.
    *
    *
    *    
	* @see changeMainLoopMethod    
	* @memberof GameSkeleton.prototype 
	* @method restoreMainLoopMethod
	* 
    * 
	*/
	GameSkeleton.prototype.restoreMainLoopMethod = function() {
		
		GameSkeleton.game.__methodForWorker = GameSkeleton.game._loop;
		
	};
    
    
    
	/** 
	*   
	*    The main game loop, your specific game mechanics should be in gameFunction which is defined during construction as part of the specs Object.
	*    
	* @memberof GameSkeleton.prototype 
	* @method _loop
	* @param ts {Number}
    * 
	*/
    GameSkeleton.prototype._loop = function(ts) {
		GameSkeleton.game._ts = ts;
		if(GameSkeleton.game._thrott === 0) GameSkeleton.game._thrott = ts;
		if(!GameSkeleton.game.__worker) {GameSkeleton.game._pr = ts - GameSkeleton.game._thrott;}
			
			if( (!GameSkeleton.game.paused && GameSkeleton.game.__workLoop) || (!GameSkeleton.game.__workLoop && GameSkeleton.game._pr >= GameSkeleton.game.frameTime)) {
				
					if(!GameSkeleton.game.__workLoop && GameSkeleton.game.__methodForWorker && GameSkeleton.game.__methodForWorker != GameSkeleton.game._loop) {
						GameSkeleton.game.__methodForWorker(1);
						GameSkeleton.game._aid = window.requestAnimationFrame(GameSkeleton.game._loop);
						return;
					}
				
				
					if(GameSkeleton.game._textTime > 0) {
						GameSkeleton.game._textTime -= 33.3;
						if(GameSkeleton.game._textTime <= 0) {
							GameSkeleton.game.hideText();
							GameSkeleton.game._textTime = 0;
						}
					}
					
					if(GameSkeleton.game._doAlternate == 1 && GameSkeleton.game.alternateLoopMethod) {
						
						GameSkeleton.game.alternateLoopMethod(ts);
						GameSkeleton.game._thrott = ts;
						if(!GameSkeleton.game.paused && !GameSkeleton.game.__workLoop) {
							GameSkeleton.game._aid = window.requestAnimationFrame(GameSkeleton.game._loop);
						}
						return;
					}
					
					if(GameSkeleton.game._cameraType >= 1) {
						
						GameSkeleton.game.charLayer.context.clearRect(GameSkeleton.game.camera.v.x,GameSkeleton.game.camera.v.y,GameSkeleton.game.camera.v.width,GameSkeleton.game.camera.v.height);
					}
					var lsce;
					if(GameSkeleton.game.sceneChanger && GameSkeleton.game.player.x > ((GameSkeleton.game.gameWidth) - GameSkeleton.game.screenRightExitOffset) ) {
						
						lsce = GameSkeleton.game.sceneChanger.currentScene + 1; if (lsce > GameSkeleton.game.sceneChanger._totalScenes.length-1) lsce = 1;
						if(!GameSkeleton.game.sceneChanger._totalScenes[lsce]) lsce = GameSkeleton.game.sceneChanger.currentScene;
						if(GameSkeleton.game.priorToSceneChange) GameSkeleton.game.priorToSceneChange(lsce);
						GameSkeleton.game.sceneChanger.changeScene(0,1,GameSkeleton.game.camera,"sceneChangeSpecifics",GameSkeleton.game,0,0,1,0,GameSkeleton.game.frameTime, GameSkeleton.game._ts,GameSkeleton.game.cameraTweenType); 
						if(GameSkeleton.game.afterSceneChange) GameSkeleton.game.afterSceneChange(lsce);
						
						GameSkeleton.game.camera.renderB1();
						GameSkeleton.game.camera.renderB2();
					
					}
					if(GameSkeleton.game.sceneChanger && GameSkeleton.game.player.x <= ((GameSkeleton.game.tileWidth) - GameSkeleton.game.screenLeftExitOffset) ) {
						
						lsce = GameSkeleton.game.sceneChanger.currentScene - 1; if (lsce == 0) lsce = GameSkeleton.game.sceneChanger._totalScenes.length-1;
						if(!GameSkeleton.game.sceneChanger._totalScenes[lsce]) lsce = GameSkeleton.game.sceneChanger.currentScene;
						if(GameSkeleton.game.priorToSceneChange) GameSkeleton.game.priorToSceneChange(lsce);
						GameSkeleton.game.sceneChanger.changeScene(0,0,GameSkeleton.game.camera,"sceneChangeSpecifics",GameSkeleton.game,0,0,1,0,GameSkeleton.game.frameTime, GameSkeleton.game._ts,GameSkeleton.game.cameraTweenType); 
						if(GameSkeleton.game.afterSceneChange) GameSkeleton.game.afterSceneChange(lsce);
						
						GameSkeleton.game.camera.renderB1();
						GameSkeleton.game.camera.renderB2();
					}
					
					
					if(GameSkeleton.game.topDownSceneChange && GameSkeleton.game.sceneChanger && GameSkeleton.game.player.y >= ((GameSkeleton.game.gameHeight) - GameSkeleton.game.screenDownExitOffset) ) {
						
						lsce = GameSkeleton.game.sceneChanger.currentScene + 1; if (lsce > GameSkeleton.game.sceneChanger._totalScenes.length-1) lsce = 1;
						if(!GameSkeleton.game.sceneChanger._totalScenes[lsce]) lsce = GameSkeleton.game.sceneChanger.currentScene;
						if(GameSkeleton.game.priorToSceneChange) GameSkeleton.game.priorToSceneChange(lsce);
						GameSkeleton.game.sceneChanger.changeScene(0,2,GameSkeleton.game.camera,"sceneChangeSpecifics",GameSkeleton.game,0,1,0,0,GameSkeleton.game.frameTime, GameSkeleton.game._ts,GameSkeleton.game.cameraTweenType); 
						if(GameSkeleton.game.afterSceneChange) GameSkeleton.game.afterSceneChange(lsce);
						
						GameSkeleton.game.camera.renderB1();
						GameSkeleton.game.camera.renderB2();
					
					}
					if(GameSkeleton.game.topDownSceneChange && GameSkeleton.game.sceneChanger && GameSkeleton.game.player.y <= (GameSkeleton.game.screenUpExitOffset)) {
						
						lsce = GameSkeleton.game.sceneChanger.currentScene - 1; if (lsce == 0) lsce = GameSkeleton.game.sceneChanger._totalScenes.length-1;
						if(!GameSkeleton.game.sceneChanger._totalScenes[lsce]) lsce = GameSkeleton.game.sceneChanger.currentScene;
						if(GameSkeleton.game.priorToSceneChange) GameSkeleton.game.priorToSceneChange(lsce);
						GameSkeleton.game.sceneChanger.changeScene(0,3,GameSkeleton.game.camera,"sceneChangeSpecifics",GameSkeleton.game,0,1,0,0,GameSkeleton.game.frameTime, GameSkeleton.game._ts,GameSkeleton.game.cameraTweenType); 
						if(GameSkeleton.game.afterSceneChange) GameSkeleton.game.afterSceneChange(lsce);
						
						GameSkeleton.game.camera.renderB1();
						GameSkeleton.game.camera.renderB2();
					}
					
					GameSkeleton.game.gameFunction();
					
					if(GameSkeleton.game._cameraType === 2) {
						GameSkeleton.game.camera.justRender();
						if(GameSkeleton.game._shakesToInclude) {
							GameSkeleton.game.camera.executeShake();
							GameSkeleton.game._shakesToInclude -= 1;
						}
					}
					
					if(GameSkeleton.game._cameraType === 1) {
						
						if(GameSkeleton.game.horizontalCameraMove) { 
							if(GameSkeleton.game.cameraPoint.x == -9999) {
								GameSkeleton.game.cameraPoint.x = (Math.round(GameSkeleton.game.player.x) - GameSkeleton.game.cameraFollowOffsetX) + (GameSkeleton.game.gameWidth/10);
							}
							GameSkeleton.game.cameraPoint.y = Math.round(GameSkeleton.game.player.y) - GameSkeleton.game.cameraFollowOffsetY;
							GameSkeleton.game.cameraPoint.x += GameSkeleton.game.horizontalCameraMove;
							
							
						} else if (GameSkeleton.game.verticalCameraMove) {
							if(GameSkeleton.game.cameraPoint.y == -9999) {
								GameSkeleton.game.cameraPoint.y = (Math.round(GameSkeleton.game.player.y) - GameSkeleton.game.cameraFollowOffsetY) - (GameSkeleton.game.gameHeight/10);
							}
							GameSkeleton.game.cameraPoint.y -= GameSkeleton.game.verticalCameraMove;
							GameSkeleton.game.cameraPoint.x = Math.round(GameSkeleton.game.player.x) - GameSkeleton.game.cameraFollowOffsetX;
							
						} else { 
							
							GameSkeleton.game.cameraPoint.x = Math.round(GameSkeleton.game.player.x) - GameSkeleton.game.cameraFollowOffsetX; 
							GameSkeleton.game.cameraPoint.y = Math.round(GameSkeleton.game.player.y)- GameSkeleton.game.cameraFollowOffsetY;
						
						}					
						
						GameSkeleton.game.camera.tweenedBlitLayerRender(GameSkeleton.game.cameraPoint, GameSkeleton.game.tweenLimitX || 0,GameSkeleton.game.tweenLimitY || 0, Math.round(GameSkeleton.game.frameTime / GameSkeleton.game._ts),GameSkeleton.game.cameraTweenType,0,0);
					}
					
					if(GameSkeleton.game._doLights) {
						
						GameSkeleton.game._actualApplyLights();
						
					}
					
					GameSkeleton.game._thrott = ts;
					
					if(!GameSkeleton.game.controller.gamePadButtonsUserDefined && GameSkeleton.game.enableGamePad) {
					   
						//window.console.log("hmmm");
					   GameSkeleton.game.controller.configureGamePadButtons();
					  
					} else if(GameSkeleton.game.enableGamePad && GameSkeleton.game.controller.gamePadButtonsUserDefined) {
						
						GameSkeleton.game.controller.handleGamePad();
						
					}

			} else {
				GameSkeleton.game._thrott = ts;
				
			}
			if(GameSkeleton.game._doReset === 1) {
				return;
			}
			

			if(!GameSkeleton.game.paused && !GameSkeleton.game.__workLoop) {
				if(!GameSkeleton.game.__worker) { 
					GameSkeleton.game._aid = window.requestAnimationFrame(GameSkeleton.game._loop);
				}
			}
	};
	/** 
	*   
	*    Makes one call to the camera to re render to the screen,
    *    for use after reseting the camera.
	*    
	* @memberof GameSkeleton.prototype 
	* @method callCamera
	* @param [ts] {Number} optional delta time
    * @param [pxoffset] {Number} optional added horizontal offset for the cameraPoint
    * @param [pyoffset] {Number} optional added vertical offset for the cameraPoint
    * @param [playerPosition] {MoverPoint} If present will first reset the camera around the player position.
	*/
    GameSkeleton.prototype.callCamera = function( ts, pxoffset, pyoffset, playerPosition ) {
		GameSkeleton.game.cameraPoint.x = (Math.round(GameSkeleton.game.player.x ) - GameSkeleton.game.cameraFollowOffsetX)+ (pxoffset); 
		GameSkeleton.game.cameraPoint.y = (Math.round(GameSkeleton.game.player.y ) - GameSkeleton.game.cameraFollowOffsetY)+ (pyoffset);
		var gm = GameSkeleton.game;
		if(playerPosition) {
			var ry = playerPosition.y < gm.camera.v.y ? 0 : gm.camera.v.y;
			var rx = playerPosition.x < gm.camera.v.x ? 0 : gm.camera.v.x;
			rx = gm.camera.v.x + gm.cameraWidth < playerPosition.x ? gm.camera.v.x + (playerPosition.x - (gm.camera.v.x + gm.cameraWidth)) + -(gm.cameraFollowOffsetX/(gm.tileWidth/2)) : rx;
			ry = gm.camera.v.y + (gm.cameraHeight/2) < playerPosition.y ? (playerPosition.y - -(gm.cameraFollowOffsetY*2)+gm.tileHeight+gm.tileHeight+gm.player.height+gm.tileHeight) : ry;
			gm.player.setX(playerPosition.x);
			gm.player.setY(playerPosition.y);
			
			gm.camera.reset(rx,ry);
			
		}
		
		GameSkeleton.game.camera.tweenedBlitLayerRender(GameSkeleton.game.cameraPoint, GameSkeleton.game.tweenLimitX || 0,GameSkeleton.game.tweenLimitY || 0, Math.round(GameSkeleton.game.frameTime / (ts||GameSkeleton.game._ts)),GameSkeleton.game.cameraTweenType,0,0);
		
	};
	
	/** 
	*   
	*    Cancels the animation frame.
	*    
	* @memberof GameSkeleton.prototype 
	* @method cancelAniFrame
    * 
	*/
    GameSkeleton.prototype.cancelAniFrame = function() {
		window.cancelAnimationFrame(GameSkeleton.game._aid);
	};
	
	/** 
	*   
	*    Pauses and unpauses the game.
	*    
	* @memberof GameSkeleton.prototype 
	* @method pause
	* @param e {Event}
    * 
	*/
    GameSkeleton.prototype.pause = function(e) {
        if(e) e.preventDefault();
       
		if(!GameSkeleton.game.screenOrganizer || (GameSkeleton.game.screenOrganizer && GameSkeleton.game.screenOrganizer.currentScreen == 1)) {
			if(!GameSkeleton.game.paused) {
				GameSkeleton.game.paused = 1;
				if(!GameSkeleton.game.__worker) {
					window.cancelAnimationFrame(GameSkeleton.game._aid);  
					GameSkeleton.game._aid = window.requestAnimationFrame(GameSkeleton.game._justGamePad);
				} else {
					GameSkeleton.game.__methodForWorker = GameSkeleton.game._justGamePad;
				}
			} else {
				GameSkeleton.game.paused = 0;
				if(!GameSkeleton.game.__worker) {
					window.cancelAnimationFrame(GameSkeleton.game._aid);  
					GameSkeleton.game._aid = window.requestAnimationFrame(GameSkeleton.game._loop);
				} else {
					GameSkeleton.game.__methodForWorker = GameSkeleton.game._loop;
				}
			}
		}
	};
    /** 
	*   
	*    A method that can happen as a loop alternate to enable gamePad use while the game is paused.
	*    
	* @memberof GameSkeleton.prototype 
	* @method _justGamePad
	* @param ts {Number}
    * 
	*/
    GameSkeleton.prototype._justGamePad = function(ts) {
    
        if(GameSkeleton.game._thrott === 0) GameSkeleton.game._thrott = ts;GameSkeleton.game._pr = ts - GameSkeleton.game._thrott;
		if(GameSkeleton.game.__worker || GameSkeleton.game._pr >= 15 ) {
			if(!GameSkeleton.game.controller.gamePadButtonsUserDefined && GameSkeleton.game.enableGamePad) {
				GameSkeleton.game.controller.configureGamePadButtons();
			} else if(GameSkeleton.game.controller.gamePadButtonsUserDefined && GameSkeleton.game.enableGamePad) {  
				GameSkeleton.game.controller.handleGamePad();
			}
			GameSkeleton.game._thrott = ts;
		}
		if(GameSkeleton.game.paused && !GameSkeleton.game.__worker) {
			
			window.cancelAnimationFrame(GameSkeleton.game._aid);  
			GameSkeleton.game._aid = window.requestAnimationFrame(GameSkeleton.game._justGamePad);
		}
	};
	/** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton 
	*  
	*/
	GameSkeleton.prototype._textTimeChosen = 0;
	/** 
	*   
	*    Shows html text in a textArea using the given parameters.
    *
    *
    *    For the most versatility, use the pixel font methods to display text.
    *
    *   This showText method exists for quick basic html text showing, to re-style it use the additionalCss param. 
	*    
	* @memberof GameSkeleton.prototype 
	* @method showText
	* @param text {String}
	* @param ttime {Number} The amount of time in millisecods to show the text, default is 4000
 	* @param tsz {Number} font size default is 16
	* @param wth {Number} width of the text area default is 44%
	* @param hgt {Number} height of the text area default is 44%
	* @param tp {Number} the top html css value default is 0
	* @param lft {Number} the left html css value default is 0
	* @param fontfamilyname {String} family name of the font to use
	* @param backgroundCss {String} Optional css for the background css property of the text area
    * @param additionalCss {String} any optional additional css for the text area
    * 
	*/
    GameSkeleton.prototype.showText = function(text, ttime, tsz, wth, hgt, tp, lft, fontfamilyname, backgroundCss, additionalCss) {
			
			if(!GameSkeleton.game.container.contains(GameSkeleton.game.speechBubble)) {
				GameSkeleton.game._textTime = ttime || 4000;
				GameSkeleton.game._textTimeChosen = GameSkeleton.game._textTime+1-1;
				GameSkeleton.game.speechBubble.setAttribute("style", (fontfamilyname ? "font-family:"+fontfamilyname : "")+";font-size:"+((tsz||16)/5)+"vmin; background: "+(backgroundCss || 'rgba(255,255,255,0.3)')+";text-align:center;border-radius:20px;width:"+(wth ? (wth+"px") : "75%")+";height:"+(hgt ? (hgt+"px") : "44%")+";position:absolute;border: thin solid black;top:"+(tp||0)+"px;left:"+(lft||0)+"px;"+(additionalCss||""));
			
				GameSkeleton.game.speechBubble.value = "\n"+ text.replace(/&#13/g, "\n");
				GameSkeleton.game.container.appendChild(GameSkeleton.game.speechBubble);
				GameSkeleton.game.textShown = 1;
			}
	};
	/** 
	*   
	*    Hide any text that was shown via showText
	*    
	* @memberof GameSkeleton.prototype 
	* @method hideText
    * 
	*/
    GameSkeleton.prototype.hideText = function() {
		
		if(GameSkeleton.game.container.contains(GameSkeleton.game.speechBubble)) {
			GameSkeleton.game.container.removeChild(GameSkeleton.game.speechBubble);
			GameSkeleton.game.textShown = 0;
		}
		
	};
    /** 
	*   
	*    Returns true if text is shown via showText.
	*    
	* @memberof GameSkeleton.prototype 
	* @method textIsShown
    * @returns {Boolean} 
	*/
	GameSkeleton.prototype.textIsShown = function() {
		
		return GameSkeleton.game.container.contains(GameSkeleton.game.speechBubble);
		
	};
	/** 
	*   
	*    
	*    @private
	* @memberof GameSkeleton 
	*  
	*/
	GameSkeleton.prototype.textShown = 0;
    /** 
	*   
	*    Returns true when text from showText is almost finished being shown.
	*    
	* @memberof GameSkeleton.prototype 
	* @method textFinished
    * @returns {Boolean}
	*/
	GameSkeleton.prototype.textFinished = function() {
		
		return GameSkeleton.game.container.contains(GameSkeleton.game.speechBubble) && GameSkeleton.game._textTime < Math.floor(GameSkeleton.game._textTimeChosen/4);
	};
    
    GameSkeleton.prototype._pixelTypeSpecs = {
		dialogBackImage:null,sourceImg:null,canvas:null,lineFromXp:0,lineFromYp:0,tw:10,th:10,space:8,  
		s33:0,s34:10,s35:20,s36:30,s37:40,s38:50,s39:60,s40:70,s41:80,s42:90,s43:100,s44:110,s45:120,s46:130,s47:140, 
		s58:250,s59:260,s60:270,s61:280,s62:290,s63:300,s64:310,  
		l0:150, l1:160,l2:170,l3:180,l4:190,l5:200,l6:210,l7:220,l8:230,l9:240,
		la:320,lb:330,lc:340,ld:350,le:360,lf:370,lg:380,lh:390,li:400,lj:410,lk:420,ll:430,lm:440,ln:450,lo:460,lp:470,
		lq:480,lr:490,ls:500,lt:510,lu:520,lv:530,lw:540,lx:550,ly:560,lz:570,
		ua:320,ub:330,uc:340,ud:350,ue:360,uf:370,ug:380,uh:390,ui:400,uj:410,uk:420,ul:430,um:440,un:450,uo:460,up:470,
		uq:480,ur:490,us:500,ut:510,uu:520,uv:530,uw:540,ux:550,uy:560,uz:570
	};
    /**
    *
    * Sets specs for the pixelType method.
    * 
    * see pixelType
    * 
    * 
    *
    * @param source {Img} The source image that has the pixel font line
    * @param canv {CanvasObject} The CanvasObject to draw to.
    * @param lineFromX {Number} The starting x position of the pixel font line in the source.
    * @param lineFromY {Number} The starting y position of the pixel font line in the source.
    * @param tw {Number} The width of each tile that each letter fits into.
    * @param th {Number} The height of each tile that each letter fits into.
    * @param spacing {Number} Spacing between each letter that will be typed.
    * @param font {Number} Default font to use, 1, 2 or 3. 1 for ClinBlock, 2 for OldSchool, 3 for GoodNeighbors.
    * @method setPixelTypingSpecs
    * @memberof GameSkeleton.prototype
    *
    */
	GameSkeleton.prototype.setPixelTypingSpecs = function(source,canv,lineFromX,lineFromY,tw,th,spacing, font) {
		if(!source) {
			source = new Image();
			if(font == 2) {
				source.src = GameSkeleton.game.__OldSchoolLine;
			}
			if(!font || font == 1) {
				source.src = GameSkeleton.game.__ClintBlockLine;
			}
			if(font == 3) {
				source.src = GameSkeleton.game.__GoodNeighborsLine;
			}
		}
		if(!GameSkeleton.game._pixelTypeSpecs.dialogBackImage) {
			GameSkeleton.game._pixelTypeSpecs.dialogBackImage = new Image();
			GameSkeleton.game._pixelTypeSpecs.dialogBackImage.src = GameSkeleton.game.__dialogBack;
		}
		GameSkeleton.game._pixelTypeSpecs.sourceImg = source;
		GameSkeleton.game._pixelTypeSpecs.canvas = canv;
		GameSkeleton.game._pixelTypeSpecs.lineFromXp = lineFromX || 0;
		GameSkeleton.game._pixelTypeSpecs.lineFromYp = lineFromY || 0;
		GameSkeleton.game._pixelTypeSpecs.tw = tw || 5;
		GameSkeleton.game._pixelTypeSpecs.th = th || 7;
		GameSkeleton.game._pixelTypeSpecs.space = spacing || 8;
	};
    /**
    *
    * Sets the default pixel font to the built in ClintBlock font.
    * see pixelType
    *
    *
    * @method useClintBlockFont
    * @memberof GameSkeleton.prototype
    *
    */
    GameSkeleton.prototype.useClintBlockFont = function(letterSpacing, canv) {
		this.setPixelTypingSpecs(null,canv || this.charLayer,0,0,10,10,letterSpacing || 7, 1);
		this.calibratePixelType(150,320,null,10,10);
	};
    /**
    *
    * Sets the default pixel font to the built in OldSchool font.
    * see pixelType
    *
    *
    * @method useOldSchoolFont
    * @memberof GameSkeleton.prototype
    *
    */
	GameSkeleton.prototype.useOldSchoolFont = function(letterSpacing, canv) {
		this.setPixelTypingSpecs(null,canv || this.charLayer,0,0,5,7,letterSpacing || 6, 2);
		this.calibratePixelType(75,320,160,5,7);
	};
    /**
    *
    * Sets the default pixel font to the built in GoodNeighbors font.
    * see pixelType
    *
    *
    * @method useGoodNeighborsFont
    * @memberof GameSkeleton.prototype
    *
    */
	GameSkeleton.prototype.useGoodNeighborsFont = function(letterSpacing, canv) {
		this.setPixelTypingSpecs(null,canv || this.charLayer,0,0,16,16,letterSpacing || 9, 3);
		this.calibratePixelType(240,1024,512,16,16);
	};
	GameSkeleton.prototype.__alphabet = {a0:"a",a1:"b",a2:"c",a3:"d",a4:"e",a5:"f",a6:"g",a7:"h",a8:"i",a9:"j",a10:"k",a11:"l",a12:"m",a13:"n",a14:"o",a15:"p",a16:"q",a17:"r",a18:"s",a19:"t",a20:"u",a21:"v",a22:"w",a23:"x",a24:"y",a25:"z"};
	
    
    /**
    *
    *
    * see pixelType
    *
    *
    * @method calibratePixelType
    * @memberof GameSkeleton.prototype
    *
    */
    GameSkeleton.prototype.calibratePixelType = function(zeroIsAtX, aIsAtX, uAIsAtX, tileWidth, tileHeight) {
		//calculate and store x position of each character in the line.
		var px = GameSkeleton.prototype._pixelTypeSpecs;
		var incer = 0;
		var i = 0;
		var l = 9;
		if(zeroIsAtX || zeroIsAtX === 0) {//numbers denoted by themselves after l
			for(i; i <= l; i++) {
				px["l"+i] = zeroIsAtX + (i*tileWidth);
			}
		}
		if(zeroIsAtX || zeroIsAtX === 0) {
			i = 58;//the few symbols after the numbers
			l = 64;//symbols denoted by charCode after s
			for(i; i <= l; i++) {		
				px["s"+i] = (zeroIsAtX + (incer*tileWidth)) + (tileWidth*10);
				incer++;
			}
		}
		i = 33;//the symbols before the numbers, at the start of the line.
		l = 47;
		incer = 0;
		for(i; i <=l; i++) {
			px["s"+i] = incer*tileWidth;
			incer++;
		}
		i = 0; l = 26;
		if(aIsAtX || aIsAtX === 0) {//alphabet denoted by the letter itself after l
			for(i; i < l; i++) {
				px[ "l"+GameSkeleton.prototype.__alphabet["a"+i] ] = aIsAtX + (i*tileWidth);
			}
		}
		i = 0; l = 26;
		if(uAIsAtX || uAIsAtX === 0) {//upper case denoted by u before lowercase of itself
			for(i; i < l; i++) {
				px[ "u"+GameSkeleton.prototype.__alphabet["a"+i] ] = uAIsAtX + (i*tileWidth);
			}
		}
		
	}; 
	/**
    *
    * Types pixel text. 
    * There are 3 pixel fonts built into the GameSkeleton Class; ClintBlock OldSchool and GoodNeighbors.
    * You can change which one is used by calling useClintBlockFont, useOldSchoolFont, or useGoodNeighborsFont.
    * By default ClintBlock is used.
    * 
    * Or you can use your own custom pixel font by including it as a line of text in your sprite sheet. (or you can load the line as an image and pass it in as the source)
    * The pixel font needs to be in one straight horizontal line in your sprite sheet, 
    * take note of the x,y start of the line, and the width and height of each tile that each letter is in,
    * the start of the numbers (0-9) from the beginning of the line, the start of the lower case letters (a-z) from the beginning of the line,
    * and the start of the upper case letters from the beginning of the line.
    *
    *  Then, first call calibratePixelType with the start of the numbers, and the starts of the letters, and the tile width and height.
    *   then you can call setPixelTypingSpecs to set all the specs this method, pixelType, will use, or you can keeping passing them into this methods call.
    *
    *       So, for example, lets say we have a line of pixel font in the sprite sheet and that line starts at position 500,500.
    *       And, lets say that each letter is spaced 8x8, 
    *        so our tile spacing when looking at the font in our image editor (like GIMP) is 8x8. 
    *       There are some other characters in the line before the number chacters most likely,
    *       we select from the beginning of the line up to the start of the zero, and the length of that selection is the start of the number characters.
    *       we select from the beginning of the line up to the start of the "a", and the length of that selection is the start of the lower case letter characters.
    *       we select from the beginning of the line up to the start of the "A", and the length of that selection is the start of the upper case letters.
    *
    *          And those are the values we need to set everything up; the x,y position of the font line in the sprite sheet
    *           the width/height of each character tile
    *           the start of the number characters, and the starts of the letter characters.
    *
    *       1. calibratePixelType(start of the number characters, start of lower case leetters, start of upper case letters, tile width, tile height)
    *                           for example (150,320,160,8,8)
    *                    [if any character set is not in your line, for example if there are no upper case, then you would put null for upper case, not 0]
    *       2. setPixelTypingSpecs(source, canvas, x position of the font line, y position of the font line, tile width, tile height, spacing)
    *   
    *           Then you can use this method, pixelType, with just the first three params, to type your custom pixel text.
    *                The cords being used to position the text are the full gameWidth and height.
    *
    *
    * @param x {Number} x position to type at
    * @param y {Number} y position to type at
    * @param alphaText {String} String of text to type.
    * @param source {Img} Source Img to draw from, the img that has the pixel font line. Can be defined for all calls using setPixelTypingSpecs. If the line is in the sprite sheet then this should be; this._image
    * @param canv {CanvasObject} The CanvasObject to draw to. Can be defined for all calls using setPixelTypingSpecs.
    * @param lineFromX {Number} The x position in the sprite sheet that the pixel font line begins. Can be defined for all calls using setPixelTypingSpecs.
    * @param lineFromY {Number} The y position in the sprite sheet that the pixel font line begins. Can be defined for all calls using setPixelTypingSpecs.
    * @param tw {Number} The width of each tile that each letter of the pixel font line fits into. Default is 10. Can be defined for all calls using setPixelTypingSpecs.
    * @param th {Number} The height of each tile that each letter of the pixel font line fits into. Default is 10. Can be defined for all calls using setPixelTypingSpecs.
    * @param spacing {Number} The amount of spacing in between each letter typed, default is 8. Can be defined for all calls using setPixelTypingSpecs.
    *
    * @method pixelType
    * 
    * @memberof GameSkeleton.prototype
    *
    */
	GameSkeleton.prototype.pixelType = function(x,y,alphaText,source,canv,lineFromX,lineFromY,tw,th,spacing,fw,fh) {
		
		var px = GameSkeleton.game._pixelTypeSpecs;
		var i = 0;
		var l = alphaText.length;
		GameSkeleton.game._helperPoint.x = x+1-1;
		GameSkeleton.game._helperPoint.y = y+1-1;
		var sp = spacing || px.space;
		
		for(i; i < l; i++) {
			
			var xSpot = px["l" +alphaText.charAt(i)] != undefined ?  px["l" +alphaText.charAt(i)] : (px["s" +alphaText.charCodeAt(i)] != undefined ? px["s" +alphaText.charCodeAt(i)] : px["u" +alphaText.charAt(i).toLowerCase()]) ;
			
			GameSkeleton.game._helperRect.x = (lineFromX || px.lineFromXp) +  xSpot; 
			GameSkeleton.game._helperRect.y = (lineFromY || px.lineFromYp);
			GameSkeleton.game._helperRect.width = (tw || px.tw);
			GameSkeleton.game._helperRect.height = (th || px.th);
			GameSkeleton.game._helperPoint.x = x + (i*sp);
			(canv || px.canvas).copyPixels(source || px.sourceImg, GameSkeleton.game._helperRect, GameSkeleton.game._helperPoint,fw || GameSkeleton.game._helperRect.width, fh || GameSkeleton.game._helperRect.height );
		}
		
	};
    /**
    *
    *
    *  
    *   Writes a paragraph of pixel text, each line in the paragraphTextByDots string should be denoted by a dot . 
    *
    * @param startX {Number} The starting x position to type from
    * @param startY {Number} The starting y position to type from
    * @param lineSpace {Number} The line space amount, default is 9
    * @param paragraphTextByDots {String} String of text with each line ending with a dot . 
    * @param canv {CanvasObject} The CanvasObject to draw on default will be charLayer
    * @param fw {Number} font text width, default is the same as the tile width of each letter
    * @param fh {Number} font text height, defaul is the same as the tile height of each letter
    *
    * @method pixelParagraph
    * @memberof GameSkeleton.prototype
    *
    */
	GameSkeleton.prototype.pixelParagraph = function(startX,startY,lineSpace,paragraphTextByDots,canv,fw,fh) {
		var pstr = paragraphTextByDots.split(".");
		var i = 0;
		var l = pstr.length;
		for(i;i<l;i++) {
			this.pixelType(startX,startY + (i*(lineSpace||9)), pstr[i], 0, canv, 0,0,0,0,0,fw,fh);
		}
	}; 
    GameSkeleton.prototype._pixli = 0;
    /**
    *
    *
    *   This method needs to be called repeatedly/during a loop to progress.
    *   Writes a paragraph of pixel text, letter by letter, each line in the paragraphTextByDots string should be denoted by a dot . 
    *
    * @param startX {Number} The starting x position to type from
    * @param startY {Number} The starting y position to type from
    * @param lineSpace {Number} The line space amount, default is 9
    * @param paragraphTextByDots {String} String of text with each line ending with a dot . 
    * @param canv {CanvasObject} The CanvasObject to draw on default will be charLayer
    * @param fw {Number} font text width, default is the same as the tile width of each letter
    * @param fh {Number} font text height, defaul is the same as the tile height of each letter
    * @param speed {Number} The speed at which to type each letter, default is 1, less than one will go slower, the value should not be 0 or negative.
    *
    * @method animatePixelParagraph
    * @memberof GameSkeleton.prototype
    *
    */
	GameSkeleton.prototype.animatePixelParagraph = function(startX,startY,lineSpace,paragraphTextByDots,canv,fw,fh,speed) {
		var pstr = paragraphTextByDots.split(".");
		var i = 0;
		var l = pstr.length;
		var letter = -1;
		var linesalready = 0;
		if(GameSkeleton.game._pixli > 0) {
			linesalready = GameSkeleton.game._pixli - 1;
			for(i;i<=linesalready;i++) {
				this.pixelType(startX,startY + (i*(lineSpace||9)), pstr[i],0, canv, 0,0,0,0,0,fw,fh);
			}
		}
		i = GameSkeleton.game._pixli;
		letter = this.animatePixelType(startX,startY + (i*(lineSpace||9)), pstr[i], speed,0, canv, 0,0,0,0,0,fw,fh);
		if(letter === 0) {
			GameSkeleton.game._pixli += 1;
		}
		if(GameSkeleton.game._pixli >= l) {
			GameSkeleton.game._pixli = 0;
		}
	}; 
     /**
    *
    *
    *   Displays a dialog box and text.
    *    This method does not position the text so that it is only with the bounds of the box, you will need to test and adjust the length of your sentences as needed.
    *    For large amounts of text the default ClintBlock font is most likely big, use the OldSchool font instead or a custom pixel font that is 5x5 or less.
    *   By default the dialog space available is 210x50. You can change that via the optional params.
    *   
    *   To have the dialog appear above everything be sure to call this method last in the loop.
    *   Or you can add a layer to the camera just for displaying text. If you use the display as the canv the dialog box will not be cleared.
    *   By default charLayer is used which means unless you keep calling this method or stop the loop, the dialog disapears on the next iteration of the game loop.
    *
    * @param dialog {String} The string to type, each new line should end with a dot .
    * @param dx {Number} The x position of the dialog box
    * @param dy {Number} The y position of the dialog box
    * @param tx {Number} The x position of the text
    * @param ty {Number} The y position of the text
    * @param lineSpace {Number} The line space amount, default is 9
    * @param animate {Boolean} If true then the text is displayed one letter at a time based on speed, and this method would need to be called repeatedly (called in a loop) to progress.
    * @param speed {Number} The speed at which to type each letter, default is 1, less than one will go slower, the value should not be 0 or negative.
    * 
    * @param fw {Number} font text width, default is the same as the tile width of each letter
    * @param fh {Number} font text height, defaul is the same as the tile height of each letter
    * @param canv {CanvasObject} The CanvasObject to draw on, default will be charLayer.
    * @param dialogBackFromRect {Rectangle} Optional Rectangle defining the location of your custom dialog background image in the source. By default a 210x50 paperish looking dialog background is used.
    * @param source {Image} Optional source image for the dialog background, if your using a custom background from the sprite sheet this param should be the sprite sheet; this._image.
    *
    * @method pixelDialogBox
    * @memberof GameSkeleton.prototype
    *
    */
    GameSkeleton.prototype.pixelDialogBox = function(dialog,dx,dy,tx,ty,lineSpace,animate,speed,fw,fh,canv,dialogBackFromRect,source) {
		
		if(dialogBackFromRect) {
			GameSkeleton.game._helperRect.x = dialogBackFromRect.x;
			GameSkeleton.game._helperRect.y = dialogBackFromRect.y;
			GameSkeleton.game._helperRect.width = dialogBackFromRect.width;
			GameSkeleton.game._helperRect.height = dialogBackFromRect.height;
		} else {
			GameSkeleton.game._helperRect.x = 0;
			GameSkeleton.game._helperRect.y = 0;
			GameSkeleton.game._helperRect.width = 210;
			GameSkeleton.game._helperRect.height = 50;
		}
		
		GameSkeleton.game._helperPoint.x = dx;
		GameSkeleton.game._helperPoint.y = dy;
		
		
		(canv || GameSkeleton.game.charLayer).copyPixels(source || GameSkeleton.game._pixelTypeSpecs.dialogBackImage,GameSkeleton.game._helperRect,GameSkeleton.game._helperPoint);
		
		if(!animate) {
			GameSkeleton.game.pixelParagraph(tx,ty,lineSpace,dialog,canv || GameSkeleton.game.charLayer,fw,fh);
		} else {
			GameSkeleton.game.animatePixelParagraph(tx,ty,lineSpace,dialog,canv || GameSkeleton.game.charLayer,fw,fh,speed);
		
		}
		
		
	};
    GameSkeleton.prototype._pixai = 0;
     /**
    *
    *
    *   This method needs to be called repeatedly/during a loop to progress.
    *   Writes pixel text, letter by letter.
    *
    * @param x {Number} The starting x position to type from
    * @param y {Number} The starting y position to type from
    * @param alphaText {String} String of text to type.
    * @param speed {Number} The speed at which to type each letter, default is 1, less than one will go slower, the value should not be 0 or negative.
    * 
    * @param source {Img} Source Img to draw from, the img that has the pixel font line. Can be defined for all calls using setPixelTypingSpecs. If the line is in the sprite sheet then this should be; this._image
    * @param canv {CanvasObject} The CanvasObject to draw to. Can be defined for all calls using setPixelTypingSpecs.
    * @param lineFromX {Number} The x position in the sprite sheet that the pixel font line begins. Can be defined for all calls using setPixelTypingSpecs.
    * @param lineFromY {Number} The y position in the sprite sheet that the pixel font line begins. Can be defined for all calls using setPixelTypingSpecs.
    * @param tw {Number} The width of each tile that each letter of the pixel font line fits into. Default is 10. Can be defined for all calls using setPixelTypingSpecs.
    * @param th {Number} The height of each tile that each letter of the pixel font line fits into. Default is 10. Can be defined for all calls using setPixelTypingSpecs.
    * @param spacing {Number} The amount of spacing in between each letter typed, default is 8. Can be defined for all calls using setPixelTypingSpecs.
    * @param fw {Number} The width of each letter, default is same as tw.
    * @param fh {Number} The height of each letter, default is same as th.
    *
    * @method animatePixelType
    * @memberof GameSkeleton.prototype
    * @return {Number} Returns the next character index to be typed or 0 when the alphaText is all typed.
    */
	GameSkeleton.prototype.animatePixelType = function(x,y,alphaText,speed,source,canv,lineFromX,lineFromY,tw,th,spacing,fw,fh) {
		
		var px = GameSkeleton.game._pixelTypeSpecs;
		var i = 0;//GameSkeleton.game._pixai;
		var l = alphaText.length;
		var letterthan = Math.round(GameSkeleton.game._pixai);
		GameSkeleton.game._helperPoint.x = x+1-1;
		GameSkeleton.game._helperPoint.y = y+1-1;
		var sp = spacing || px.space;
		
		for(i; i <= letterthan; i++) {
			
			var xSpot = px["l" +alphaText.charAt(i)] != undefined ?  px["l" +alphaText.charAt(i)] : (px["s" +alphaText.charCodeAt(i)] != undefined ? px["s" +alphaText.charCodeAt(i)] : px["u" +alphaText.charAt(i).toLowerCase()]) ;
			
			GameSkeleton.game._helperRect.x = (lineFromX || px.lineFromXp) +  xSpot; 
			GameSkeleton.game._helperRect.y = (lineFromY || px.lineFromYp);
			GameSkeleton.game._helperRect.width = (tw || px.tw);
			GameSkeleton.game._helperRect.height = (th || px.th);
			GameSkeleton.game._helperPoint.x = x + (i*sp);
			(canv || px.canvas).copyPixels(source || px.sourceImg, GameSkeleton.game._helperRect, GameSkeleton.game._helperPoint,fw || GameSkeleton.game._helperRect.width, fh || GameSkeleton.game._helperRect.height );
		}
	
		GameSkeleton.game._pixai += (speed || 1);
	
		if(GameSkeleton.game._pixai >= l) {
			GameSkeleton.game._pixai = 0;
		}
		return GameSkeleton.game._pixai;
		
		
	};
    
	GameSkeleton.prototype._setATimeO = 0;
	/** 
	*   
	*    Can be called when a level is complete, or to simply do something else using the main loop, it will switch the main loop to the levelCompleteMethod passed.
	*      
    *    To give back the loop to the game loop method you can set _doAlternate to 0, which would switch it back immediately.
    *    Or you can call endLevelComplete() which will show a transition and then set _doAlternate to 0 for you,
    *    potentially calling positionResetSpecifics, and then underCoverSpecifics, before the transition ends.
    *    Or you can pass a levelCompleteTime which will cause endLevelComplete to happen after that time.
    *
    *    If you want to sleep the main loop for a time, you would use this method with an empty levelCompleteMethod passed in,
    *   for example this.levelComplete(function(ts) {}, 7000); would cause the game to effectively pause for 7 seconds, afterward show transition and resume
    *
	* @memberof GameSkeleton.prototype 
	* @method levelComplete
	* @param levelCompleteMethod {Function} The function that should replace the main loop, ts time stamp will be passed to it.
	* @param levelCompleteTime {Number} Optional millisecond amount of time until main loop should resume, main loop will resume after this amount of time if set.
    * @param dontRunAlternate {Boolean} It true the alternate loop will run but void of the levelCompleteMethod, it would just be like a pause in the thread
    *                                       So if you set this to true and do not pass a levelCompleteTime, what happens is that the game effectively pauses,
    *                                       but you would need to call endLevelComplete to come out of it, or set _doAlternate to 0.    
    * 
	*/
    GameSkeleton.prototype.levelComplete = function(levelCompleteMethod, levelCompleteTime, dontRunAlternate) {
		if(levelCompleteTime && levelCompleteTime <= 1000 && levelCompleteMethod) {
			window.console.warn("levelCompleteMethod will not happen until 1000, so if levelCompleteTime is less than 1000, its like there is no levelCompleteMethod");
		}
		if(!GameSkeleton.game._endingLevel) { 
			if(levelCompleteMethod && !dontRunAlternate) { 
				GameSkeleton.game._doReset = 1;GameSkeleton.game.__workLoop = 0;
				GameSkeleton.game.reset({keyCode:399});
				GameSkeleton.game.alternateLoopMethod = levelCompleteMethod || null;
			} else { //window.console.log("do a");
				GameSkeleton.game._doAlternate = 1;
			}
			if(levelCompleteTime && !GameSkeleton.game._endingLevel && GameSkeleton.game._setATimeO == 0) {  GameSkeleton.game._setATimeO = 1;
				window.setTimeout( function() {GameSkeleton.game._setATimeO = 0;
					if(GameSkeleton.game._doAlternate && !GameSkeleton.game._endingLevel) {
						GameSkeleton.game._endingLevel =1;
						GameSkeleton.game.screenOrganizer.addEventListener(tabageos.ScreenChangeEvent.COVER, "_changeDoAlternate", GameSkeleton.game);
						GameSkeleton.game.screenOrganizer.changeScreen(1);
					}
				}, levelCompleteTime);
			}
		}
		return;
		
	};
	/** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton 
	*  
	*/
	GameSkeleton.prototype._transitionByDoorTo = 0;
	/** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype._endingLevel = 0;
	/** 
	*   
	*    Call this to finish and return from having called levelComplete
	*    A transition animation will happen then the main loop will start back.
    *
	* @memberof GameSkeleton.prototype 
	* @method endLevelComplete
	* @param e 
    * 
	*/
    GameSkeleton.prototype.endLevelComplete = function(e) {
		if(!GameSkeleton.game._endingLevel) {
			GameSkeleton.game._endingLevel =1;
			GameSkeleton.game.screenOrganizer.addEventListener(tabageos.ScreenChangeEvent.COVER, "_changeDoAlternate", GameSkeleton.game);
			GameSkeleton.game.screenOrganizer.changeScreen(1);
		}
		
	};
	/** 
	*   
	*    @private
	*    
	* @memberof GameSkeleton.prototype 
	* @method _changeDoAlternate
	* @param e 
    * 
	*/
    GameSkeleton.prototype._changeDoAlternate = function(e) {
		GameSkeleton.game.screenOrganizer.removeEventListener(tabageos.ScreenChangeEvent.COVER, "_changeDoAlternate", GameSkeleton.game);
		if(GameSkeleton.game.positionResetSpecifics) {
			GameSkeleton.game.positionResetSpecifics();
		}
		if(GameSkeleton.game.underCoverSpecifics) {
			GameSkeleton.game.underCoverSpecifics();
		}
		if(GameSkeleton.game._transitionByDoorTo) {
			if(GameSkeleton.game.priorToSceneChange) {GameSkeleton.game.priorToSceneChange(GameSkeleton.game._transitionByDoorTo);}
			GameSkeleton.game.sceneChanger.changeScene(0,0,GameSkeleton.game.camera,"sceneChangeSpecifics",GameSkeleton.game,GameSkeleton.game._transitionByDoorTo,0,0,0,GameSkeleton.game.frameTime, GameSkeleton.game._ts,GameSkeleton.game.cameraTweenType); 
			if(GameSkeleton.game.afterSceneChange) {GameSkeleton.game.afterSceneChange(GameSkeleton.game._transitionByDoorTo);}
						
			GameSkeleton.game.camera.renderB1();
			GameSkeleton.game.camera.renderB2();
			GameSkeleton.game._transitionByDoorTo = 0;
		}
		GameSkeleton.game._doAlternate = 0;
		GameSkeleton.game._endingLevel = 0;
		
	};
	/** 
	*   
	*    Can be called when the game is complete, which switches the main loop to the gameCompleteMethod passed.
	*    Same as levelComplete but with less options, this method will switch the main loop to the gameCompleteMethod after 1 second.
    *    One second is given to ensure that the main loop has finished, this method causes the main loop to complete first, ending the request for animation frames.
    *    So you don't need to put a return after the call to this method, but its ok if you do.
    *    If autoToTitleTime is set, then fullResetToTitle will be called after that time, it should be more than 1 second. 
    *   
	* @memberof GameSkeleton.prototype 
	* @method gameComplete
	* @param gameCompleteMethod {Function} The method to switch the main loop to. Will receive a ts time stamp param.
	* @param autoToTitleTime {Number} If set then after this amount of milliseconds the game will reset to title, needs to be more than 1000 if set.
    * 
	*/
    GameSkeleton.prototype.gameComplete = function(gameCompleteMethod, autoToTitleTime) {
		
		GameSkeleton.game._doReset = 1;GameSkeleton.game.__workLoop = 0;
		GameSkeleton.game.reset({keyCode:399});
		GameSkeleton.game.alternateLoopMethod = gameCompleteMethod || null;
		
		
		if(autoToTitleTime) {
			window.setTimeout( function() {
				GameSkeleton.game.__workLoop = 0;
				window.cancelAnimationFrame(GameSkeleton.game._aid);
				GameSkeleton.game.fullResetToTitle(0);
			}, autoToTitleTime);
		
		}
		
		return;
		
		
	};
	/** 
	*   This method is used as the alternate loop methoed when gameOver has been called with no lives
	*    when start is pressed it will fullResetToTitle
	*    
	* @memberof GameSkeleton.prototype 
	* @method waitForStart
	* @param ts {Number}
    * 
	*/
    GameSkeleton.prototype.waitForStart = function(ts) {
		if(this.controller.buttons.start) {
			
			this.controller.buttons.start = 0;
			GameSkeleton.game.fullResetToTitle(0);
			
		}
		
	};
	/** 
	*   
	*    Subtracts 1 lives, if lives remains the scene is reset, if no lives it switches to the gameOverContainer screen (2) and waits for the start button to be pressed.
	*    
	* @memberof GameSkeleton.prototype 
	* @method gameOver
	* @param onlyRestPositionOnLooseLife {Boolean}
	* @param waitTime {Number}
    * 
	*/
    GameSkeleton.prototype.gameOver = function(onlyRestPositionOnLooseLife, waitTime) { 
			if(this.lives > 1) {
				this.lives -= 1;
				GameSkeleton.game._doReset = 1;GameSkeleton.game.__workLoop = 0;
				GameSkeleton.game.reset({keyCode:onlyRestPositionOnLooseLife ? 82 : 299});
				
				
				return;
			} else {
				if(this.lives == 1) { this.lives = 0; 
				//this.lives = this._initLives+1-1;
				
					
					window.cancelAnimationFrame(GameSkeleton.game._aid);
					GameSkeleton.game._doReset = 1;GameSkeleton.game.__workLoop = 0;
					GameSkeleton.game.alternateLoopMethod = GameSkeleton.game.waitForStart;
					this.screenOrganizer.addEventListener(tabageos.ScreenChangeEvent.SCREEN_CHANGE, "endLevel", GameSkeleton.game);
					this.screenOrganizer.switchScreen(2);
					
					
					return;
				}
			}
	};
	/** 
	*   
	*    If the game is paused this method would cause a full reset to title.
    *    If the game is not paused this method causes a basic scene reset, leading to resetPosition being called.
	*    
	* @memberof GameSkeleton.prototype 
	* @method goBack
	* @param e 
    * 
	*/
    GameSkeleton.prototype.goBack = function(e) {
			if(e) e.preventDefault();
			
			if(!GameSkeleton.game.screenOrganizer || (GameSkeleton.game.screenOrganizer && GameSkeleton.game.screenOrganizer.currentScreen == 1)) {
				if(GameSkeleton.game.paused) {
					GameSkeleton.game.fullResetToTitle(0);
				} else {
					window.cancelAnimationFrame(GameSkeleton.game._aid);
					GameSkeleton.game.__workLoop = 0;
					GameSkeleton.game.reset({keyCode:82});
				}
			}
	};
	/** 
	*   
	*    Resets the game to the title screen.
	*    
	* @memberof GameSkeleton.prototype 
	* @method fullResetToTitle
	* @param e {Event}
    * 
	*/
    GameSkeleton.prototype.fullResetToTitle = function(e) {
		
		window.cancelAnimationFrame(GameSkeleton.game._aid);
		GameSkeleton.game._doReset = 1;
			GameSkeleton.game.__workLoop = 0;
		//window.setTimeout( function() {
			GameSkeleton.game._theReset();
		//}, 700); return;

	};
    
    
	
	/** 
	*   
	*    This methos is used internally by other methods to reset scene or position.
	*    
	* @memberof GameSkeleton.prototype 
	* @method reset
	* @param e {Event} A key event, or Object, with keyCode of 82, 299 or 399. 82 would reset position, 299 would reset the scene, and 399 would end the level.
    * 
	*/
    GameSkeleton.prototype.reset = function(e) {
			if (typeof e == 'undefined') e = window.event;
			
			if(e && e.keyCode == 82) {
				window.cancelAnimationFrame(GameSkeleton.game._aid);
				if(GameSkeleton.game.screenOrganizer) {
					GameSkeleton.game.screenOrganizer.addEventListener(tabageos.ScreenChangeEvent.COVER, "resetPosition", GameSkeleton.game);
					
					
					GameSkeleton.game.screenOrganizer.changeScreen(1);
				} else {
					GameSkeleton.game.resetPosition(0);
					
				}

				return;
			}
			
			if(e && e.keyCode == 299) {  
				window.cancelAnimationFrame(GameSkeleton.game._aid);
				if(GameSkeleton.game.sceneResetSpecifics) { GameSkeleton.game.sceneResetSpecifics(); }
				
			
				if(GameSkeleton.game.screenOrganizer) {
					GameSkeleton.game.screenOrganizer.addEventListener(tabageos.ScreenChangeEvent.COVER, "resetScene", GameSkeleton.game);
					
					
					GameSkeleton.game.screenOrganizer.changeScreen(1);
				} else {
					
					GameSkeleton.game.resetScene(0);
				}
				return;
			}
			
			if(e && e.keyCode == 399) {
				window.cancelAnimationFrame(GameSkeleton.game._aid);
				
				
			
				if(GameSkeleton.game.screenOrganizer) {
					
					
					
					
					GameSkeleton.game.endLevel(0);
				} else {
					
					GameSkeleton.game.endLevel(0);
				}
				return;
			}
			
			
			
	};
		
	/** 
	*   
	*    Potentially calls positionResetSpecifics if it has been set.
    *    Restarts the main loop.
	*    
	* @memberof GameSkeleton.prototype 
	* @method resetPosition
	* @param e 
    *  
	*/
    GameSkeleton.prototype.resetPosition = function(e) {
			//window.console.log("rp1");
			if(GameSkeleton.game.screenOrganizer) {
				GameSkeleton.game.screenOrganizer.removeEventListener(tabageos.ScreenChangeEvent.COVER, "resetPosition", GameSkeleton.game);
			}
			
			if(GameSkeleton.game.positionResetSpecifics) { //window.console.log("rp");
				GameSkeleton.game.positionResetSpecifics();
			} 
			
			window.setTimeout( function() { GameSkeleton.game._doReset = 0;
				if(GameSkeleton.game.__worker) {
					GameSkeleton.game.__workLoop = 1;
				} else {
					GameSkeleton.game._aid = window.requestAnimationFrame(GameSkeleton.game._loop);
				}
				
			}, 1000);
		
	};
		
		
		
	/** 
	*   
	*    Potentially calls positionResetSpecifics then additionSceneResetSpecifics, if they have been defined.
    *    Then restarts the main game loop after 1 second.
	*    
	* @memberof GameSkeleton.prototype 
	* @method resetScene
	* @param e 
    * 
	*/
    GameSkeleton.prototype.resetScene = function(e) {
		
			if(GameSkeleton.game.screenOrganizer) {
				GameSkeleton.game.screenOrganizer.removeEventListener(tabageos.ScreenChangeEvent.COVER, "resetScene", GameSkeleton.game);
			}
			
			if(GameSkeleton.game.positionResetSpecifics) {
				GameSkeleton.game.positionResetSpecifics();
			} 
			
			if(GameSkeleton.game.additionalSceneResetSpecifics) {
				GameSkeleton.game.additionalSceneResetSpecifics();
			}
			
			window.setTimeout( function() { GameSkeleton.game._doReset = 0; 
				if(GameSkeleton.game.__worker) {
					GameSkeleton.game.__workLoop = 1;
				} else {
					GameSkeleton.game._aid = window.requestAnimationFrame(GameSkeleton.game._loop);
				}
			}, 1000);
    };
	/** 
	*   
	*    
	*    You can call this method to go foward one scene.
    *     This method is using the sceneChanger.
    *
	* @memberof GameSkeleton.prototype 
	* @method moveForwardOneScene
    * 
	*/
	GameSkeleton.prototype.moveForwardOneScene = function() {
		
		
		var lsce = GameSkeleton.game.sceneChanger.currentScene + 1; if (lsce > GameSkeleton.game.sceneChanger._totalScenes.length-1) lsce = 1;
		if(!GameSkeleton.game.sceneChanger._totalScenes[lsce]) lsce = GameSkeleton.game.sceneChanger.currentScene;
		if(GameSkeleton.game.priorToSceneChange) GameSkeleton.game.priorToSceneChange(lsce);
		GameSkeleton.game.sceneChanger.changeScene(0,1,GameSkeleton.game.camera,"sceneChangeSpecifics",GameSkeleton.game,0,0,1,0,GameSkeleton.game.frameTime, GameSkeleton.game._ts,GameSkeleton.game.cameraTweenType); 
		if(GameSkeleton.game.afterSceneChange) GameSkeleton.game.afterSceneChange(lsce);
		
		GameSkeleton.game.camera.renderB1();
		GameSkeleton.game.camera.renderB2();
		
	};
	/** 
	*   
	*    You can call this method to go back to the previous scene, it would be like calling gotoSceneByDoor, but for just going back to whatever scene is previous.
    *   These move methods are working with the sceneChanger.
	*    
	* @memberof GameSkeleton.prototype 
	* @method moveBackOneScene
    *  
	*/
	GameSkeleton.prototype.moveBackOneScene = function() {
		
		var lsce = GameSkeleton.game.sceneChanger.currentScene - 1; if (lsce == 0) lsce = GameSkeleton.game.sceneChanger._totalScenes.length-1;
		if(!GameSkeleton.game.sceneChanger._totalScenes[lsce]) lsce = GameSkeleton.game.sceneChanger.currentScene;
		if(GameSkeleton.game.priorToSceneChange) GameSkeleton.game.priorToSceneChange(lsce);
		GameSkeleton.game.sceneChanger.changeScene(0,0,GameSkeleton.game.camera,"sceneChangeSpecifics",GameSkeleton.game,0,0,1,0,GameSkeleton.game.frameTime, GameSkeleton.game._ts,GameSkeleton.game.cameraTweenType); 
		if(GameSkeleton.game.afterSceneChange) GameSkeleton.game.afterSceneChange(lsce);
		
		GameSkeleton.game.camera.renderB1();
		GameSkeleton.game.camera.renderB2();
		
		
	};
	/** 
	*   
	*    Change to the scene previous to the current.   2 - 1.
	*      This method is using the sceneChanger.    
    *
	* @memberof GameSkeleton.prototype 
	* @method moveUpOneScene
    * 
	*/
	GameSkeleton.prototype.moveUpOneScene = function() {
		
		var lsce = GameSkeleton.game.sceneChanger.currentScene - 1; if (lsce == 0) lsce = GameSkeleton.game.sceneChanger._totalScenes.length-1;
		if(!GameSkeleton.game.sceneChanger._totalScenes[lsce]) lsce = GameSkeleton.game.sceneChanger.currentScene;
		if(GameSkeleton.game.priorToSceneChange) GameSkeleton.game.priorToSceneChange(lsce);
		GameSkeleton.game.sceneChanger.changeScene(0,3,GameSkeleton.game.camera,"sceneChangeSpecifics",GameSkeleton.game,0,1,0,0,GameSkeleton.game.frameTime, GameSkeleton.game._ts,GameSkeleton.game.cameraTweenType); 
		if(GameSkeleton.game.afterSceneChange) GameSkeleton.game.afterSceneChange(lsce);
			
		GameSkeleton.game.camera.renderB1();
		GameSkeleton.game.camera.renderB2();
		
	};
	/** 
	*   
	*    Change to the scene beyond the current scene. 2 + 1
	*      This method is using the sceneChanger.    
    *
	* @memberof GameSkeleton.prototype 
	* @method moveDownOneScene
    * 
	*/
	GameSkeleton.prototype.moveDownOneScene = function() {
		
		var lsce = GameSkeleton.game.sceneChanger.currentScene + 1; if (lsce > GameSkeleton.game.sceneChanger._totalScenes.length-1) lsce = 1;
		if(!GameSkeleton.game.sceneChanger._totalScenes[lsce]) lsce = GameSkeleton.game.sceneChanger.currentScene;
		if(GameSkeleton.game.priorToSceneChange) GameSkeleton.game.priorToSceneChange(lsce);
		GameSkeleton.game.sceneChanger.changeScene(0,2,GameSkeleton.game.camera,"sceneChangeSpecifics",GameSkeleton.game,0,1,0,0,GameSkeleton.game.frameTime, GameSkeleton.game._ts,GameSkeleton.game.cameraTweenType); 
		if(GameSkeleton.game.afterSceneChange) GameSkeleton.game.afterSceneChange(lsce);
		
		GameSkeleton.game.camera.renderB1();
		GameSkeleton.game.camera.renderB2();
		
	};
	/** 
	*   
	*    Goto a scene right away without any transition.
    *
    *      The order of optional calls that would happen from this method being called is:
    *        optional priorToSceneChange  if it has been set
    *          Then the sceneChanger changeScene method is called 
    *        then optional afterSceneChange  if it has been set
    *        then camera renderB1 and camera renderB2 to draw the scene.
	*  
    *       The difference between this method and transitionToSceneByDoor
    *       is that transitionToSceneByDoor does a transition first then calls the above methods as the transition ends.
    *  
	* @memberof GameSkeleton.prototype 
	* @method gotoSceneByDoor
	* @param sceneToGoTo {Number} The number of the scene to go to.
    * 
	*/
	GameSkeleton.prototype.gotoSceneByDoor = function(sceneToGoTo) {
		
		//lsce = GameSkeleton.game.sceneChanger.currentScene - 1; if (lsce == 0) lsce = GameSkeleton.game.sceneChanger._totalScenes.length-1;
					//if(!GameSkeleton.game.sceneChanger._totalScenes[lsce]) lsce = GameSkeleton.game.sceneChanger.currentScene;
					if(GameSkeleton.game.priorToSceneChange) GameSkeleton.game.priorToSceneChange(sceneToGoTo);
					GameSkeleton.game.sceneChanger.changeScene(0,0,GameSkeleton.game.camera,"sceneChangeSpecifics",GameSkeleton.game,sceneToGoTo,0,0,0,GameSkeleton.game.frameTime, GameSkeleton.game._ts,GameSkeleton.game.cameraTweenType); 
					if(GameSkeleton.game.afterSceneChange) GameSkeleton.game.afterSceneChange(sceneToGoTo);
					
					GameSkeleton.game.camera.renderB1();
					GameSkeleton.game.camera.renderB2();
		
		
	};
	/** 
	*   
	*    Will transition to the scene after a default 1000 milliseconds.
    *    To have something happen during transition set the priorToSceneChange / afterSceneChange methods.
	*    
	* @memberof GameSkeleton.prototype 
	* @method transitionToSceneByDoor
	* @param scene {Number} The scene number from the TileSceneHolder to transition to.
	* @param transitionTime {Number} Default is 1000, scene will change after this millisecond delay.
    * 
	*/
	GameSkeleton.prototype.transitionToSceneByDoor = function(scene, transitionTime) {
		
		this._transitionByDoorTo = scene;
		
		this.levelComplete(null, transitionTime || 1000);
		
	};
    
    /** 
	*   
	*    The amount of time in miliseconds that should pass before the game starts the next level after endLevel is called.
    * Default is 1000.
	*    
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype._endLevelTime = 1000;
    
	/** 
	*   
	*    To be called inside an alternate loop, use levelComplete to initate an alternate loop.
    *       Ends the alternate loop and restarts the main loop.
	*    
	* @memberof GameSkeleton.prototype 
	* @method endLevel
	* @param e 
    * 
	*/
    GameSkeleton.prototype.endLevel = function(e) {
			
			if(GameSkeleton.game.screenOrganizer) {
				GameSkeleton.game.screenOrganizer.removeEventListener(tabageos.ScreenChangeEvent.COVER, "endLevel", GameSkeleton.game);
				GameSkeleton.game.screenOrganizer.removeEventListener(tabageos.ScreenChangeEvent.SCREEN_CHANGE, "endLevel", GameSkeleton.game);
			}
			
			window.setTimeout( function() { GameSkeleton.game._doReset = 0;  GameSkeleton.game._doAlternate = 1;
				if(GameSkeleton.game.__worker) {
					GameSkeleton.game.__workLoop = 1;
				} else {
					GameSkeleton.game._aid = window.requestAnimationFrame(GameSkeleton.game._loop);
				}
			}, GameSkeleton.game._endLevelTime);
    };
	
	
    
    /** 
	*   
	*    Mutes or unmutes any sound/music playing.
    *    This method gets added as the event handler for the sound button in the hud.
	*    
	* @memberof GameSkeleton.prototype 
	* @method muteUnmute
    * @param e {Event}
	*/
    GameSkeleton.prototype.muteUnmute = function() {
		
		GameSkeleton.game._mute = GameSkeleton.game._mute ? 0 : 1;
			if(GameSkeleton.game._mute) { 
				GameSkeleton.game.soundSystem.stopMusic();//st
			} else {
				GameSkeleton.game.soundSystem.playMusic();
			}
		return GameSkeleton.game._mute +1-1;
    };
    
    
    /** 
	*   
	*    Loads and plays a sound.
	*    
	* @memberof GameSkeleton.prototype 
	* @method playSound
    * @param soundString {String} The name of the sound to play, by default it will play soundString".ogg", to change what type is loaded use the stype param
    * @param poolAmount {Number} The number of sounds to pool, if the sound is going to be a quick fire sound, like a bullet, then it needs to be pooled at least by 2 or 3.
    * @param [stype=".ogg"] {String} The type of sound file to load, default is '.ogg'.
	*/
    GameSkeleton.prototype.playSound = function(soundString, poolAmount, stype) {
		if(this.soundSystem._soundNames.indexOf(soundString) === -1) {
			this.soundSystem.addSound(soundString+(stype||".ogg"),soundString,1,poolAmount || 2);
		}
		
		if(!this._mute) {
			this.soundSystem.playSound(soundString, 1);
		}
	};
     /** 
	*   
	*    Loads and plays music. Quick sounds should be loaded and played with playSound.
    *     When called with different music the first track stops.
	*    
	* @memberof GameSkeleton.prototype 
	* @method playMusic
    * @param soundString {String} The name of the music track to play, by default it will play soundString".ogg", to change what type is loaded use the stype param.
    * @param [loop=1] {Number} To loop the track or not, default is 1, it loops by default.
    * @param [stype=".ogg"] {String} The type of music file to load, default is '.ogg'.
	*/
	GameSkeleton.prototype.playMusic = function(soundString, loop, stype) {
		this.soundSystem.clearMusicTracks();
		this.soundSystem.addMusic(soundString+(stype||".ogg"),1,loop === 0 || loop === -1 ? 0 : 1);
		if(!this._mute) {
			this.soundSystem.playMusic(0);
		}
	};
    
    
        
    /** 
	*   
	*    This method gets set up as the event handler for the x button in the hud.
	*      If not on the title screen will cause a reset to the title screen.    
    *
    *
	* @memberof GameSkeleton.prototype 
	* @method hudExit
	* @param e 
    * 
	*/
    GameSkeleton.prototype.hudExit = function(e) {

        if(e) e.preventDefault();
        if(GameSkeleton.game.screenOrganizer && GameSkeleton.game.screenOrganizer.currentScreen == 0) {
            
            //title screen.
        } else {
            GameSkeleton.game.paused = 1;
            window.cancelAnimationFrame(GameSkeleton.game._aid);
            GameSkeleton.game._doReset = 1;
            
            window.setTimeout( function() {
                GameSkeleton.game._theReset();
            }, 700);
        }

    };

    /** 
	*   
    *    This method gets set up as the event handler for the question mark in the hud.
	*    If walkthroughLink has been defined and includes 'http'
    *    then when the question mark in the hud is clicked/touched the link would open in a new tab.
	*    
	* @memberof GameSkeleton.prototype 
	* @method hudToWalkthrough
	* @param e 
    * 
	*/
    GameSkeleton.prototype.hudToWalkthrough = function(e) {

        if(e) e.preventDefault();
			if(GameSkeleton.game.walkthroughLink && GameSkeleton.game.walkthroughLink.indexOf("http") != -1) {
				window.open(GameSkeleton.game.walkthroughLink, "_blank");
			}

    };
		
	/** 
	*   
	*    A full reset of the whole game ending with a call to _reEstablish
    *
	*    
	* @memberof GameSkeleton.prototype 
	* @method _theReset
    * @param dontEstablish If true _reEstablsih will not be called, and so the method then acts as a destroy method. 
    *
    *
	*/
    GameSkeleton.prototype._theReset = function(dontEstablish) {
        
            GameSkeleton.game._doReset = 1;GameSkeleton.game.__workLoop = 0;
			if(GameSkeleton.game.__worker) {
				GameSkeleton.game.__worker.terminate();
				GameSkeleton.game.__worker = null;
			}
			window.cancelAnimationFrame(GameSkeleton.game._aid);
            window.removeEventListener("keyup", GameSkeleton.game.reset, false);
            
			if(GameSkeleton.game.fullResetSpecifics) {
				GameSkeleton.game.fullResetSpecifics();
            }
            
			this.hideScoreText();
			this.hideHealthBar();
			this.hideText();
			this.removeHUD();
			this.takeDownMouseTouchHandle();
           
			this.cameraLayer.context.clearRect(0,0,this.gameWidth,this.gameHeight);
			this.backgroundLayer = null;
			this.gameOverContainer = null;
			this.camera = null;this.cameraLayer = null;
			this.charLayer.context.clearRect(0,0,this.gameWidth,this.gameHeight);
			this.charLayer = null;
			if(this.display && this.display.context) {
				this.display.context.clearRect(0,0,this.gameWidth,this.gameHeight);
				this.display = null;
			}
			if(this.startButton && this.title.div.contains(this.startButton)) {
				this.title.div.removeChild(this.startButton);
			}
			this._thrott = 0;
			this.paused = 0;
			
			while(this.screenOrganizer && this.screenOrganizer.theGame.getNumChildren()) {
				
				this.screenOrganizer.theGame.removeChild(this.screenOrganizer.theGame.getChildAt(this.screenOrganizer.theGame.getNumChildren() - 1));
			}
			if(!this.screenOrganizer && this.root.contains(this.cameraLayer.canavs)) this.root.removeChild(this.cameraLayer.canvas);
			this.title = null;this.root = null;this.player = null;
			this.container = null; tabageos.ScreenOrganizer._instance = null;
			if(!dontEstablish) GameSkeleton.game._reEstablish(0);
			//window.location.reload();
			return;
	};
	
	/** 
	*   
	*    
	*    @private
	* @memberof GameSkeleton 
	*  
	*/
    GameSkeleton.prototype._scaleRectRef = null;
	/** 
	*   
	*     removes all HUD event listeners and removes the _HUD from the document body, and removes _playerHUD from container.
	*    
	* @memberof GameSkeleton.prototype 
	* @method removeHUD
    * 
	*/
    GameSkeleton.prototype.removeHUD = function() {
        var listnr = tabageos.seekTouch() ? "touchstart" : "click";
		if(GameSkeleton.game._HUD) {
			GameSkeleton.game.hExit.removeEventListener(listnr, GameSkeleton.game.hudExit, false);
			GameSkeleton.game.hPause.removeEventListener(listnr, GameSkeleton.game.pause, false);
			GameSkeleton.game.hMute.removeEventListener(listnr,GameSkeleton.game.muteUnmute, false);
			GameSkeleton.game.hWalkthrough.removeEventListener(listnr, GameSkeleton.game.hudToWalkthrough, false);
			GameSkeleton.game.hReset.removeEventListener(listnr, GameSkeleton.game.goBack, false);
			if(GameSkeleton.game._playerHUD) this.container.removeChild(GameSkeleton.game._playerHUD);
			document.body.removeChild(GameSkeleton.game._HUD);
		}
    };
	
	/** 
	*   
	*    Called by establish and __instanceBasicTwoLayerResize.
    *   This method resizes the container based on cameraWidth/Height and gameScale
    *   It is handling a call to tabageos.ResizeGame
    *   In general this method happens as part of construction and automatically. 
    *   If you needed to resize the game manually use __instanceBasicTwoLayerResize.
	*    
	* @memberof GameSkeleton.prototype 
	* @method _basicTwoLayerResize
	* @param cameraLayer 
	* @param display 
	* @param charLayer 
	* @param cameraWidth 
	* @param cameraHeight 
	* @param controllerHeight 
	* @param containerDiv 
	* @param controllerInstance 
	* @param gameScale 
    * 
	*/
    GameSkeleton.prototype._basicTwoLayerResize = function(cameraLayer,display,charLayer, cameraWidth,cameraHeight,controllerHeight,containerDiv,controllerInstance, gameScale) { 
			
			
			cameraLayer.context.webkitImageSmoothingEnabled = false;
			cameraLayer.context.mozImageSmoothingEnabled = false;
			cameraLayer.context.imageSmoothingEnabled = false;
			if(display && display.context) {
				display.context.webkitImageSmoothingEnabled = false;
				display.context.mozImageSmoothingEnabled = false;
				display.context.imageSmoothingEnabled = false;
			}
			charLayer.context.webkitImageSmoothingEnabled = false;
			charLayer.context.mozImageSmoothingEnabled = false;
			charLayer.context.imageSmoothingEnabled = false;
			GameSkeleton.game.device = tabageos.seekTouch();
			
			if (GameSkeleton.game.device == 1) { 
				tabageos.ResizeGame(cameraWidth,cameraHeight+controllerHeight,GameSkeleton.game.dontResizeHorizontal ? 0 : (gameScale || 1), GameSkeleton.game.dontResizeVertical ? 0 : (gameScale || 1),gameScale ? GameSkeleton.game.container : null,GameSkeleton.game._manuelControllerUse ? null : GameSkeleton.game.controller,1,1,GameSkeleton.game._scaleRectRef,1,cameraWidth, controllerHeight);
				
				
			} else { 
				tabageos.ResizeGame(cameraWidth,cameraHeight,GameSkeleton.game.dontResizeHorizontal ? 0 : (gameScale || 1), GameSkeleton.game.dontResizeVertical ? 0 : (gameScale || 1),gameScale ? (GameSkeleton.game.resizeRootForNoTouch ? ( GameSkeleton.game.screenOrganizer ? GameSkeleton.game.root.div : GameSkeleton.game.root) : GameSkeleton.game.container) : null,GameSkeleton.game._manuelControllerUse ? null : GameSkeleton.game.controller,0,1,GameSkeleton.game._scaleRectRef,1); 
				
			}
			
	};
	/** 
	*   
	*    Calls GameSkeleton.establish with instance properties.
	*    
	* @memberof GameSkeleton.prototype 
	* @method _reEstablish
	* @param e {Event}
    * 
	*/
    GameSkeleton.prototype._reEstablish = function(e) {
		
		GameSkeleton.game.screenOrganizer.removeEventListener(tabageos.ScreenOrganizer.COVER,"_reEstablish", GameSkeleton.game);
		
		GameSkeleton.establish(GameSkeleton.game, GameSkeleton.game.__specs.spriteSheetImage || null, GameSkeleton.game.__specs.containerDivId || "container", GameSkeleton.game.__specs.rootDivId || "root", GameSkeleton.game.__specs.controllerDivId , GameSkeleton.game.__specs.gameScale === 0 ? 0 : (GameSkeleton.game.__specs.gameScale||2), GameSkeleton.game.__specs.useScreenOrganizer === false ? false : true, GameSkeleton.game.__specs.startWidth || 50, GameSkeleton.game.__specs.startHeight || 25);

		
	};
    
	/** 
	*   
	*    This static method is called by the GameSkeleton constructor and should generally not be used.
    *    This method sets up GameSkeleton.game._image, calls basicInitalize and does initial resizing of the game.
    *    To do everything this method does except ._image setup use the .__instanceBasicTwoLayerResize method on the instance.
    *    To recall this method once everything has already been constructed use the ._reEstablish method on the instance.
    *    If you want to change your whole sprite sheet on the fly, set it up manually to be GameSkeleton.__sprites as a CanvasObject.
    *    Or streamline it using the tabageos.loadSpriteSheetAndStart static Utility method, in which case it would also end up as the GameSkeleton.__sprites CanvasObject.
    *    then you would just use __sprites.copyPixels to change the sprite sheet itself. 
	*    
	* @memberof GameSkeleton
	* @method establish
    * @param gameInstance
    * @param spriteSheetImage An html image a CanvasObject or the string 'streamline'
    * @param containerDivId {String}
    * @param rootDivId {String}
    * @param controllerDivId {String}
    * @param gameScale {Number}
    * @param useScreenOrganizer {Boolean}
    * @param startWidth {Number}
    * @param startHeight {Number}
	*/
	GameSkeleton.establish = function(gameInstance, spriteSheetImage,containerDivId, rootDivId, controllerDivId, gameScale, useScreenOrganizer, startWidth,startHeight) {
            
			if(spriteSheetImage) {
				GameSkeleton.img = ((spriteSheetImage != "streamline" && !GameSkeleton.__sprites) ? new Image() : GameSkeleton.__sprites.canvas);
				GameSkeleton.img.onload = function(e) {
					GameSkeleton.game = gameInstance;
					GameSkeleton.game._image = GameSkeleton.img;
					GameSkeleton.game.basicInitialize(containerDivId, rootDivId, GameSkeleton.game.gameWidth,GameSkeleton.game.gameHeight, GameSkeleton.game.cameraWidth,GameSkeleton.game.cameraHeight, controllerDivId,useScreenOrganizer, startWidth,startHeight,GameSkeleton.game.useSceneChanger === 0 ? 1 : 0, GameSkeleton.game._manuelControllerUse);
					GameSkeleton.game.gameScale = gameScale || 0;
					GameSkeleton.game._basicTwoLayerResize(GameSkeleton.game.cameraLayer,GameSkeleton.game.display,GameSkeleton.game.charLayer, GameSkeleton.game.cameraWidth,GameSkeleton.game.cameraHeight,GameSkeleton.game.controllerHeight,GameSkeleton.game.containerDiv,GameSkeleton.game.controller, GameSkeleton.game.gameScale);
					
					
					if(GameSkeleton.game.gameScale >= 1 || GameSkeleton.game.gameScale === 0) {
						
						var scaw = GameSkeleton.game._scaleRectRef.width || GameSkeleton.game.cameraWidth;
						var scah = (GameSkeleton.game._scaleRectRef.height - GameSkeleton.game.tileHeight) >= GameSkeleton.game.gameHeight;
						
                        GameSkeleton.game.container.style.left = "calc(50% - "+(    (scaw/2)    )+"px)";
                        GameSkeleton.game._HUD.style.left = "calc(50% - "+(  (scaw/2)  - (scaw-160)  )+"px)";

                        var scaleX = window.innerWidth / GameSkeleton.game.cameraWidth;

                       
                    
                        var scaleY = window.innerHeight / GameSkeleton.game.cameraHeight;

                        GameSkeleton.game._HUD.style.transformOrigin = "0 0";
                        GameSkeleton.game._HUD.style.transform = "scale(" + ( scaleX / GameSkeleton.game.gameScale) + "," + ( scaleY / GameSkeleton.game.gameScale) + ")";

                        var hudupr = GameSkeleton.game._HUD.getBoundingClientRect();

                        GameSkeleton.game._HUD.style.left = "calc(50% - "+(  (scaw/2)  - (scaw-hudupr.width)  )+"px)";
					}
					if(GameSkeleton.game.addedResizeMethod) {
						GameSkeleton.game.addedResizeMethod();
					}
					window.addEventListener('resize', GameSkeleton.game.__instanceBasicTwoLayerResize, false);
					window.addEventListener('orientationchange', GameSkeleton.game.__instanceBasicTwoLayerResize, false);
				}; GameSkeleton.img.src = spriteSheetImage;
			} else {
				GameSkeleton.game = gameInstance;
				GameSkeleton.game.basicInitialize(containerDivId, rootDivId, GameSkeleton.game.gameWidth,GameSkeleton.game.gameHeight, GameSkeleton.game.cameraWidth,GameSkeleton.game.cameraHeight, controllerDivId, useScreenOrganizer, startWidth,startHeight,GameSkeleton.game.useSceneChanger === 0 ? 1 : 0,GameSkeleton.game._manuelControllerUse);
				GameSkeleton.game.gameScale = gameScale || 0;
				GameSkeleton.game._basicTwoLayerResize(GameSkeleton.game.cameraLayer,GameSkeleton.game.display,GameSkeleton.game.charLayer, GameSkeleton.game.cameraWidth,GameSkeleton.game.cameraHeight,GameSkeleton.game.controllerHeight,GameSkeleton.game.containerDiv,GameSkeleton.game.controller, GameSkeleton.game.gameScale);	
				if(GameSkeleton.game.gameScale >= 1 || GameSkeleton.game.gameScale === 0) {
			
					var scaw = GameSkeleton.game._scaleRectRef.width || GameSkeleton.game.cameraWidth;
					var scah = (GameSkeleton.game._scaleRectRef.height - GameSkeleton.game.tileHeight) >= GameSkeleton.game.gameHeight;
					
                    GameSkeleton.game.container.style.left = "calc(50% - "+(    (scaw/2)    )+"px)";
                    GameSkeleton.game._HUD.style.left = "calc(50% - "+(  (scaw/2)  - (scaw-160)  )+"px)";


                    var scaleX = window.innerWidth / GameSkeleton.game.cameraWidth;

                   
                   
                    var scaleY = window.innerHeight / GameSkeleton.game.cameraHeight;
					
                    GameSkeleton.game._HUD.style.transformOrigin = "0 0";
                    GameSkeleton.game._HUD.style.transform = "scale(" + ( scaleX / GameSkeleton.game.gameScale) + "," + ( scaleY / GameSkeleton.game.gameScale) + ")";

                    var hudupr = GameSkeleton.game._HUD.getBoundingClientRect();

                    GameSkeleton.game._HUD.style.left = "calc(50% - "+(  (scaw/2)  - (scaw-hudupr.width)  )+"px)";

				}
				if(GameSkeleton.game.addedResizeMethod) {
					GameSkeleton.game.addedResizeMethod();
				}
				window.addEventListener('resize', GameSkeleton.game.__instanceBasicTwoLayerResize, false);
				window.addEventListener('orientationchange', GameSkeleton.game.__instanceBasicTwoLayerResize, false);
				
			}
			
	};
	
	/** 
	*   
	*    This method is basically the value of the static GameSkeleton.establish method, but using the instance, therefore no params are needed.
	*    if addedResizeMethod has been defined it will be called after resizing.
    *
    *     The styles being used for resizing are using the calc css property, so for example container.style.left will be 'calc(50% - '+ (scaw/2) +'px)';
    *       where scaw is the scale width or cameraWidth if no scale.
    *
	* @memberof GameSkeleton.prototype 
	* @method __instanceBasicTwoLayerResize
    * 
	*/
    GameSkeleton.prototype.__instanceBasicTwoLayerResize = function() {
		
		GameSkeleton.game._basicTwoLayerResize(GameSkeleton.game.cameraLayer,GameSkeleton.game.display,GameSkeleton.game.charLayer, GameSkeleton.game.cameraWidth,GameSkeleton.game.cameraHeight,GameSkeleton.game.controllerHeight,GameSkeleton.game.container,GameSkeleton.game.controller, GameSkeleton.game.gameScale);
		
		if(GameSkeleton.game.gameScale >= 1 || GameSkeleton.game.gameScale === 0) {
			
			
			var scaw = GameSkeleton.game._scaleRectRef.width || GameSkeleton.game.cameraWidth; 
			var scah = (GameSkeleton.game._scaleRectRef.height - GameSkeleton.game.tileHeight) >= GameSkeleton.game.gameHeight;
			
            GameSkeleton.game.container.style.left = "calc(50% - "+(    (scaw/2)    )+"px)";
            
            GameSkeleton.game._HUD.style.left = "calc(50% - "+(  (scaw/2)  - (scaw-160)  )+"px)";

            var scaleX = window.innerWidth / GameSkeleton.game.cameraWidth;
            var scaleY = window.innerHeight / GameSkeleton.game.cameraHeight;

            GameSkeleton.game._HUD.style.transformOrigin = "0 0";
            GameSkeleton.game._HUD.style.transform = "scale(" + ( scaleX / GameSkeleton.game.gameScale) + "," + ( scaleY / GameSkeleton.game.gameScale) + ")";

            var hudupr = GameSkeleton.game._HUD.getBoundingClientRect();

            GameSkeleton.game._HUD.style.left = "calc(50% - "+(  (scaw/2)  - (scaw-hudupr.width)  )+"px)";
           
		}
        
		
		if(GameSkeleton.game.addedResizeMethod) {
			
			GameSkeleton.game.addedResizeMethod();
		}
		
	};
    
    
    /**
    *
    * plays the sound as defined by its soundString name. If the sound is not already loaded it will be loaded. By default soundString +".ogg" would be loaded.
    *  It will load and create a default pool of 2, with a pool quick back to back full one shots are possible, increase the optional poolAmount as needed.
    *  The stype param can be used to change the type.
    *  
    * @memberof GameSkeleton.prototype
    * @method playSound
    * @param soundString {String} The name of the sound, by default the sound to load will be soundString + ".ogg"
    * @param poolAMount {Number} optional amount to pool the sound, default is 2.
    * @param stype {String} Optional alternate type of sound to load/ending of file name, default is '.ogg' which is added to soundString.
    */
    GameSkeleton.prototype.playSound = function(soundString, poolAmount, stype) {
		if(this.soundSystem._soundNames.indexOf(soundString) === -1) {
			this.soundSystem.addSound(soundString+(stype||".ogg"),soundString,1,poolAmount || 2);
		}
		this.soundSystem.playSound(soundString, 1);
	};
    /**
    *
    * plays the music as defined by its soundString name. By default soundString +".ogg" would be loaded.
    *  Only 1 music track can play at a time, when this method is called any previous tracks are cleared
    *  
    *  
    * @memberof GameSkeleton.prototype
    * @method playMusic
    * @param soundString {String} The name of the sound, by default the sound to load will be soundString + ".ogg"
    * @param loop {Number} loop the track, defalt is 1 true, the track will keep replaying by default.
    * @param stype {String} Optional alternate type of sound to load/ending of file name, default is '.ogg' which is added to soundString.
    */
	GameSkeleton.prototype.playMusic = function(soundString, loop, stype) {
		this.soundSystem.clearMusicTracks();
		this.soundSystem.addMusic(soundString+(stype||".ogg"),1,loop === 0 || loop === -1 ? 0 : 1);
		this.soundSystem.playMusic(0);
	};
    
    
    /**
    *
    * Setup a custom hud. 
    * It's called setupCustomHealthHud because the _healthBar div is being used, but you can utilize html to style/position it in any way.
    * 
    *  By default there is a right side HUD with 4 buttons and on the left a basic health bar is displayed using calls to showHealthBar/hideHealthBar.
    *  This method will hide the default right side HUD and gets the _healthBar left side area ready to be custom styled.
    *
    * @memberof GameSkeleton.prototype
    * @method setupCustomHealthHud
    * @param backgroundId {String} The id for the html div holding your custom hud, assign css to the id to style and positon the background of your custom hud
    *
    */
    GameSkeleton.prototype.setupCustomHealthHud = function( backgroundId ) {
		
		GameSkeleton.game.hideHUD();
		GameSkeleton.game._playerHUD.style.display = "inline";
		if(backgroundId) {
			GameSkeleton.game._healthBar.setAttribute("id", backgroundId);
			
		}
	};
	/**
    * Adds a div to the custom hud.
    *
    * @memberof GameSkeleton.prototype
    * @method addToCustomHud
    * @param divID {String} The id for the new div added to the custom hud, you can asign style to the id (in css) to style your custom addition
    * @param style {String} Style for the new div added to the custom hud, you can style via the id or you can pass in css style directly in this param
    * @returns {Number} Returns the part number of this addition, for example if it is the first part added the part number is 1 and so on.
    */
	GameSkeleton.prototype.addToCustomHud = function( divID, style ) {
		
		var div = document.createElement("div");
		div.setAttribute("id", divID);
		div.setAttribute("style", style);
		GameSkeleton.game._healthBar.appendChild(div);
		GameSkeleton.game._playerHudParts.push(div);
		return GameSkeleton.game._playerHudParts.length - 1;
		
	};
	/**
    *
    *  Returns a reference to a div added to the custom hud via addToCustomHud
    *  
    * @memberof GameSkeleton.prototype
    * @method getCustomHudPart
    * @param partNumber {Number} The number of the div to get. The number will be in the order that you called addToCustomHud.
    * @returns {HTMLDiv} A reference to the html div that was added to the custom hud.
    */
	GameSkeleton.prototype.getCustomHudPart = function(partNumber) {
		
		return GameSkeleton.game._playerHudParts[partNumber || 1];
		
	};
    /**
    *
    *
    * Removes all divs added with addToCustomHud
    *
    * @memberof GameSkeleton.prototype
    * @method removeCustomHudParts
    *
    *
    */
	GameSkeleton.prototype.removeCustomHudParts = function() {
		
		var i = 0;
		for(i;i<GameSkeleton.game._playerHudParts.length;i++) {
			
			GameSkeleton.game._healthBar.removeChild(GameSkeleton.game._playerHudParts[i]);
			
		}
		GameSkeleton.game._playerHudParts = [0];
	};
	/**
    *
    *
    * Hides the custom hud (same as hideHealthBar)
    *
    * @memberof GameSkeleton.prototype
    * @method hideCustomHud
    *
    *
    */
	GameSkeleton.prototype.hideCustomHud = function() {
		
		GameSkeleton.game.hideHealthBar();
	};
	/**
    *
    *
    * Shows the custom hud  (same as showHealthBar, but in this case it may not be being used as a health bar, it's just that _healthBar is the space used for the custom hud)
    *
    * @memberof GameSkeleton.prototype
    * @method showCustomHud
    * @param health {Number} The amount of health, also the width of the healthbar.
	* @param firstColor {String} an html color value
	* @param secondColor {String} am html color value
	* @param height {Number} the height of the health bar
    * @param replacementStyle {String} An optional style that would replace the default style, thereby the firstColor and secondColor and height params would not be used. Use this param to style the health bar yourself.
    * @param additionalStyle {String} A style that would be added to the default style.
    * 
	*
    *
    */
	GameSkeleton.prototype.showCustomHud = function(health, firstColor, secondColor, height, replacementStyle, additionalStyle) {
		
		GameSkeleton.game.showHealthBar(health, firstColor, secondColor, height, replacementStyle, additionalStyle);
	};
    
    /**
    *
    *
    * Stops the game loop and resets postion, the transition shows, then main loop would start again.
    *  And positionResetSpecifics would get called if it is set.
    *
    * @memberof GameSkeleton.prototype
    * @method simpleReset
    *
    *
    */
    GameSkeleton.prototype.simpleReset = function() {
		GameSkeleton.game._doReset = 1;GameSkeleton.game.__workLoop = 0;
		GameSkeleton.game.reset({keyCode:82});
	};
    /**
    *
    *
    *  This method shakes the container for the specified time.
    *  this method is used in conjunction with the _loop method.
    *   this method is controlling camera.shake for you, utilizing also the includeShake method.
    *   You have more control over what shakes and how it shakes using the BasicCamera's shake methods directly.
    *   But this method is the easiest way to simply shake the screen.
    *  
    * @memberof GameSkeleton.prototype
    * @method shake
    * @param time {Number} Amount of time to shake in milliseconds
    *
    */
    GameSkeleton.prototype.shake = function(time) {
		GameSkeleton.game.camera.shake(time, GameSkeleton.game.container);
		if(GameSkeleton.game._cameraType == 2) {
			GameSkeleton.game.includeShake(time);
		}
	};
	/**
    *
    * Used by the shake method.
    *
    * @memberof GameSkeleton.prototype
    * @method includeShake
    *
    * @param time {Number} Amount of time to shake in milliseconds
    * 
    */
	GameSkeleton.prototype.includeShake = function(time) {
		
		GameSkeleton.game._shakesToInclude = Math.round(time / 33.3) + 1;
		if(GameSkeleton.game._shakesToInclude % 2 === 0) {
			GameSkeleton.game._shakesToInclude += 3;
		}
		
	};
    
    /**
    *
    * When 1 and the __worker has been made then _loop is happening from the worker.
    *
    * @memberof GameSkeleton
    *  @type {Number}
    *
    *
    */
    GameSkeleton.prototype.__workLoop = 0;
    /**
    *
    * A Worker created by the initWorkerLoop method.
    * by default this worker is set up during construction.
    *
    * @memberof GameSkeleton
    * 
    * @type {Worker}
    *
    */
	GameSkeleton.prototype.__worker = null;
    
    /**
    *
    * Changes the frameRate and frameTime of the game.
    * This method must be used if you want to change frameRate/frameTime after construction.
    *
    * @memberof GameSkeleton.prototype
    * @method changeFrameRate
    *
    * @param to {Number} The frameRate to change to.
    *
    */
    GameSkeleton.prototype.changeFrameRate = function(to) {
		
		
		if(GameSkeleton.game && GameSkeleton.game.__worker) {
			
			GameSkeleton.game.__worker.postMessage({frameRate:to});
			GameSkeleton.game.frameTime = (1000/60) * (60 / GameSkeleton.game.frameRate ) - (1000/60) * 0.5;
		} else {
			
			GameSkeleton.game.frameRate = to;
			GameSkeleton.game.frameTime = (1000/60) * (60 / GameSkeleton.game.frameRate ) - (1000/60) * 0.5;
		}
		
	};
    
    
    
	/**
    *
    * Creates a Worker that runs a frameRate based loop. Automatically called as part of construction of the class.
    *
    * @memberof GameSkeleton.prototype
    * @method __loopWorker
    *
    * @return {Worker}
    *
    */
	GameSkeleton.prototype.__loopWorker = function() { 
		
		var blb;var retw = null;
			blb = URL.createObjectURL( new Blob([ '(',
			
				function() {
					var tck = {tick:1};
					var rate = 16.666666666;
					var intervl = null;
					onmessage = function(e) {
						if(e.data.frameRate) {
							rate = (1000/e.data.frameRate);
							if(intervl) clearInterval(intervl);
							intervl = setInterval(  function() {
								self.postMessage(tck);
							}, rate);
						}
					};
					intervl = setInterval(  function() {
						
						self.postMessage(tck);
						
					}, rate);
					
				}.toString(),
				
			')()' ], {type: 'application/javascript'} ) );
		
		try {
			retw = new Worker( blb );
		} catch(e) {
			
		}
		return retw;
		
	};
	GameSkeleton.prototype.__methodForWorker = null;
	/**
    *
    * Creates a Worker that runs a frameRate based loop. And sets _loop to run on that independent loop.
    * This method is called as part of basicInitialize which is called as part of construction.
    * 
    *   If a Worker can not be used, then requestAnimationFrame is used to repeatedy call _loop, and that call is then throttled using the _thrott and _pr properties.
    *   You can change what function the worker/requestAnimationFrame is calling by using the changeMainLoopMethod method.
    *   That function happens at the frameRate you set with the changeFrameRate function, by default 60 frames a second.
    *
    *   This method gets called as part of construction and a worker starts running _loop by default, but nothing happens in _loop until the start button is pressed.
    *   If a worker can not be set up, then requestAnimationFrame using _loop happens when the start button is pressed.
    *   
    *
    * @memberof GameSkeleton.prototype
    * @method initWorkerLoop
    * 
    *
    */
	GameSkeleton.prototype.initWorkerLoop = function() { 
		if(!this.__worker) {
			this.__worker = GameSkeleton.game.__loopWorker();
			try {
				GameSkeleton.game.__worker.postMessage({frameRate:GameSkeleton.game.frameRate});
				GameSkeleton.game.frameTime = (1000/60) * (60 / GameSkeleton.game.frameRate ) - (1000/60) * 0.5;
			} catch(e) {
				this.__worker = null;
				
			}
			if(this.__worker != null) {
				this.__workLoop = 0;
				this.__methodForWorker = GameSkeleton.game._loop;
				
				this.__worker.addEventListener("message", function(e) {
				  if(e.data.tick) {
					GameSkeleton.game.__methodForWorker(1);
				  }
				});
			} else {
				
				this.changeFrameRate(GameSkeleton.game.frameRate);
				
				
				
				
			}
		}
	};
    
	tabageos.GameSkeleton = GameSkeleton;
	
})();
(function() { 

	'use strict';
	/**
    *
    * @class GeometricMath
    * 
	*@classdesc
	*  A Class of static methods used for various geometry calculations and basic collision detection.
	*  Also contains some Array helper methods; splice and mergeArrays. 
	*
	* 
	*
	*
	*
	*/
    function GeometricMath() {}
	/**
	*
	*
	* Returns the MoverPoint on the arc curve that is defined by the x/y pairs given.
	* The MoverPoint returned is in relation to t (0 to .9) on the curve.
	* This method creates and returns a new MoverPoint, to avoid that instead use updateArcCurvePath with a premade MoverPoint.
	*
	* @memberof GeometricMath
	* @param t {Number} translation on the path from which to get the one point; 0 to .9.
	* @param p0x {Number} x position of first point in curve path
	* @param p0y {Number} y position of first point in curve path
	* @param p1x {Number} x position of middle point in curve path
	* @param p1y {Number} y position of middle point in curve path
	* @param p2x {Number} x position of last point in curve path
	* @param p2y {Number} y position of last point in curve path
	* @returns {MoverPoint}
	*/
	GeometricMath.arcCurvePoint = function(t, p0x, p0y, p1x, p1y, p2x, p2y) {
        var result = new tabageos.MoverPoint();
        var oneMinusTSq = (1 - t) * (1 - t);
        var TSq = t * t;
        result.x = oneMinusTSq * p0x + 2 * (1 - t) * t * p1x + TSq * p2x;
        result.y = oneMinusTSq * p0y + 2 * (1 - t) * t * p1y + TSq * p2y;
        return result;
    };
	/**
	*
	*
	* Updates the given MoverPoint on the arc curve defined by the x/y pairs given.
	* The update is based on t, which is a 0 to .9 value, the amount of points the path has being 1.
	* The path is defined by p0x...p2y. 
	* 
	*  Same as the arcCurvePoint method except that you pass in a pre made MoverPoint that gets updated.
	* 
	* @param point {MoverPoint} The MoverPoint to store the point on the path.  
	* @param t {Number} translation on the path from which to get the one point; 0 to .9.
	* @param p0x {Number} x position of first point in curve path
	* @param p0y {Number} y position of first point in curve path
	* @param p1x {Number} x position of middle point in curve path
	* @param p1y {Number} y position of middle point in curve path
	* @param p2x {Number} x position of last point in curve path
	* @param p2y {Number} y position of last point in curve path
	* @memberof GeometricMath
	*
	*
	*/
    GeometricMath.updateArcCurvePoint = function(point, t, p0x, p0y, p1x, p1y, p2x, p2y) {
        var oneMinusTSq = (1 - t) * (1 - t);
        var TSq = t * t;
        point.x = oneMinusTSq * p0x + 2 * (1 - t) * t * p1x + TSq * p2x;
        point.y = oneMinusTSq * p0y + 2 * (1 - t) * t * p1y + TSq * p2y;
    };
	/**
	*
	* Returns an Array of MoverPoints that make up the arc defined by the points given.
	*  p0 is the first leftmost point of the arc, p1 is the middle of the arc, and p2 is the end of the arc.
	* 
	*
	* @memberof GeometricMath
	* @param p0 {MoverPoint} the first MoverPoint of the arc path
	* @param p1 {MoverPoint} the middle MoverPoint of the arc path
	* @param p2 {MoverPoint} the last MoverPoint of the arc path
	* @param amountOfPathPoints {Number} the number of points along the path to return.
	* @returns {Array}
	*/
    GeometricMath.getArcCurvePath = function(p0, p1, p2, amountOfPathPoints) {
        var i = 0;
        var addBy = (100 / amountOfPathPoints) / 100;
        var path = [];
        var pathPoint;
        while (i < 1) {
            pathPoint = GeometricMath.arcCurvePoint(i, p0.x, p0.y, p1.x, p1.y, p2.x, p2.y);
            path[path.length] = pathPoint;
            i += addBy;
        }
        return path;
    };
	/**
	*
	* Updates the Array path given with the MoverPoints that make up the arc defined by the points given.
	* A path should first be made using the GeometricMath.getArcCurvePath method.
	*
	* @memberof GeometricMath
	* @param path {Array} an Array of MoverPoints to update
	* @param p0 {MoverPoint} the first point in the arc curve path
	* @param p1 {MoverPoint} the middle point in the arc curve path
	* @param p2 {MoverPoint} the last point in the arc curve path
	*/
    GeometricMath.updateArcCurvePath = function(path, p0, p1, p2) {
        var i = 0;
        var l = path.length;
        var pathPoint;
        var addBy = (100 / l) / 100;
        var t = 0;
        while (i < l) {
            pathPoint = path[i];
            GeometricMath.updateArcCurvePoint(pathPoint, t, p0.x, p0.y, p1.x, p1.y, p2.x, p2.y);
            i += 1;
            t += addBy;
        }
    };
	/**
	* 
	* Returns an Array of x and y pairs that make up the locations of each point along the path defined by the x/y pairs given.
	* This is the most efficient method to use to obtain a arc curve path, then loop through the array by 2 to use each x y location.
	* 
	* @param p0x {Number} the x position of the first point.
	* @param p0y {Number} the y position of the first point.
	* @param p1x {Number} the x position of the middle point.
	* @param p1y {Number} the y position of the middle point.
	* @param p2x {Number} the x position of the last point.
	* @param p2y {Number} the y position of the last point.
	* @param amountOfPathPoints {Number} the amount of points to calculate.
	* @param prePath {Array} a predefined Array to hold the path.
	* @memberof GeometricMath
	* @returns {Array | Number}
	*
	*/
	GeometricMath.getRawArcCurvePath = function(p0x, p0y, p1x, p1y, p2x, p2y, amountOfPathPoints, prePath) {
        var i = 0;
        var addBy = (100 / amountOfPathPoints) / 100;
        var path = prePath || []; path.length = 0;
        while (i < 1) {
			var oneMinusTSq = (1 - i) * (1 - i);
			var TSq = i * i;
            path[path.length] = oneMinusTSq * p0x + 2 * (1 - i) * i * p1x + TSq * p2x;
			path[path.length] = oneMinusTSq * p0y + 2 * (1 - i) * i * p1y + TSq * p2y;
            i += addBy;
        }
        return prePath ? 0 : path;
    };
	/**
	*
	*
	*
	*
	* Returns the point on the hermite (wave) curve as defined by t and the x/y pairs given. 
	* Creates and returns a new MoverPoint.
	*
	*
	* @memberof GeometricMath
	* @param t {Number} 
	* @param p0x {Number} the x position of the first point.
	* @param p0y {Number} the y position of the first point.
	* @param t0x {Number} the x position of the middle point.
	* @param t0y {Number} the y position of the middle point.
	* @param p1x {Number} the x position of the last point.
	* @param p1y {Number} the y position of the last point.
	* @param t1x {Number} the x position of the middle point.
	* @param t1y {Number} the y position of the middle point.
	* 
	* @returns {MoverPoint}
	*
	*
	*
	*/
    GeometricMath.hermiteCurvePoint = function(t, p0x, p0y, t0x, t0y, p1x, p1y, t1x, t1y) {
        var result = new tabageos.MoverPoint();
        result.x = (2 * Math.pow(t, 3) - 3 * t * t + 1) * p0x + (Math.pow(t, 3) - 2 * t * t + t) * t0x + (-2 * Math.pow(t, 3) + 3 * t * t) * p1x + (Math.pow(t, 3) - t * t) * t1x;
        result.y = (2 * Math.pow(t, 3) - 3 * t * t + 1) * p0y + (Math.pow(t, 3) - 2 * t * t + t) * t0y + (-2 * Math.pow(t, 3) + 3 * t * t) * p1y + (Math.pow(t, 3) - t * t) * t1y;
        return result;
    };
	/**
	*
	*
	*
	*
	*  Returns an Array of MoverPoints that make up the hermite (wave) path as defined by the points given.
	*
	*
	*
	*
	* @memberof GeometricMath
	* @returns {Array}
	*
	*
	*/
    GeometricMath.getHermiteCurvePath = function(p0, t0, p1, t1, amountOfPathPoints) {
        var i = 0;
        var addBy = (100 / amountOfPathPoints) / 100;
        var path = [];
        while (i < 1) {
            var pathPoint = GeometricMath.hermiteCurvePoint(i, p0.x, p0.y, t0.x, t0.y, p1.x, p1.y, t1.x, t1.y);
            path[path.length] = pathPoint;
            i += addBy;
        }
        return path;
    };
	/**
	*
	*
	*
	*  Returns or updates an Array of x/y pairs that make up the hermite (wave) path as defined by the x/y pairs given. 
	*
	*
	*
	*
	*  @memberof GeometricMath
	* @returns {Array | Number}
	*
	*
	*
	*/
	GeometricMath.getRawHermiteCurvePath = function(p0x,p0y, t0x,t0y, p1x,p1y, t1x,t1y, amountOfPathPoints, prePath) {
        var t = 0;
        var addBy = (100 / amountOfPathPoints) / 100;
        var path = prePath || []; path.length = 0;
        while (t < 1) {
			path[path.length] = (2 * Math.pow(t, 3) - 3 * t * t + 1) * p0x + (Math.pow(t, 3) - 2 * t * t + t) * t0x + (-2 * Math.pow(t, 3) + 3 * t * t) * p1x + (Math.pow(t, 3) - t * t) * t1x;
			path[path.length] = (2 * Math.pow(t, 3) - 3 * t * t + 1) * p0y + (Math.pow(t, 3) - 2 * t * t + t) * t0y + (-2 * Math.pow(t, 3) + 3 * t * t) * p1y + (Math.pow(t, 3) - t * t) * t1y;
            t += addBy;
        }
        return prePath ? 0 : path;
    };
	/**
	*
	*
	* 
	*
	* 
	* Returns true if the two lines intersect.
	*
	* @memberof GeometricMath
	*
	* @param a beginning point of line one
	* @param b ending point of line one
	* @param c beginning point of line two
	* @param d ending point of line two
	* @returns {Boolean}
	*/
    GeometricMath.lineIntersectionTest = function(a, b, c, d) {
        var top1 = (a.y - c.y) * (d.x - c.x) - (a.x - c.x) * (d.y - c.y);
        var top2 = (a.y - c.y) * (b.x - a.x) - (a.x - c.x) * (b.y - a.y);
        var bott = (b.x - a.x) * (d.y - c.y) - (b.y - a.y) * (d.x - c.x);
        if (bott == 0) {
            return false;
        }
        var opBott = 1.0 / bott;
        var u = top1 * opBott;
        var dw = top2 * opBott;
        if ((u > 0) && (u < 1) && (dw > 0) && (dw < 1)) {
            return true;
        }
        return false;
    };
	/**
	*
	*
	*
	*
	*
	*
	* Returns the point at which the lines interset or null.
	*
	*
	* @memberof GeometricMath
	* @param a beginning point of line one
	* @param b ending point of line one
	* @param c beginning point of line two
	* @param d ending point of line two
	* @returns {MoverPoint}
	*
	*/
    GeometricMath.lineIntersectionPoint = function(a, b, c, d) {
        var top1 = (a.y - c.y) * (d.x - c.x) - (a.x - c.x) * (d.y - c.y);
        var top2 = (a.y - c.y) * (b.x - a.x) - (a.x - c.x) * (b.y - a.y);
        var bott = (b.x - a.x) * (d.y - c.y) - (b.y - a.y) * (d.x - c.x);
        if (bott == 0) {
            return null;
        }
        var u = top1 / bott;
        var dw = top2 / bott;
        if ((u > 0) && (u < 1) && (dw > 0) && (dw < 1)) {
            var temp = b.subtract(a).multiply(u);
            var point = a.add(temp);
            return point;
        } else {
            return null;
        }
    };
	GeometricMath._rPoint;
	/**
	*
	*
	*
	*
	*
	*
	* Returns true if the given point is inside the circle defined by circlePosition and circleRadius
	*
	*
	*
	* @memberof GeometricMath
	* @param circlePosition {MoverPoint} the position of the circle (its center)
	* @param circleRadius {Number} the radius of the circle
	* @param pointToTest {MoverPoint} the point to test and see if its inside the circles area.
	* @returns {Boolean}
	*
	*/
    GeometricMath.testForPointInCircle = function(circlePosition, circleRadius, pointToTest) {
		if(!GeometricMath._rPoint) { GeometricMath._rPoint = new tabageos.MoverPoint(); }
		GeometricMath._rPoint.x = pointToTest.x+1-1; GeometricMath._rPoint.y = pointToTest.y+1-1;
        var dist = GeometricMath._rPoint.subtract(circlePosition, 0).getSquaredLength();
        if (dist < (circleRadius * circleRadius)) {
            return true;
        }
        return false;
    };
	/**
	*
	*
	*
	*
	* Returns true if the given point is inside the area defined by left top right and bottom cords.
	*
	*
	*
	*
	* @memberof GeometricMath
	* @param p {MoverPoint} the point to check if its in the given area.
	* @param left {Number} the left (x) position of the area
	* @param right {Number} the right (x+width) position of the area
	* @param top {Number} the top (y) position of the area
	* @param bottom {Number} the bottom (y+height) position of the area
	* @returns {Boolean}
	*
	*
	*/
    GeometricMath.testForPointInArea = function(p, left, top, right, bottom) {
        return Boolean(!(p.x < left || p.x > right || p.y < top || p.y > bottom));
    };
	/**
	*
	*
	*
	*
	*
	*
	*
	*
	* Returns an Array of MoverPoints that make up a circle as defined by circleCenter, and circleRadius
	*
	*
	* @memberof GeometricMath
	* @param circleCenter {MoverPoint} the center point of the circle
	* @param circleRadius {Number} the radius of the circle
	* @param numberOfPoints {Number} the amount of points to get
	* @returns {Array}
	*/
    GeometricMath.getMoverPointsOnCircle = function(circleCenter, circleRadius, numberOfPoints) {
        var alpha = (Math.PI * 2) / numberOfPoints;
        var points = [];
        var theta;
        var p;
        var i = -1;
        while (i < numberOfPoints) {
            i += 1;
            theta = alpha * i;
            p = new tabageos.MoverPoint(Math.cos(theta) * circleRadius,Math.sin(theta) * circleRadius);
            points[i] = circleCenter.add(p);
        }
        return points;
    };
	/**
	*
	*
	*
	*
	*
	*
	* Returns an Array of the x/y pairs that define each point along the circle defined by circleCenterX/Y circleRaidus and numberOfPoints.
	*
	*  @memberof GeometricMath
	* @param circleCenterX {Number} the x position of the circles center
	* @param circleCenterY {Number} the y position of the circles center
	* @param circleRadius {Number} the radious of the circle
	* @param numberOfPoints {Number} the amount of points to get
	* @returns {Array}
	*
	*
	*
	*/
    GeometricMath.getRawPointsOnCircle = function(circleCenterX, circleCenterY, circleRadius, numberOfPoints) {
        var alpha = (Math.PI * 2) / numberOfPoints;
        var points = [];
        var theta;
        var cpx;
        var cpy;
        var i = -1;
        var remainder = numberOfPoints % 2;
        if (remainder != 0) {
            numberOfPoints = numberOfPoints - Math.round(remainder);
        }
        while (i < numberOfPoints * 2) {
            i += 2;
            theta = alpha * Math.floor(i / 2);
            cpx = Math.cos(theta) * circleRadius;
            cpy = Math.sin(theta) * circleRadius;
            points[i - 1] = circleCenterX + cpx;
            points[i] = circleCenterY + cpy;
        }
        return points;
    };
	/**
	*
	*
	*
	*
	*
	*
	* Merges two or more Arrays into a1 and returns a1.
	*
	* @memberof GeometricMath
	* @param a1 {Array} The Array that should get the other Arrays values added to it at the end
	* @param a2 {Array} The first Array whos values will get added to the end of a1, any other Arrays passed will keep getting added to the end.
	* @returns {Array} One Array containing the values of all the Arrays given.
	*
	*
	*
	*/
    GeometricMath.mergeArrays = function(a1, a2) {
        var i;
        for (i = 0; i < a2.length; i++) {
            a1[a1.length] = a2[i];
        }
        return a1;
    };
	/**
	*
	*
	*
	*
	*
	*
	*
	*
	*  Splices the given Array at the given index, without returning anything.
	*
	*
	* @memberof GeometricMath
	* @param arr {Array} The Array to splice
	* @param index {Number} The index at which to splice the Array.
	*
	*/
	GeometricMath.splice = function(arr, index) {
			var i = index;
			var l = arr.length - 1;
			for(i; i < l; i++) {
				arr[i] = arr[i+1];
			}
			arr.length = l;
	};
	/**
	*
	*
	*
	*
	*
	* Returns true if the two given Rectangles intersect.
	*
	* @memberof GeometricMath
	* @param r1 {Rectangle}
	* @param r2 {Rectangle}
	* @returns {Boolean}
	*
	*
	*
	*
	*/
    GeometricMath.rectanglesIntersect = function(r1, r2) {
        return !(r2.x > r1.x + r1.width || r2.x + r2.width < r1.x || r2.y > r1.y + r1.height || r2.y + r2.height < r1.y);
    };
	/**
	*
	*
	*
	*
	*
	*
	* @private
	*
	*
	*
	*
	*
	*
	*/
    GeometricMath._efRect = {top:0,bottom:0,left:0,right:0,si:0};
	/**
	*
	*
	*
	*
	*
	*  Returns the amount of overlap between two Rectangles, if any.
	*
	*
	* @memberof GeometricMath
	* @param r1 {Rectangle}
	* @param r2 {Rectangle}
	* @returns {Number}
	*
	*
	*
	*/
    GeometricMath.rectanglesOverlapAmount = function(r1, r2) {
        GeometricMath._efRect.top = Math.max(r1.y, r2.y);
        GeometricMath._efRect.bottom = Math.min(r1.y + r1.height, r2.y + r2.height);
        GeometricMath._efRect.left = Math.max(r1.x, r2.x);
        GeometricMath._efRect.right = Math.min(r1.x + r1.width, r2.x + r2.width);
        GeometricMath._efRect.si = Math.max(0, GeometricMath._efRect.right - GeometricMath._efRect.left) * Math.max(0, GeometricMath._efRect.bottom - GeometricMath._efRect.top);
       // var su = (r1.width * r1.height) + (r2.width * r2.height) - si;
        return GeometricMath._efRect.si+1-1;
		//return GeometricMath._wasmRoa(r1.x,r1.y,r1.width,r1.height,r2.x,r2.y,r2.width,r2.height);
    };
	/**
	*
	*
	*
	*
	*
	* Returns true if the number given is a power of 2.
	*
	* @memberof GeometricMath
	* @param x {Number} The Number to check.
	* @returns {Boolean}
	*
	*
	*
	*
	*/
    GeometricMath.isPowerOfTwo = function(x) {
        return x > 0 && (x & (x - 1)) == 0;
    };
    tabageos.GeometricMath = GeometricMath;
})();


//CopyRight 2019 (t)ad 
(function() { 
	'use strict';
    /**
    *@class IrisScreenOrganizer
    *@classdesc
	*   A ScreenOrganizer that uses an iris style transition.
	*    
	*    
	* 
	* @param game {CanvasPbjectContainer} A reference to the CanvasObjectContainer that is holding the whole game.
	* @param screenClasses {Array} An Array of Classes that this screen organizer will hold. Other CanvasObjectContainers or CanvasObjects that will act as different screens for the game.
	* @param screenConfigs  {Array} An optional Array of methods to call when each screen is initialized.
	*  
	*/
    function IrisScreenOrganizer(game, screenClasses, screenConfigs) {
		tabageos.EventDispatcher.call(this);
		tabageos.ScreenOrganizer.call(this,game,screenClasses,screenConfigs);
        this.fullRect = new tabageos.Rectangle();
        this.init(game, screenClasses, screenConfigs);
    };
	/** 
	*   
	*    
	*    
	* @memberof IrisScreenOrganizer 
	*  
	*/
    IrisScreenOrganizer.prototype.constructor = IrisScreenOrganizer;
	IrisScreenOrganizer.prototype = Object.create(tabageos.EventDispatcher.prototype);
	Object.assign(IrisScreenOrganizer.prototype, tabageos.ScreenOrganizer.prototype);
    /** 
	*   
	*    @private
	*    
	* @memberof IrisScreenOrganizer 
	*  
	*/
    IrisScreenOrganizer.prototype.fullRect = null;
    /** 
	*  Overrriden method of ScreenOrganizer
	*    
	*    
	* @memberof IrisScreenOrganizer.prototype 
	* @method initializeTransition
    * @returns {} 
	*/
    IrisScreenOrganizer.prototype.initializeTransition = function() {
        this.coverShape.setAlpha(1);
        this.rectRef.width = this.coverShape.width;
        this.rectRef.height = this.coverShape.height;
        this.fullRect.x = 0;
        this.fullRect.y = 0;
        this.fullRect.width = this.coverShape.width;
        this.fullRect.height = this.coverShape.height;
        this.coverShape.clear();
    };
    /** 
	*   Overrriden method of ScreenOrganizer
	*    uses coverShape and draws an iris. Returns true when the iris has filled.
	*    
	* @memberof IrisScreenOrganizer.prototype 
	* @method transitionBackward
    * @returns {} 
	*/
    IrisScreenOrganizer.prototype.transitionBackward = function() {
        this.rectRef.height += 16 * tabageos.TimeKeeper._sae;
        var w = this.coverShape.width;
        var h = this.coverShape.height;
        this.coverShape.context.fillStyle = "#000000";
        this.coverShape.context.fillRect(0, 0, w, h);
        this.coverShape.context.save();
        this.coverShape.context.beginPath();
        this.coverShape.context.arc(w / 2, h / 2, this.rectRef.height >= 0 ? this.rectRef.height : 0, 0, Math.PI * 2);
        this.coverShape.context.clip();
        this.coverShape.context.clearRect(0, 0, w, h);
        this.coverShape.context.restore();
		var tbgth = this.coverShape.height > this.coverShape.width ? this.coverShape.height : this.coverShape.width;
        var b = this.rectRef.height >= tbgth;
        if (b) {
            this.rectRef.width = 0;
            this.rectRef.height = tbgth;
        }
        return b;
    };
    /** 
	*   Overrriden method of ScreenOrganizer
	*    
	*    
	* @memberof IrisScreenOrganizer.prototype 
	* @method transitionForward
    * @returns {} 
	*/
    IrisScreenOrganizer.prototype.transitionForward = function() {
        this.rectRef.height -= 16 * tabageos.TimeKeeper._sae;
        var w = this.coverShape.width;
        var h = this.coverShape.height;
        this.coverShape.context.fillStyle = "#000000";
        this.coverShape.context.fillRect(0, 0, w, h);
        this.coverShape.context.save();
        this.coverShape.context.beginPath();
        this.coverShape.context.arc(w / 2, h / 2, this.rectRef.height >= 0 ? this.rectRef.height : 0, 0, Math.PI * 2);
        this.coverShape.context.clip();
        this.coverShape.context.clearRect(0, 0, w, h);
        this.coverShape.context.restore();
        var b = this.rectRef.height <= 0;
        if (b) {
            this.rectRef.width = 0;
            this.rectRef.height = 0;
        }
        return b;
    };
    tabageos.IrisScreenOrganizer = IrisScreenOrganizer;
})();





(function() { 

	'use strict';
    /** 
    *
    * @class LoopingImage
	* @classdesc
	*    Controls the repeated drawing of an image onto an html canvas.
	*    Extends the CanvasObject class.
	*    
	* 
	* @param canvas {HTMLCanvasElement}
	* @param width {Number}
	* @param height {Number}
	*  
	*/
    function LoopingImage(canvas, width, height) {
		tabageos.EventDispatcher.call(this);
		tabageos.CanvasObject.call(this,canvas,width,height);
        this.init(canvas, width, height);
        this.bI = 0;
        this.fRect = new tabageos.Rectangle();
        this.tPoint = new tabageos.MoverPoint();
    };
	/** 
	*   
	*    
	*    
	* @memberof LoopingImage 
	*  
	*/
    LoopingImage.prototype.constructor = LoopingImage;
	LoopingImage.prototype = Object.create(tabageos.EventDispatcher.prototype);
	Object.assign(LoopingImage.prototype, tabageos.CanvasObject.prototype);
    /** 
	*   
	*    A Rectangle defining where to draw from.
	*    
	* @memberof LoopingImage 
	*  
	*/
    LoopingImage.prototype.fRect = null;
    /** 
	*   @private
	*    
	*    
	* @memberof LoopingImage 
	*  
	*/
    LoopingImage.prototype.bI = 0;
    /** 
	*   
	*    A MoverPoint defining where in the canvas to draw to.
	*    
	* @memberof LoopingImage 
	*  
	*/
    LoopingImage.prototype.tPoint = null;
    /** 
	*   
	*    Loop the draw of an image horizontally. Useful for creating scrolling backgrounds.
	*	 This method should be called during a requestAnimationFrame loop.
	*    
	* @memberof LoopingImage.prototype 
	* @method loopHorizontal
	* @param imgToLoop {Image} The image to draw and loop horizontally.
	* @param w {Number} The width of the image
	* @param h {Number} The height of the image
	* @param incer {Number} Optional amount to increment by, default is 1.
    *
	*/
    LoopingImage.prototype.loopHorizontal = function(imgToLoop, w, h, incer) {
        this.fRect.x = this.bI;
        //backgroundI;//Apply the increment to the x position to copy from, starts from 0.
        this.fRect.y = 0;
        //y does not change, we are only moving horizontally.
        this.fRect.width = w;
        //the width of the image
        this.fRect.height = h;
        //the height of the image
        this.tPoint.x = 0;
        this.copyPixels(imgToLoop, this.fRect, this.tPoint, w, h);
        //draw the image from backgroundI to 500.
        if (this.bI > 0) {
            //when the backgroundI is 1 or more, also
            this.fRect.x = 0;
            //copy from the start,
            this.tPoint.x = w - this.bI;
            //but draw at the end, 
            this.fRect.width = this.bI;
            //using only the left out front part of the image.
            this.copyPixels(imgToLoop, this.fRect, this.tPoint, this.fRect.width, h);
        }
        if (this.bI < w) {
            this.bI += incer || 1;
        } else {
            this.bI = 0;
        }
    };
    tabageos.LoopingImage = LoopingImage;
})();


(function() { 
	'use strict';
    /** 
    *
    *@class MapMover
    * @classdesc
	*   A MoverSkeleton that moves confined to the map given.
	*    
	*    
	* 
	* @param x {Number} The x location of the MapMover
	* @param y {Number} The y location of the MapMover
	* @param width {Number} The width of the MapMover
	* @param height {Number} The height of the MapMover
	* @param map {Array} A 2D Array denoting the area that the MapMover can move in.
	*						The map can be a 2D Array with integer inner values as follows;
	*						var map = [ 
	*									[1,0,0,0,0,1],
	*									[1,0,0,0,0,1],
	*									[1,0,0,0,0,1],
	*									[1,1,1,1,1,1]
	*									];
	*
	*							(In the above case, the player would only be able to move in the 0 spots)
	*
	*						Or the map can be a 2D Array with array inner values as follows;
	*  							var map = [ 
	*										[[1,1],[0,0],[0,0],[0,0],[1,1]],
	*										[[1,1],[0,0],[0,0],[0,0],[1,1]],
	*										[[1,1],[0,0],[0,0],[0,0],[1,1]],
	*										[[1,1],[2,2],[2,2],[2,2],[1,1]]
	*										];
	*							(In the above case, the player would only be able to move in the [0,0] spots)
	*							(this map type can denote much more and is the default type for the BlitMath Class which is a map drawing helper class)
	*
	* @param [ca] {CanvasAnimation} The optional CanvasAnimation associated with this MapMover.
	* @param {Boolean} [dontCloneMap=false] If true is passed the map you pass in will not be cloned, otherwise the map you pass in is cloned, truly cloned, such that your constructed MapMover.map is Not a reference to your original map. The default opperation is to leave this alone, allowing your map to get cloned. See BlitMath.cloneMultiArray
	* @param [dt=.6666666667] {Number} delta time based on desired frame rate, the default is Tabageos.TimeKeeper._sae; 1000 / 60. Change the value of Tabageos.TimeKeeper._sae if you want to adjust the frame rate of your game. Default is 1000 / 60. for 60 frames per second.
	* @param [tw] {Number} The width of each tile in the map, default will be same as width
	* @param [th] {Number} The height of each tile in the map, default will be same as height
	* @param [mapRows] {Number} The amount of rows the map has. Optional, by default this will be calculated based on map. 
	* @param [mapColumns]  {Number} The amount of columns the map has. Optional, by default this will be calculated based on map.
	*  
	*/
    function MapMover(x,y,width,height, map,ca,dontCloneMap, dt, tw, th,mapRows, mapColumns) {
		tabageos.MoverSkeleton.call(this,x,y,width,height);
        this.width = width || 0;
        this.height = height || 0;
        this._middlePoint = new tabageos.MoverPoint();
        this._pos = new tabageos.MoverPoint(x || 0,y || 0);
        this._veloc = new tabageos.MoverPoint(0,0);
        this._lastVeloc = new tabageos.MoverPoint(0,0);
        this._lastPos = new tabageos.MoverPoint(x || 0,y || 0);
        this._deltaTime = dt || tabageos.TimeKeeper._sae;
        this._map = dontCloneMap ? map : tabageos.BlitMath.cloneMultiArray(map);
        this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
        this._state = 1;
        this.x = x || 0;
        this.y = y || 0;
        this._canvasAnimation = ca || null;
        this._checkHelper = new tabageos.MoverPoint();
		this._jumps = 0;
		this._jumpSpeed = 4;
		this._jsp = 1;
		this._walkSpeed = 4;
		this._gravityLevel = .285;
		this._pLeft = 0;
		this._npLeft = 0;
		this._pRight = 0;
		this._npRight = 0;
		this._grounded = 0;
		this._unGrounded = 1;
		this._atCeiling = 0;
		this._unCeiling = 1;
		this._mapRows = mapRows || map.length;
		this._mapColumns = mapColumns || map[0].length;
		this._tw = tw || this.width;
		this._th = th || this.height;
    }
	/** 
	*   
	*    
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype.constructor = MapMover;
    MapMover.prototype = Object.create(tabageos.MoverSkeleton.prototype);
	/** 
	*   
	*    @private
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._mapRows = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._mapColumns = 0;
    /** 
	*   
	*    
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype.stand = 1;
    /** 
	*   
	*    
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype.walk = 2;
    /** 
	*   
	*    
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype.up = 3;
    /** 
	*   
	*    
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype.down = 4;
    /** 
	*   
	*    @private
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._deltaTime = .666666667;
    /** 
	*   
	*    1 is idle
    *    2 is left and right
    *    3 is up
    *    4 is down, only when _jumps is 1.
    *
    *    The move method uses this property, if it gets changed before move is called, then the move method would start from that state.
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._state = 1;
    /** 
	*   
	*    If 1 then gravity will be applied to the MapMover. Platformer movement.
    *    By default _jumps is 0 for MapMovers. Topdown movement.
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._jumps = 0;
    /** 
	*   
	*    
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._jumpSpeed = 4;
    /** 
	*   @private
	*    
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._jsp = 1;
    /** 
	*   
	*    Default is 4.
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._walkSpeed = 4;
    /** 
	*   
	*    Default is .285, this only applies if _jumps is 1.
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._gravityLevel = .285;
    /** 
	*   
	*    Denotes if the MapMover is colliding left.
	*	 This property is set via the update method.
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._pLeft = 0;
    /** 
	*   
	*    
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._npLeft = 0;
    /** 
	*   
	*    Denotes if the MapMover is colliding right.
	*	 This property is set via the update method.
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._pRight = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._npRight = 0;
    /** 
	*   
	*    Denotes if the MapMover is colliding down.
	*	 This property is set via the update method.
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._grounded = 0;
    /** 
	*   @private
	*    
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._unGrounded = 1;
    /** 
	*   Denotes if the MapMover is colliding up.
	*	 This property is set via the update method.
	*    
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._atCeiling = 0;
    /** 
	*   @private
	*    
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._unCeiling = 1;
    /** 
	*   @private
	*    
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._checkHelper = null;
    /** 
	*   
	*    The 2D Array that the MapMover is confined to.
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._map = null;
    /** 
	*   
	*    A reference to the optional CanvasAnimation that is associated with this MapMover.
	*	 The CanvasAnimation would be used to display and animate the MapMover on a CanvasObject.
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._canvasAnimation = null;
    /** 
	*   The tile width of each tile in the map, default is 16.
	*    
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._tw = 16;
    /** 
	*   
	*    The tile height of each tile in the map, default is 16.
	*    
	* @memberof MapMover 
	*  
	*/
    MapMover.prototype._th = 16;
    
    
    /**
    *
    * Set up the MapMover to move tile by tile instead of fluidly.
    *
    * This method sets the following variables accordingly:
    *
    *  _jumps = 0; _deltaTime = 1; _jumpSpeed = tile width; ,maxSpeed = tile width. _walkSpeed = tile width.
    *
    * @memberof MapMover
    * @method setupForTileMove
    *
    *
    */
    MapMover.prototype.setupForTileMove = function() {
		
		this._jumps = 0;
		this._deltaTime = 1;
		this._jumpSpeed = this._tw+1-1;
		this.maxSpeed = this._tw +1-1;
		this._walkSpeed = this._tw+1-1;
		
	};
    /**
    *
    * Move tile by tile, call setupForTileMove once first, then you can use this method instead of move, also cancel all button presses after the call. 
    *  Also, if using the touch controller, you would want the touch controller to not capture touch move, so you would call removeTouchMove on the ControllerPad instance.
    * See the frogger example.
    *
    * @memberof MapMover
    * @method tileMove
    *
    * @param left {Boolean}
    * @param right {Boolean}
    * @param up {Boolean}
    * @param down {Boolean}
    *
    */
	MapMover.prototype.tileMove = function(left,right,up,down) {
		
			if(left && !this._pLeft) {
				this._veloc.x = -this._tw;
			} 
			if(right && !this._pRight) {
				this._veloc.x = this._tw;
			} 
			if(!left && !right) {
				this._veloc.x = 0;
			}
			if(up && !this._atCeiling) {
				this._veloc.y = -this._th;
			} 
			if(down && !this._grounded) {
				this._veloc.y = this._th;
			} 
			if(!up && !down) {
				this._veloc.y = 0;
			}
			this.update(0,1,0);
		
	};
    
    
	
    /** 
	*   Moves the MapMover, in the directions given, confined to the map given during construction.
	*    
	*    
	* @memberof MapMover.prototype 
	* @method move
	* @param left {Boolean}
	* @param right {Boolean}
	* @param up {Boolean}
	* @param down {Boolean}
    * 
	*/
    MapMover.prototype.move = function(left,right,up,down) {
           
            if(this._state == 1) {//idle
            
                this._veloc.x = 0; this._veloc.y = 0;

                if (!this._grounded || this._atCeiling) {
                    this._state = 3;

                } else if ((left && !right) || (right && !left)) {
                    this._state = 2;

                } else if (up && !this._atCeiling) {
                    
                    this._jsp = (this._jumpSpeed-2);
                    this._veloc.y = this._jumps ? -(this._jumpSpeed-(this._jumpSpeed-2)) : -this._jumpSpeed;
                    this._state = 3;
                    
                } else if( !up && !this._jumps && down) {
                    
                    this._veloc.y = this._walkSpeed;
                    this._state = 4;
                }
                
                this.update(); return;
            }
            if(this._state == 2) { //left right
                if (!left && !right) {
                    this._state = 1;
                    this._veloc.x = 0; this._veloc.y = 0;

                } else if (right) {
                    if (this._pRight)
                        this._veloc.x = 0;
                    else
                        this._veloc.x = this._walkSpeed;
                    
                } else if (left) {
                    if (this._pLeft)
                        this._veloc.x = 0;
                    else
                        this._veloc.x = -this._walkSpeed;
                } 

                if (up && !this._atCeiling) {
                    
                    this._jsp = (this._jumpSpeed-2);
                    this._veloc.y = this._jumps ? -(this._jumpSpeed-(this._jumpSpeed-2)) : -this._jumpSpeed;
                    this._state = 3;

                } else if (!up && !this._grounded) {
                    this._state = 3;

                }
                this.update(); return;
            }

            if(this._state ==3) { //up
              
                if(!this._jumps) {
                    if(up && !this._atCeiling) {
                        this._veloc.y = -this._walkSpeed;
                    } else {
                        this._veloc.y = 0;
                    }
                    if(!up) {
                        if(!left && !right && !down) {
                            this._state = 1; this._veloc.x = 0; this._veloc.y = 0;
                        } else if ((left || right) && !down) {
                            this._state = 2;this._veloc.y = 0;
                        } else if(down) {
                            this._state = 4;this._veloc.y = this._walkSpeed;
                        }
                    }
                } else { //allow for jumping based on how long up pressed, and apply gravity to _veloc.y
                
                    if(up && !this._atCeiling && this._veloc.y > -this._jumpSpeed && this._jsp != 0) {
                        this._jsp -= 1; this._veloc.y = -(this._jumpSpeed-this._jsp); 
                    } else {
                        this._jsp = 0;
                    }

                    this._veloc.y += this._gravityLevel * this._deltaTime;
                    
                    if(this._veloc.y > this._jumpSpeed) {
                        this._veloc.y = this._jumpSpeed+1-1;  
                    } 
                
                    if (!up && this._veloc.y > 0) {
                        this._veloc.y = this._veloc.y > this._jumpSpeed ? this._jumpSpeed+1-1 : this._veloc.y;
                    }
                }
                
                if (!right && !left) {
                    this._veloc.x = 0;
                } else if (right) {
                    if (this._pRight)
                        this._veloc.x = 0;
                    else
                        this._veloc.x = this._walkSpeed;
                   
                } else if (left) {
                    if (this._pLeft)
                        this._veloc.x = 0;
                    else
                        this._veloc.x = -this._walkSpeed;
                }

                if (this._grounded) {
                    if (!right && !left) {
                        this._state = 1;
                        this._veloc.x = 0; this._veloc.y = 0;
                        
                    } else  {
                        this._state = 2;
                        this._veloc.y = 0;
                    } 
                } else {
                    
                    if(!this._jumps && down) {
                        this._veloc.y = this._walkSpeed;
                        this._state = 4;
                    } 
                }
                this.update(); return;
            }
        
            if(!this._jumps && this._state == 4) { //down (when _jumps = 0)
                if(down && !this._grounded) {
                    this._veloc.y = this._walkSpeed;
                } else {
                    this._veloc.y = 0;
                }
                if(!down) {
                    if(!left && !right) {
                        this._state = 1; this._veloc.x = 0; this._veloc.y = 0;
                    } else {
                        this._state = 2;this._veloc.y = 0;
                    }
                }
                
                if (!right && !left) {
                    this._veloc.x = 0;
                } else if (right) {
                    if (this._pRight)
                        this._veloc.x = 0;
                    else
                        this._veloc.x = this._walkSpeed;
                   
                } else if (left) {
                    if (this._pLeft)
                        this._veloc.x = 0;
                    else
                        this._veloc.x = -this._walkSpeed;
                }
            
                if (this._atCeiling) {
                    if (!right && !left) {
                        this._state = 1;
                        this._veloc.x = 0; this._veloc.y = 0;
                        
                    } else  {
                        this._state = 2;
                        this._veloc.y = 0;
                    } 
                }
                this.update(); return;
            }
        
    };
    /** 
	*   
	*    This methos is called by the move method, and is the method handling _pos updates and collisions.
	*    
	* @memberof MapMover.prototype 
	* @method update
	* @param dontApplyToXY {Boolean}
    * 
	*/
    MapMover.prototype.update = function(dontApplyToXY) {
        this._lastPos.x = this._pos.x +1-1;
        this._lastPos.y = this._pos.y +1-1;
        this._lastVeloc.x = this._veloc.x+1-1;
        this._lastVeloc.y = this._veloc.y+1-1;
        this._unGrounded =  this._grounded+1-1;
        
        this._npRight = this._pRight+1-1;
        this._npLeft = this._pLeft+1-1;
        this._unCeiling = this._atCeiling+1-1;
        
        this._pos.x += this._veloc.x*this._deltaTime;
        this._pos.y += this._veloc.y*this._deltaTime;
        
        var pgy, pgx;
        pgx = this.isLeftPushingOnMap(this._lastPos,this._pos,this._veloc,this._map,this._tw,this._th);
        if(pgx > 0) {
            this._pLeft = 1;
            this._pos.x = pgx +1;
            this._veloc.x = 0;
        } else {
            
            this._pLeft = 0;
        }
        
        pgx = this.isRightPushingOnMap(this._lastPos,this._pos,this._veloc,this._map,this._tw,this._th);
        if(pgx > 0) {
            this._pRight = 1;
            this._pos.x = pgx - this.width;
            this._veloc.x = 0;
        } else {
            
            this._pRight = 0;
        }
        
        pgy = this.isGroundedOnMap(this._lastPos,this._pos,this._veloc,this._map,this._tw,this._th);
        if(pgy > 0){
            this._grounded = 1;
            this._pos.y = pgy - this.height;
            this._veloc.y = 0;
        } else {
            this._grounded = 0;
        }
        
        pgy = this.isHeadHitOnMap(this._lastPos,this._pos,this._veloc,this._map,this._tw,this._th);
        if(pgy > 0) {
            this._atCeiling = 1;
			if(this._jumps) {
				if(this._pos.y < pgy) this._pos.y = pgy ;
				if(this._veloc.y < 0) this._veloc.y = (this._jumps && !this._grounded) ? this._walkSpeed : 0;//
			} else {
				this._pos.y = pgy;
				this._veloc.y = 0;
			}
	   } else {
            this._atCeiling = 0;
			
        }
        
        if(!dontApplyToXY) {
            this.setX( this._pos.x +1-1 );
            this.setY( this._pos.y +1-1 );
        }
		
		if(this._autoAnimate && this._canvasAnimation) {

            this._canvasAnimation.x = Math.round(this.x);
			this._canvasAnimation.y = Math.round(this.y);
					
			this._canvasAnimation.changeDirectionAnimation(this._veloc.x < 0,this._lastVeloc.x > 0, this._veloc.y < 0, this._veloc.y > 0);
					
			this._canvasAnimation.animate(this._autoAnimationThrottle);
			this._canvasAnimation.blit();
        
        } else if(this._autoAnimate && this._directCanvasObject) {


            this._directCanvasObject.context.fillRect(Math.round(this.x),Math.round(this.y),this.width,this.height);
            


        }
		
    };
    /** 
	*   
	*    Used by the update method
	*    
	* @memberof MapMover.prototype 
	* @method isGroundedOnMap
	* @param last 
	* @param curr 
	* @param veloc 
	* @param map 
	* @param tw 
	* @param th 
    * @returns {Number}  The y position of the collision
	*/
    MapMover.prototype.isGroundedOnMap = function(last, curr, veloc, map,tw,th) {
        
       var  bLx = this._pos.x+1-1; var bLy = this._pos.y+this.height +  ((this._veloc.y < 1 ? 1 : this._veloc.y));
        var bRx = this._pos.x + this.width;
        var tile; var gy = -999;var iX = 0; var iY = 0;var cmb = 0;var ciy; var cix;
        
        while(bLx < bRx) {
           // tile = tabageos.BlitMath.getTileDataAt(bLx,bLy,map,tw,th);
            tabageos.BlitMath.fasterCheckTileValueAt(bLx,bLy,this._mapRows,this._mapColumns,tw,th,this._checkHelper);
			ciy = this._checkHelper.y; cix = this._checkHelper.x;
			tile = this._map[ciy][cix];
            if(tile && ((tile[0] != 0 || tile[1] != 0))) {  //xValueFromPosition(bLx,bLy,tw,th,this._map);
                gy = (ciy*th) +1-1;//tile.position.y +1-1; 
                if(gy < bLy) {  } else { gy = -1; }
            }
            bLx += (tw > this.width ? this.width : tw) / 4;
            
        } return gy;
    };
	
    /** 
	*   
	*    Used by the update method
	*    
	* @memberof MapMover.prototype 
	* @method isHeadHitOnMap
	* @param last 
	* @param curr 
	* @param veloc 
	* @param map 
	* @param tw 
	* @param th 
    * @returns {Number} The y position of the collision
	*/
    MapMover.prototype.isHeadHitOnMap = function(last, curr, veloc, map,tw,th) {
        
        var bLx = this._pos.x+1-1; var bLy = this._pos.y -1 - (-(this._veloc.y));
        var bRx = this._pos.x + this.width;
        var tile; var gy = -999;var iX = 0; var iY = 0; var cmb = 0;var ciy; var cix;
        while(bLx < bRx) {
           // tile = tabageos.BlitMath.getTileDataAt(bLx,bLy,map,tw,th);
            tabageos.BlitMath.fasterCheckTileValueAt(bLx,bLy,this._mapRows,this._mapColumns,tw,th, this._checkHelper);
			ciy = this._checkHelper.y; cix = this._checkHelper.x;
			tile = this._map[ciy][cix];
            if(tile && ((tile[0] != 0 || tile[1] != 0))) {
                gy = (ciy*th) +th; 
                if(gy > bLy) {  } else { gy = -1; }
            }
            bLx += (tw > this.width ? this.width : tw);
            
        } return gy;
    };
    /** 
	*   
	*    Used by the update method
	*    
	* @memberof MapMover.prototype 
	* @method isRightPushingOnMap
	* @param last 
	* @param curr 
	* @param veloc 
	* @param map 
	* @param tw 
	* @param th 
    * @returns {Number}  The x position of the collision
	*/
    MapMover.prototype.isRightPushingOnMap = function(last, curr, veloc, map,tw,th) {
        
        var Tpy = this._pos.y+1-1; var Bty = this._pos.y + this.height;
        var rx = this._pos.x + (this.width) + 1;
        var tile; var gx = -999;var iX = 0; var iY = 0;var cmb = 0;var ciy; var cix;
        while(Tpy < Bty) {
            //tile = tabageos.BlitMath.getTileDataAt(rx,Tpy,map,tw,th);
            tabageos.BlitMath.fasterCheckTileValueAt(rx,Tpy,this._mapRows,this._mapColumns,tw,th, this._checkHelper);
			ciy = this._checkHelper.y; cix = this._checkHelper.x;
			tile = this._map[ciy][cix];
            if(tile && ( (tile[0] != 0 || tile[1] != 0))) {
                gx = (cix*tw) +1-1;//tile.position.x +1-1; 
                if(gx < rx) { break; } else { gx = -1; }
            }
            Tpy += (th > this.height ? this.height : th) ;
            
        } return gx;
    };
    /** 
	*   
	*    Used by the update method
	*    
	* @memberof MapMover.prototype 
	* @method isLeftPushingOnMap
	* @param last 
	* @param curr 
	* @param veloc 
	* @param map 
	* @param tw 
	* @param th 
    * @returns {Number} The x position of the collision
	*/
    MapMover.prototype.isLeftPushingOnMap = function(last, curr, veloc, map,tw,th) {
        
        var Tpy = this._pos.y+1-1; var Bty = this._pos.y + this.height;
        var lx = this._pos.x -1;
        var tile; var gx = -999;var iX = 0; var iY = 0; var cmb = 0;var ciy; var cix;
        while(Tpy < Bty) {
           // tile = tabageos.BlitMath.getTileDataAt(lx,Tpy,map,tw,th);
            tabageos.BlitMath.fasterCheckTileValueAt(lx,Tpy,this._mapRows,this._mapColumns,tw,th,this._checkHelper);
			ciy = this._checkHelper.y; cix = this._checkHelper.x;
			tile = this._map[ciy][cix];
            if(tile && ( (tile[0] != 0 || tile[1] != 0))) {
                gx = (cix*tw) + tw;//tile.position.x +tw; 
                if(gx > lx) { break; } else { gx = -1; }
            }
            Tpy += (th > this.height ? this.height : th) ;
            
        } return gx;
    };
    tabageos.MapMover = MapMover;
    
})();
//

(function() { 

	'use strict';
    
    
    /** 
    *
    *
    *@class MapTraveler
    * @classdesc
	*   A MapTraveler moves around in a tiled map using velocity, basic jumping and collisions are handled.
	*    MapTravelers extend TravelerSkeleton and mass, maxSpeed via forceApplier are factors involvide with velocity updates. 
	*    
	* 
	* @param x {Number} The x location of the MapTraveler
	* @param y {Number} The y location of the MapTraveler
	* @param width {Number} The width of the MapTraveler
	* @param height {Number} The height of the MapTraveler
	* @param map {Array} The 2D Array map the MapTraveler should be confined to. see _map
	* @param [ca] {CanvasAnimation} Optional CanvasAnimation to display and animate the MapTraveler
	* @param [dontCloneMap=false] {Boolean} Optional to not clone the map that is passed in during construction.
	* @param [dt=.6666666667] {Number} Optiona delta time value, default is TimeKeeper._sae  .6666666667 see TimeKeeper.
	* @param [tileW] {Number} The default tile width for each tile in the map.
	* @param [tileH] {Number} The default tile height for each tile in the map.
	* @param [mapRows] {Number} The amount of rows that the map has.
	* @param [mapColumns] {Number} The amount of columns that the map has.
	*  
    * @see TravelerSkeleton
    *
	*/
    function MapTraveler(x,y,width,height, map,ca,dontCloneMap, dt, tileW, tileH, mapRows, mapColumns) {
		tabageos.TravelerSkeleton.call(this,x,y,width,height);
        this.width = width || 0;
        this.height = height || 0;
        this._middlePoint = new tabageos.MoverPoint();
        this._pos = new tabageos.MoverPoint(x,y);
        this._veloc = new tabageos.MoverPoint(0,0);
        this._lastVeloc = new tabageos.MoverPoint(0,0);
        this._lastPos = new tabageos.MoverPoint(x,y);
        this._deltaTime = dt || tabageos.TimeKeeper._sae;
        this._map = dontCloneMap ? map : tabageos.BlitMath.cloneMultiArray(map);
        this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
        this._state = 1;
        this.forceApplier = new tabageos.MoverPoint();
        this.forceHolder = new tabageos.MoverPoint();
        this._canvasAnimation = ca || null;
        this._w = width || 0;
        this._h = height || 0;
        this.wanderOffset = new tabageos.MoverPoint(0,0);
        this.blankMO = new tabageos.MoverPoint();
        this._eventDispatcher = new tabageos.EventDispatcher();
        this.x = x || 0;
        this.y = y || 0;
        this._checkHelper = new tabageos.MoverPoint();
		this._jumps = 0;
		this._jumpSpeed = 4;
		this._jsp = 1;
		this._walkSpeed = 4;
		this._gravityLevel = .285;
		this.health = 100;
		this._pLeft = 0;
		this._npLeft = 0;
		this._pRight = 0;
		this._npRight = 0;
		this._grounded = 0;
		this._unGrounded = 1;
		this._atCeiling = 0;
		this._unCeiling = 1;
		this.path = [];
		this._mapRows = mapRows || map.length;//j
		this._mapColumns = mapColumns || map[0].length;//i
		this._tw = tileW || this.width;
		this._th = tileH || this.height;
		this.destination = new tabageos.MoverPoint();
    };
	/** 
	*   
	*    
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype.constructor = MapTraveler;
    MapTraveler.prototype = Object.create(tabageos.TravelerSkeleton.prototype);
	/** 
	*   
	*    @private
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._mapRows = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._mapColumns = 0;
    /** 
	*   
	*   The stand state: 1. 
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype.stand = 1;
    /** 
	*   
	*    The walk state: 2.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype.walk = 2;
    /** 
	*   
	*    The up state: 3.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype.up = 3;
    /** 
	*   
	*    A reference to the CanvasAnimation passed in during construction.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._canvasAnimation = null;
    /** 
	*   
	*    The down state: 4.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype.down = 4;
    /** 
	*   
	*    @private
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._deltaTime = .666666667;
    /** 
	*   
	*    The current state of the MapTraveler, 1 2 3 or 4; stand, walk, up down.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._state = 1;
    /** 
	*   
	*    @private
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._checkHelper;
    /** 
	*   
	*    If _jumps is 1 then the MapTraveler will jump up and fall back down having gravity applied when falling,
    * 	if _jumps is 0 it will move in all directions in the same manner. _jumps is 0 by default for MapTravelers.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._jumps = 0;
    /** 
	*   
	*    _jumpSpeed affects how fast it jumps up when _jumps is 1.
	*    _veloc.y is set to this value for jumping during move calls.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._jumpSpeed = 4;
    /** 
	*   
	*    @private
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._jsp = 1;
    /** 
	*   _walkSpeed defines how fast it will move horizontally, 
	*   _veloc.x is set to this value during .move calls.
	*    
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._walkSpeed = 4;
    /** 
	*   
	*   The amount of gravity to apply for jumping, defaut is .285. 
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._gravityLevel = .285;
    /** 
	*   
	*    Denotes if the MapTravelers is colliding left.
	*    This value should not be manually changed, the .update method calculates this value.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._pLeft = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._npLeft = 0;
    /** 
	*   
	*    Denotes if the MapTraveler is colliding right.
	*    This value should not be manually changed, the .update method calculates this value.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._pRight = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._npRight = 0;
    /** 
	*   
	*    Denotes if the MapTraveler is colliding downward.
	*    This value should not be manually changed, the .update method calculates this value.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._grounded = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._unGrounded = 1;
	/** 
	*   
	*    A value present so that one can use it.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype.health = 100;
    /** 
	*   
	*    Denotes that the MapTraveler is colliding upward.
	*    This value should not be manually changed, the .update method calculates this value.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._atCeiling = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._unCeiling = 1;
    /** 
	*   
	*    A 2D Array denoting the area that the MapTraveler can move in.
	*						The map can be a 2D Array with integer inner values as follows;
	*						var map = [ 
	*									[1,0,0,0,0,1],
	*									[1,0,0,0,0,1],
	*									[1,0,0,0,0,1],
	*									[1,1,1,1,1,1]
	*									];
	*
	*							(In the above case, it would only be able to move in the 0 spots)
	*
	*						Or the map can be a 2D Array with Array inner values as follows;
	*  							var map = [ 
	*										[[1,1],[0,0],[0,0],[0,0],[1,1]],
	*										[[1,1],[0,0],[0,0],[0,0],[1,1]],
	*										[[1,1],[0,0],[0,0],[0,0],[1,1]],
	*										[[1,1],[2,2],[2,2],[2,2],[1,1]]
	*										];
	*							(In the above case, it would only be able to move in the [0,0] spots)
	*							(this map type can denote much more and is the default type for the BlitMath Class which is a map drawing helper class)
	*
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._map = null;
    /** 
	*   
	*    The default tile width of each tile in the map.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._tw = 16;
    /** 
	*   
	*    The default tile height of each tile in the map.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype._th = 16;
	/** 
	*   
	*    A MoverPoint the MapTraveler is going to, can be used with the methods inherited from TravelerSkeleton.
	*    
	* @memberof MapTraveler 
	*  
	*/
    MapTraveler.prototype.destination = null;
    
	
    /** 
	*   
	*    Moves the MapTraveler left, right, up, and down and confines it to the map given during construction.
	*    Velocity is controlled by this method, it gets set to either _walkSpeed or _jumpSpeed based on the paramaters passed and the current _state of the MapTraveler.
	*    This method opperates and results in the same behavior as the MapMover Class if dontApplyForce is true (or 1). [ by default it is false]
	* 	 If dontApplyForce is left out [false] forceApplier is used and therefore maxForce, mass, and maxSpeed are applied to velocity. All the TravelerSkeleton methods change and use forceApplier.
	*	 The move method encapsulates and controlls .update calls, dontApplyForce is also available as the last param of the update method.
	*    But to fully utilize the Traveler aspect of this Class, MapTraveler, one would adjust the velocity (_veloc), or use one of the TravelerSkeleton inherited methods, then use update without the move method.
	*  	 (see update)
	*
	* @memberof MapTraveler.prototype 
	* @method move
	* @param left  {Boolean}
	* @param right {Boolean}
	* @param up {Boolean}
	* @param down {Boolean}
	* @param [dontApplyForce=false] {Boolean} Default is false.
    * 
	*/
    MapTraveler.prototype.move = function(left,right,up,down, dontApplyForce) {
           
            if(this._state == 1) {//idle
            
                this._veloc.x = 0; this._veloc.y = 0;

                if (!this._grounded || this._atCeiling) {
                    this._state = 3;

                } else if ((left && !right) || (right && !left)) {
                    this._state = 2;

                } else if (up && !this._atCeiling) {
                    
                    this._jsp = (this._jumpSpeed-2);
                    this._veloc.y = this._jumps ? -(this._jumpSpeed-(this._jumpSpeed-2)) : -this._jumpSpeed;
                    this._state = 3;
                    
                } else if( !up && !this._jumps && down) {
                    
                    this._veloc.y = this._walkSpeed;
                    this._state = 4;
                }
                
                this.update(0,dontApplyForce); return;
            }
            if(this._state == 2) { //left right
                if (!left && !right) {
                    this._state = 1;
                    this._veloc.x = 0; this._veloc.y = 0;

                } else if (right) {
                    if (this._pRight) {
                        this._veloc.x = 0;
                    } else {
                        if(easeFuncString) {
                           // this[easeFuncString](this._pos.addBy(4,0,1));// this._veloc.x = this._walkSpeed;
                        } else {
                            this._veloc.x = this._walkSpeed;
                        }
                        
                    }
                    
                } else if (left) {
                    if (this._pLeft) {
                        this._veloc.x = 0;
                    } else {
                        if(easeFuncString) {
                            //this[easeFuncString](this._pos.addBy(-4,0,1));// this._veloc.x = -this._walkSpeed;
                        } else {
                            this._veloc.x = -this._walkSpeed;
                        }
                       
                    }
                } 

                if (up && !this._atCeiling) {
                    
                    this._jsp = (this._jumpSpeed-2);
                    this._veloc.y = this._jumps ? -(this._jumpSpeed-(this._jumpSpeed-2)) : -this._jumpSpeed;
                    this._state = 3;

                } else if (!up && !this._grounded) {
                    this._state = 3;

                }
                this.update(0,dontApplyForce); return;
            }

            if(this._state ==3) { //up
              
                if(!this._jumps) {
                    if(up && !this._atCeiling) {
                        this._veloc.y = -this._walkSpeed;
                    } else {
                        this._veloc.y = 0;
                    }
                    if(!up) {
                        if(!left && !right && !down) {
                            this._state = 1; this._veloc.x = 0; this._veloc.y = 0;
                        } else if ((left || right) && !down) {
                            this._state = 2;this._veloc.y = 0;
                        } else if(down) {
                            this._state = 4;this._veloc.y = this._walkSpeed;
                        }
                    }
                } else { //allow for jumping based on how long up pressed, and apply gravity to _veloc.y
                
                    if(up && !this._atCeiling && this._veloc.y > -this._jumpSpeed && this._jsp != 0) {
                        this._jsp -= 1; this._veloc.y = -(this._jumpSpeed-this._jsp); 
                    } else {
                        this._jsp = 0;
                    }

                    this._veloc.y += this._gravityLevel * this._deltaTime;
                    
                    if(this._veloc.y > this._jumpSpeed) {
                        this._veloc.y = this._jumpSpeed+1-1;  
                    } 
                
                    if (!up && this._veloc.y > 0) {
                        this._veloc.y = this._veloc.y > this._jumpSpeed ? this._jumpSpeed+1-1 : this._veloc.y;
                    }
                }
                
                if (!right && !left) {
                    this._veloc.x = 0;
                } else if (right) {
                    if (this._pRight)
                        this._veloc.x = 0;
                    else
                        this._veloc.x = this._walkSpeed;
                   
                } else if (left) {
                    if (this._pLeft)
                        this._veloc.x = 0;
                    else
                         this._veloc.x = -this._walkSpeed;
                }

                if (this._grounded) {
                    if (!right && !left) {
                        this._state = 1;
                        this._veloc.x = 0; this._veloc.y = 0;
                        
                    } else  {
                        this._state = 2;
                        this._veloc.y = 0;
                    } 
                } else {
                    
                    if(!this._jumps && down) {
                        this._veloc.y = this._walkSpeed;
                        this._state = 4;
                    } 
                }
                this.update(0,dontApplyForce); return;
            }
        
            if(!this._jumps && this._state == 4) { //down (when _jumps = 0)
                if(down && !this._grounded) {
                    this._veloc.y = this._walkSpeed;
                } else {
                    this._veloc.y = 0;
                }
                if(!down) {
                    if(!left && !right) {
                        this._state = 1; this._veloc.x = 0; this._veloc.y = 0;
                    } else {
                        this._state = 2;this._veloc.y = 0;
                    }
                }
                
                if (!right && !left) {
                    this._veloc.x = 0;
                } else if (right) {
                    if (this._pRight)
                        this._veloc.x = 0;
                    else
                        this._veloc.x = this._walkSpeed;
                   
                } else if (left) {
                    if (this._pLeft)
                        this._veloc.x = 0;
                    else
                        this._veloc.x = -this._walkSpeed;
                }
            
                if (this._atCeiling) {
                    if (!right && !left) {
                        this._state = 1;
                        this._veloc.x = 0; this._veloc.y = 0;
                        
                    } else  {
                        this._state = 2;
                        this._veloc.y = 0;
                    } 
                }
                this.update(0,dontApplyForce); return;
            }
        
    };
    
    
    
    
    /**
    *
    * Set up the MapTraveler to move tile by tile instead of fluidly.
    *
    * This method sets the following variables accordingly:
    *
    *  _jumps = 0; _deltaTime = 1; _jumpSpeed = tile width; ,maxSpeed = tile width. _walkSpeed = tile width.
    *
    * @memberof MapTraveler
    * @method setupForTileMove
    *
    *
    */
    MapTraveler.prototype.setupForTileMove = function() {
		
		this._jumps = 0;
		this._deltaTime = 1;
		this._jumpSpeed = this._tw+1-1;
		this.maxSpeed = this._tw +1-1;
		this._walkSpeed = this._tw+1-1;
		
	};
    /**
    *
    * Move tile by tile, call setupForTileMove once first, then you can use this method instead of move, also cancel all button presses after the call. 
    *  Also, if using the touch controller, you would want the touch controller to not capture touch move, so you would call removeTouchMove on the ControllerPad instance.
    * See the frogger example.
    *
    * @memberof MapTraveler
    * @method tileMove
    *
    * @param left {Boolean}
    * @param right {Boolean}
    * @param up {Boolean}
    * @param down {Boolean}
    *
    */
	MapTraveler.prototype.tileMove = function(left,right,up,down) {
		
			if(left && !this._pLeft) {
				this._veloc.x = -this._tw;
			} 
			if(right && !this._pRight) {
				this._veloc.x = this._tw;
			} 
			if(!left && !right) {
				this._veloc.x = 0;
			}
			if(up && !this._atCeiling) {
				this._veloc.y = -this._th;
			} 
			if(down && !this._grounded) {
				this._veloc.y = this._th;
			} 
			if(!up && !down) {
				this._veloc.y = 0;
			}
			this.update(0,1,0);
		
	};
    
    
    
    
    
    
    /** 
	*   
	*    The update method applies velocity to the position of the MapTraveler,
	*    and then only changes velocity to 0 if there is collision.
	* 	 One could utilze TravelerSkeleton methods as follows;
	*	     var mt = new tabageos.MapTraveler( ... );
	*		 mt._veloc.x = 1;
	*	 	 mt.easeTo(MoverPoint);
	*		 mt.update();    
	*
	* @memberof MapTraveler.prototype 
	* @method update
	* @param [dontApplyToXY=false] {Boolean} If true, x and y are not updated, ._pos and just ._veloc (velocity).
	* @param [dontApplyForce=false] {Boolean} If true, forceApplier will not be used and therefore the method opperates the same way as a MapMover, to utilize the TravelerSkeleton inherited methods this value must be the default false.
    * 
	*/
    MapTraveler.prototype.update = function(dontApplyToXY, dontApplyForce) {
        this._lastPos.x = this._pos.x +1-1;
        this._lastPos.y = this._pos.y +1-1;
        this._lastVeloc.x = this._veloc.x+1-1;
        this._lastVeloc.y = this._veloc.y+1-1;
        this._unGrounded =  this._grounded+1-1;
        
        this._npRight = this._pRight+1-1;
        this._npLeft = this._pLeft+1-1;
        this._unCeiling = this._atCeiling+1-1;
        
        if(!dontApplyForce) {
			this.forceApplier.truncate(this.maxForce);
			this.forceApplier.divide(this.mass, 0);
			this._veloc.add(this.forceApplier.multiply(this._deltaTime,0), 0);
			this.forceApplier.reset();
			this._veloc._length = 0;
			this._veloc._angle = 0;
			this._veloc.truncate(this.maxSpeed);
		}
        this._pos.addBy(this._veloc.x * this._deltaTime, this._veloc.y * this._deltaTime, 0);
        
        
        var pgy, pgx;
        pgx = this.isLeftPushingOnMap(this._lastPos,this._pos,this._veloc,this._map,this._tw,this._th);
        if(pgx > 0) {
            this._pLeft = 1;
            this._pos.x = pgx +1;
            this._veloc.x = 0;
        } else {
            
            this._pLeft = 0;
        }
        
        pgx = this.isRightPushingOnMap(this._lastPos,this._pos,this._veloc,this._map,this._tw,this._th);
        if(pgx > 0) {
            this._pRight = 1;
            this._pos.x = pgx - this.width;
            this._veloc.x = 0;
        } else {
            
            this._pRight = 0;
        }
        
        pgy = this.isGroundedOnMap(this._lastPos,this._pos,this._veloc,this._map,this._tw,this._th);
        if(pgy > 0){
            this._grounded = 1;
            this._pos.y = pgy - this.height;
            this._veloc.y = 0;
        } else {
            this._grounded = 0;
        }
        
        pgy = this.isHeadHitOnMap(this._lastPos,this._pos,this._veloc,this._map,this._tw,this._th);
        if(pgy > 0) {
            this._atCeiling = 1;
            this._pos.y = pgy ;
            if(this._veloc.y < 0) this._veloc.y = 0;
        } else {
            this._atCeiling = 0;
        }
        
        if(!dontApplyToXY) {
            this.x = Math.round(this._pos.x +1-1);
            this.y = Math.round(this._pos.y +1-1);
        }
    };
    /** 
	*   
	*   Returns where the MapTraveler is touching the ground based on the map given.
	*   The update method uses this method using the params given during construction of the Class.
	*   The ._grounded property is set by the update method based on this method.
	*    
	* @memberof MapTraveler.prototype 
	* @method isGroundedOnMap
	* @param last {MoverPoint} this._lastPost
	* @param curr {MoverPoint} this._pos
	* @param veloc {MoverPoint} this._veloc
	* @param map {Array} this._map
	* @param tw {Number} this._tw
	* @param th {Number} this._th
    * @returns {Number} 
	*/
    MapTraveler.prototype.isGroundedOnMap = function(last, curr, veloc, map,tw,th) {
        
       var  bLx = this._pos.x+1-1; var bLy = this._pos.y+this.height +  ((this._veloc.y < 1 ? 1 : this._veloc.y));
        var bRx = this._pos.x + this.width;
        var tile; var gy = -999;var iX = 0; var iY = 0;var cmb;var cix; var ciy;
        
        while(bLx < bRx) {
           // tile = tabageos.BlitMath.getTileDataAt(bLx,bLy,map,tw,th);
            tabageos.BlitMath.fasterCheckTileValueAt(bLx,bLy,this._mapRows,this._mapColumns,tw,th,this._checkHelper);
			ciy = this._checkHelper.y; cix = this._checkHelper.x;
			tile = this._map[ciy][cix];
            if(tile && (tile[0] != 0 || tile[1] != 0)) {
                gy = (ciy*th) +1-1;//tile.position.y +1-1; 
                if(gy < bLy) {  } else { gy = -1; }
            }
            bLx += (tw > this.width ? this.width : tw) / 4;
            
        } return gy;
    };
    /** 
	*   
	*    Returns where the MapTraveler is touching a ceiling based on the map given.
	*   The update method uses this method using the params given during construction of the Class.
	*   The ._atCeiling property is set by the update method based on this method.
	*    
	* @memberof MapTraveler.prototype 
	* @method isHeadHitOnMap
	* @param last {MoverPoint} this._lastPost
	* @param curr {MoverPoint} this._pos
	* @param veloc {MoverPoint} this._veloc
	* @param map {Array} this._map
	* @param tw {Number} this._tw
	* @param th {Number} this._th
    * @returns {Number}  
	*/
    MapTraveler.prototype.isHeadHitOnMap = function(last, curr, veloc, map,tw,th) {
        
        var bLx = this._pos.x+1-1; var bLy = this._pos.y -1 - (-(this._veloc.y));
        var bRx = this._pos.x + this.width;
        var tile; var gy = -999;var iX = 0; var iY = 0;var cmb = 0;var cix; var ciy;
        while(bLx < bRx) {
           // tile = tabageos.BlitMath.getTileDataAt(bLx,bLy,map,tw,th);
            cmb = tabageos.BlitMath.fasterCheckTileValueAt(bLx,bLy,this._mapRows,this._mapColumns,tw,th, this._checkHelper);
			ciy = this._checkHelper.y; cix = this._checkHelper.x;
			tile = this._map[ciy][cix];
            if(tile && (tile[0] != 0 || tile[1] != 0)) {
                gy = (ciy*th) +th; 
                if(gy > bLy) {  } else { gy = -1; }
            }
            bLx += (tw > this.width ? this.width : tw);
            
        } return gy;
    };
    /** 
	*   
	*    Returns where the MapTraveler is colliding right based on the map given.
	*   The update method uses this method using the params given during construction of the Class.
	*   The ._pRight property is set by the update method based on this method.
	*    
	* @memberof MapTraveler.prototype 
	* @method isRightPushingOnMap
	* @param last {MoverPoint} this._lastPost
	* @param curr {MoverPoint} this._pos
	* @param veloc {MoverPoint} this._veloc
	* @param map {Array} this._map
	* @param tw {Number} this._tw
	* @param th {Number} this._th
    * @returns {Number}  
	*/
    MapTraveler.prototype.isRightPushingOnMap = function(last, curr, veloc, map,tw,th) {
        
        var Tpy = this._pos.y+1-1; var Bty = this._pos.y + this.height;
        var rx = this._pos.x + (this.width) + 1;
        var tile; var gx = -999;var iX = 0; var iY = 0;var cmb = 0;var cix; var ciy;
        while(Tpy < Bty) {
            //tile = tabageos.BlitMath.getTileDataAt(rx,Tpy,map,tw,th);
            cmb = tabageos.BlitMath.fasterCheckTileValueAt(rx,Tpy,this._mapRows,this._mapColumns,tw,th, this._checkHelper);
			ciy = this._checkHelper.y; cix = this._checkHelper.x;
			tile = this._map[ciy][cix];
            if(tile && (tile[0] != 0 || tile[1] != 0)) {
                gx = (cix*tw) +1-1;//tile.position.x +1-1; 
                if(gx < rx) { break; } else { gx = -1; }
            }
            Tpy += (th > this.height ? this.height : th) ;
            
        } return gx;
    };
    /** 
	*    Returns where the MapTraveler is colliding left based on the map given.
	*   The update method uses this method using the params given during construction of the Class.
	*   The ._pLeft property is set by the update method based on this method.
	*    
	*    
	* @memberof MapTraveler.prototype 
	* @method isLeftPushingOnMap
	* @param last {MoverPoint} this._lastPost
	* @param curr {MoverPoint} this._pos
	* @param veloc {MoverPoint} this._veloc
	* @param map {Array} this._map
	* @param tw {Number} this._tw
	* @param th {Number} this._th
    * @returns {Number}  
	*/
    MapTraveler.prototype.isLeftPushingOnMap = function(last, curr, veloc, map,tw,th) {
        
        var Tpy = this._pos.y+1-1; var Bty = this._pos.y + this.height;
        var lx = this._pos.x -1;
        var tile; var gx = -999;var iX = 0; var iY = 0;var cmb = 0;var cix; var ciy;
        while(Tpy < Bty) {
           // tile = tabageos.BlitMath.getTileDataAt(lx,Tpy,map,tw,th);
            cmb = tabageos.BlitMath.fasterCheckTileValueAt(lx,Tpy,this._mapRows,this._mapColumns,tw,th, this._checkHelper);
			ciy = this._checkHelper.y; cix = this._checkHelper.x;
			tile = this._map[ciy][cix];
            if(tile && (tile[0] != 0 || tile[1] != 0)) {
                gx = (cix*tw) + tw;//tile.position.x +tw; 
                if(gx > lx) { break; } else { gx = -1; }
            }
            Tpy += (th > this.height ? this.height : th);
            
        } return gx;
    };
    tabageos.MapTraveler = MapTraveler;
    
})();


(function() { 
	'use strict';
    /** 
    *
    *
    *@class MouseController
    * @classdesc
	*   static methods for getting the position of the mouse.
	* 
    *
    */
    function MouseController() {
        throw "This is a static class, construction is not needed.";
    };
    MouseController.ready = false;
    MouseController._mX = 0;
    MouseController._mY = 0;
    MouseController._oX = 1;
    MouseController._oY = 1;
    MouseController._mmp = new tabageos.MoverPoint();
    MouseController._ed = new tabageos.EventDispatcher();
    MouseController._muE = new tabageos.MouseEvent(tabageos.MouseEvent.MOUSE_UP);
    MouseController._mdE = new tabageos.MouseEvent(tabageos.MouseEvent.MOUSE_DOWN);
    MouseController._mmE = new tabageos.MouseEvent(tabageos.MouseEvent.MOUSE_MOVE);
    /** 
    * 
    * Returns the x position of the mouse.
    *  No setup needed, just call tabageos.MouseController.mouseX() to get the x position of the mouse.
    * @method mouseX
    * @memberof MouseController
    * 
	*    
	*/
    MouseController.mouseX = function() {
        if (tabageos.MouseController.ready == false || document.onmousemove != tabageos.MouseController.updateMousePosition) {
            document.onmousemove = tabageos.MouseController.updateMousePosition;
            tabageos.MouseController.ready = true;
            tabageos.MouseController._mmp = new tabageos.MoverPoint();
        }
        return tabageos.MouseController._mX;
    };
    /** 
    * 
    * Returns the y position of the mouse.
    *  No setup needed, just call tabageos.MouseController.mouseY() to get the y position of the mouse.
    * @method mouseY
    * @memberof MouseController
    * 
	*    
	*/
    MouseController.mouseY = function() {
        if (tabageos.MouseController.ready == false || document.onmousemove != tabageos.MouseController.updateMousePosition) {
            document.onmousemove = tabageos.MouseController.updateMousePosition;
            tabageos.MouseController.ready = true;
            tabageos.MouseController._mmp = new tabageos.MoverPoint();
        }
        return tabageos.MouseController._mY;
    };
    /** 
    * 
    * Returns the position of the mouse as a MoverPoint.
    * @method mouseMoverPoint
    * @memberof MouseController
    * 
	*    
	*/
    MouseController.mouseMoverPoint = function() {
        if (tabageos.MouseController.ready == false || document.onmousemove != tabageos.MouseController.updateMousePosition) {
            document.onmousemove = tabageos.MouseController.updateMousePosition;
            tabageos.MouseController.ready = true;
            tabageos.MouseController._mmp = new tabageos.MoverPoint();
        }
        return tabageos.MouseController._mmp;
    };
    MouseController.updateMousePosition = function(e) {
        e = tabageos.MouseController._defineMouseEvent(e);
        tabageos.MouseController._origPX = e.pageX;
        tabageos.MouseController._origPY = e.pageY;
        tabageos.MouseController._mX = e.pageX * MouseController._oX;
        tabageos.MouseController._mY = e.pageY * MouseController._oY;
        tabageos.MouseController._mmp.y = e.pageY * MouseController._oY;
        tabageos.MouseController._mmp.x = e.pageX * MouseController._oX;
        tabageos.MouseController._mmE.x = e.pageX * MouseController._oX;
        tabageos.MouseController._mmE.y = e.pageY * MouseController._oY;
        tabageos.MouseController.dispatchEvent(tabageos.MouseController._mmE);
    };
    MouseController.mouseUpHandler = function(e) {
        e = tabageos.MouseController._defineMouseEvent(e);
        tabageos.MouseController._muE.x = e.pageX * MouseController._oX;
        tabageos.MouseController._muE.y = e.pageY * MouseController._oY;
        tabageos.MouseController.dispatchEvent(tabageos.MouseController._muE);
    };
    MouseController.mouseDownHandler = function(e) {
        e = tabageos.MouseController._defineMouseEvent(e);
        tabageos.MouseController._mdE.x = e.pageX * MouseController._oX;
        tabageos.MouseController._mdE.y = e.pageY * MouseController._oY;
        tabageos.MouseController.dispatchEvent(tabageos.MouseController._mdE);
    };
    MouseController.addEventListener = function(type, listenerString, listenerObject) {
        tabageos.MouseController._ed.addEventListener(type, listenerString, listenerObject);
        if (type == "mouseUp" || type == "MouseUp" || type == "up" || type == "onmouseup" || type == "UP" || type == "Up") {
            document.onmouseup = tabageos.MouseController.mouseUpHandler;
        }
        if (type == "mouseDown" || type == "MouseDown" || type == "down" || type == "onmousedown" || type == "DOWN" || type == "Down") {
            document.onmousedown = tabageos.MouseController.mouseDownHandler;
        }
        if (type == "mouseMove" || type == "MouseMove" || type == "move" || type == "onmousemove" || type == "MOVE" || type == "Move") {
            document.onmousemove = tabageos.MouseController.updateMousePosition;
        }
    };
    MouseController.removeEventListener = function(type, listenerString, listenerObject) {
        return tabageos.MouseController._ed.removeEventListener(type, listenerString, listenerObject);
    };
    MouseController.dispatchEvent = function(event) {
        tabageos.MouseController._ed.dispatchEvent(event);
    };
    /** 
    * 
    * Defines the offset for the mouse based on the original width/height verses the scale width/height
    * @method mouseMoverPoint
    * @memberof MouseController
    * 
    * @param origWidth {Number} The original width of the mouse area (typically the container)
    * @param origHeight {Number} The original height of the mouse area
	* @param scaledWidth {Number} The current width of the mouse area
    * @param scaledHeight {Number} The current height of the mouse area
    *
    *
    *
	*/
    MouseController.defineMousePositionOffset = function(origWidth, origHeight, scaledWidth, scaledHeight) {
        MouseController._oX = origWidth / scaledWidth;
        MouseController._oY = origHeight / scaledHeight;
    };
    MouseController._defineMouseEvent = function(e) {
        if (typeof e == 'undefined')
            e = window.event;
        return e;
    };
    tabageos.MouseController = MouseController;
})();


(function() { 
	'use strict';
    /** 
    *
    * @class MouseEvent
	*   @classdesc
	*    Used by the MouseController Class.
	*    
	* 
	* @param type {String}
	* @param potato  {Object}
	*  
	*/
    function MouseEvent(type, potato) {
		tabageos.Event.call(this,type,potato);
        this.type = type || "mouseEvent";
        this.potato = potato;
		this.target = null;
		this.x = 0; this.y = 0;
    };
	/** 
	*   
	*    
	*    
	* @memberof MouseEvent 
	*  
	*/
    MouseEvent.prototype.constructor = MouseEvent;
	MouseEvent.prototype = Object.create(tabageos.Event.prototype);
    /** 
	*   
	*    
	*    @type Number
	* @memberof MouseEvent 
	*  
	*/
    MouseEvent.prototype.x = 0;
    /** 
	*   
	*    
	*    @type Number
	* @memberof MouseEvent 
	*  
	*/
    MouseEvent.prototype.y = 0;
    /** 
	*   mouseUp
	*    
	*    @type String
	* @memberof MouseEvent 
	*  
	*/
    MouseEvent.MOUSE_UP = "mouseUp";
    /** 
	*   mouseDown
	*    
	*    @type String
	* @memberof MouseEvent 
	*  
	*/
    MouseEvent.MOUSE_DOWN = "mouseDown";
    /** 
	*   mouseEvent
	*    @type String
	*    
	* @memberof MouseEvent 
	*  
	*/
    MouseEvent.MOUSE_EVENT = "mouseEvent";
    /** 
	*   
	*    mouseMove
	*    @type String
	* @memberof MouseEvent 
	*  
	*/
    MouseEvent.MOUSE_MOVE = "mouseMove";
    tabageos.MouseEvent = MouseEvent;
})();

(function() { 
	'use strict';
    /** 
    *
    * @class MoverPoint
	*  @classdesc
	*    A basic Class representing a point/vector that will be used for movement.
	*    
	*
	* @param x {Number} The x position of the MoverPoint
	* @param y {Number}  The y position of the MoverPoint
	*  
	*/
    function MoverPoint(x, y) {
        this.x = x || 0;
        this.y = y || 0;
		this._length = 0;
		this._angle = 0;
    };
	/** 
	*   
	*    
	*    
	* @memberof MoverPoint 
	*  
	*/
    MoverPoint.prototype.constructor = MoverPoint;
    /** 
	*   
	*    The x position of the MoverPoint
	*    
	* @memberof MoverPoint 
	*  
	*/
    MoverPoint.prototype.x = null;
    /** 
	*   
	*    The y position of the MoverPoint.
	*    
	* @memberof MoverPoint 
	*  
	*/
    MoverPoint.prototype.y = null;
    /** 
	*   
	*    The square root of the squared length of the point.
	*    Math.sqrt(x*x + y*y);
	*    Use .getLength();
	*    
	* @memberof MoverPoint 
	*  
	*/
    MoverPoint.prototype._length = null;
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint 
	*  
	*/
    MoverPoint.prototype._angle = null;
    
    MoverPoint._poolIndex = 0;
    MoverPoint.pool = [];
    MoverPoint.newMoverPoint = function(x,y) {
        if(tabageos.MoverPoint.pool.length <= 0) { 
            while(tabageos.MoverPoint.pool.length < 250) {
                tabageos.MoverPoint.pool.push(new tabageos.MoverPoint());
            } tabageos.MoverPoint._poolIndex = 249;
        } 
       // var p = tabageos.MoverPoint.pool[tabageos.MoverPoint._poolIndex];
       // p.x = x; p.y = y; p._length = 0; p._angle = 0;
        tabageos.MoverPoint._poolIndex--;
        if(tabageos.MoverPoint._poolIndex <= -1) {window.console.log("mppool");
            tabageos.MoverPoint._poolIndex = 249;
        } return tabageos.MoverPoint._setInstance(tabageos.MoverPoint.pool[tabageos.MoverPoint._poolIndex],x,y,0,0);
    };
    MoverPoint._setInstance = function(instance,x,y,l,a) {
        instance.x = x;instance.y = y;instance._length = l;instance._angle = a;return instance;
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method getSquaredLength
    * @returns {Number} 
	*/
    MoverPoint.prototype.getSquaredLength = function() {
        return this.x * this.x + this.y * this.y;
    };
    /** 
	*   
	*    A MoverPoint perpendicular to this one.
	*    
	* @memberof MoverPoint.prototype 
	* @method perp
    * @returns {MoverPoint} 
	*/
    MoverPoint.prototype.perp = function() {
        return new tabageos.MoverPoint(-this.y,this.x);
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method getX
    * @returns {Number} 
	*/
    MoverPoint.prototype.getX = function() {
        return this.x;
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method setX
	* @param toThis 
    * 
	*/
    MoverPoint.prototype.setX = function(toThis) {
        this.x = toThis;
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method getY
    * @returns {Number} 
	*/
    MoverPoint.prototype.getY = function() {
        return this.y;
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method setY
	* @param toThis 
    * 
	*/
    MoverPoint.prototype.setY = function(toThis) {
        this.y = toThis;
    };
    /** 
	*   
	*    Sets ._angle to the atangent of y and x if it is not set, then returns _angle.
	*    
	* @memberof MoverPoint.prototype 
	* @method getAngle
    * @returns {Number} 
	*/
    MoverPoint.prototype.getAngle = function() {
        if (!this._angle) {
            this._angle = Math.atan2(this.y, this.x);
        }
        return this._angle;
    };
    /** 
	*   
	*    Sets _angle to the value given.
	*    
	* @memberof MoverPoint.prototype 
	* @method setAngle
	* @param toThis {Number}
    * 
	*/
    MoverPoint.prototype.setAngle = function(toThis) {
        var l = this.getLength();
        this.x = Math.cos(toThis) * l;
        this.y = Math.sin(toThis) * l;
        this._angle = toThis;
    };
    /** 
	*   
	*    Returns the length of the MoverPoint.
	*    
	* @memberof MoverPoint.prototype 
	* @method getLength
    * @returns {Number} 
	*/
    MoverPoint.prototype.getLength = function() {
        if (!this._length) {
            this._length = Math.sqrt(this.getSquaredLength());
        }
        return this._length;
    };
    /** 
	*   
	*    Sets the length of the MoverPoint to the value given.
	*    
	* @memberof MoverPoint.prototype 
	* @method setLength
	* @param toThis {Number}
    * 
	*/
    MoverPoint.prototype.setLength = function(toThis) {
        var a = this.getAngle();
        this.x = Math.cos(a) * toThis;
        this.y = Math.sin(a) * toThis;
        this._length = toThis;
    };
    /** 
	*   
	*    Divides x and y by length. Normalizes the point to a unit vector.
	*    
	* @memberof MoverPoint.prototype 
	* @method normalize
    * @returns {MoverPoint} 
	*/
    MoverPoint.prototype.normalize = function() {
        if (this.getLength() == 0) {
            this.x = 1;
            return this;
        }
        var l = this.getLength();
        this.x /= l;
        this.y /= l;
        return this;
    };
    /** 
	*   
	*    Returns this MoverPoint with its values reversed.
	*    
	* @memberof MoverPoint.prototype 
	* @method reverse
    * @returns {MoverPoint} 
	*/
    MoverPoint.prototype.reverse = function() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method subtractBy
	* @param xAmount {Number}
	* @param yAmount {Number}
	* @param makeNew {Boolean} If true a new MoverPoint is returned, otherwise this is returned.
    * @returns {MoverPoint} 
	*/
    MoverPoint.prototype.subtractBy = function(xAmount, yAmount, makeNew) {
        if (makeNew != 0) {
            return tabageos.MoverPoint.newMoverPoint(this.x - xAmount,this.y - yAmount);
        } else {
            this.x = this.x - xAmount;
            this.y = this.y - yAmount;
            return this;
        }
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method truncate
	* @param max {Number}
    * @returns {MoverPoint} 
	*/
    MoverPoint.prototype.truncate = function(max) {
        this.setLength(this.getLength() > max ? max : this.getLength());
        return this;
    };
    /** 
	*   
	*    Subtracts the values of mp from this MoverPoint and returns this or a new MoverPoint.
	*    
	* @memberof MoverPoint.prototype 
	* @method subtract
	* @param mp {MoverPoint}
	* @param makeNew {Boolean}
    * @returns {MoverPoint} 
	*/
    MoverPoint.prototype.subtract = function(mp, makeNew) {
        if (makeNew != 0) {
            return tabageos.MoverPoint.newMoverPoint(this.x - mp.x,this.y - mp.y);
        } else {
            this.x = this.x - mp.x;
            this.y = this.y - mp.y;
            return this;
        }
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method add
	* @param mp {MoverPoint}
	* @param makeNew {Boolean}
    * @returns {MoverPoint} 
	*/
    MoverPoint.prototype.add = function(mp, makeNew) {
        if (makeNew != 0) {
            return tabageos.MoverPoint.newMoverPoint(this.x + mp.x,this.y + mp.y);
        } else {
            this.x = (this.x + mp.x);
            this.y = (this.y + mp.y);
            return this;
        }
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method sign
	* @param mp {MoverPoint}
    * @returns {Number} 
	*/
    MoverPoint.prototype.sign = function(mp) {
        return this.perp().dotProduct(mp) < 0 ? -1 : 1;
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method multiply
	* @param value 
	* @param makeNew 
    * @returns {MoverPoint} 
	*/
    MoverPoint.prototype.multiply = function(value, makeNew) {
        if (makeNew != 0) {
            return tabageos.MoverPoint.newMoverPoint(this.x * value,this.y * value);
        } else {
            this.x = this.x * value;
            this.y = this.y * value;
            return this;
        }
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method dotProduct
	* @param mp {moverPoint}
    * @returns {Number} 
	*/
    MoverPoint.prototype.dotProduct = function(mp) {
        return this.x * mp.x + this.y * mp.y;
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method squaredDistance
	* @param mp {MoverPoint}
    * @returns {Number} 
	*/
    MoverPoint.prototype.squaredDistance = function(mp) {
        var dx = mp.x - this.x;
        var dy = mp.y - this.y;
        return dx * dx + dy * dy;
    };
    /** 
	*   
	*    Returns true if the given MoverPoint has the same values as this.
	*    
	* @memberof MoverPoint.prototype 
	* @method equals
	* @param mp {MoverPoint}
    * @returns {Boolean} 
	*/
    MoverPoint.prototype.equals = function(mp) {
        return this.x == mp.x && this.y == mp.y;
    };
    /** 
	*   
	*    Returns the distance between the given MoverPoint and this.
	*    
	* @memberof MoverPoint.prototype 
	* @method dist
	* @param mp {MoverPoint}
    * @returns {Number} 
	*/
    MoverPoint.prototype.dist = function(mp) {
        return Math.sqrt(this.squaredDistance(mp));
    };
    /** 
	*   
	*    Returns a new MoverPoint that has the same values as this.
	*    
	* @memberof MoverPoint.prototype 
	* @method clone
    * @returns {MoverPoint} 
	*/
    MoverPoint.prototype.clone = function() {
        return new tabageos.MoverPoint(this.x,this.y);
    };
    /** 
	*   Uses a MoverPoint from a pool of premade MoverPoints.
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method lesserClone
    * @returns {MoverPoint} 
	*/
    MoverPoint.prototype.lesserClone = function() {
        return tabageos.MoverPoint.newMoverPoint(this.x+1-1,this.y+1-1);
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method addBy
	* @param xAmount {Number}
	* @param yAmount {Number}
	* @param makeNew {Boolean}
    * @returns {MoverPoint} 
	*/
    MoverPoint.prototype.addBy = function(xAmount, yAmount, makeNew) {
        if (makeNew != 0) {
            return tabageos.MoverPoint.newMoverPoint(this.x + xAmount,this.y + yAmount);
        } else {
            this.x = this.x + xAmount;
            this.y = this.y + yAmount;
            return this;
        }
    };
    /** 
	*   
	*    Resets the values of the MoverPoint.
	*    
	* @memberof MoverPoint.prototype 
	* @method reset
    *  
	*/
    MoverPoint.prototype.reset = function() {
        this.x = 0;
        this.y = 0;
        this._length = Math.sqrt(this.getSquaredLength());
        this._angle = Math.atan2(this.y, this.x);
    };
    /** 
	*   
	*    
	*    
	* @memberof MoverPoint.prototype 
	* @method divide
	* @param value {Number} The amount to divide x and y by.
	* @param makeNew {Boolean}
    * @returns {MoverPoint} 
	*/
    MoverPoint.prototype.divide = function(value, makeNew) {
        if (makeNew != 0) {
            return tabageos.MoverPoint.newMoverPoint(this.x / value,this.y / value);
        } else {
            this.x = this.x / value;
            this.y = this.y / value;
            return this;
        }
    };
	/** 
	*   
	*    Returns the angel between the two given MoverPoints
	*    
	* @memberof MoverPoint
    * @static
	* @method angleBetweenMoverPoints
	* @param mp1 {MoverPoint}
	* @param mp2 {MoverPoint}
    * @returns {Number} 
	*/
    MoverPoint.angleBetweenMoverPoints = function(mp1, mp2) {
        if (mp1.getLength() != 1)
            mp1 = mp1.clone().normalize();
        if (mp2.getLength() != 1)
            mp2 = mp2.clone().normalize();
        return Math.acos(mp1.dotProduct(mp2));
    };
	/** 
	*   
	*    Returns the squared distance between the two MoverPoints.
	*    
	* @memberof MoverPoint
	* @method squaredDistanceBetween
	* @param mp1 {MoverPoint}
	* @param mp2 {MoverPoint}
    * @returns {Number} 
	*/
    MoverPoint.squaredDistanceBetween = function(mp1, mp2) {
        var dx = mp1.x - mp2.x;
        var dy = mp1.y - mp2.y;
        return dx * dx + dy * dy;
    };
	/** 
	*   
	*    Returns the distance between the two points.
	*    
	* @memberof MoverPoint 
	* @method distBetween
	* @param mp1 {MoverPoint}
	* @param mp2 {MoverPoint}
    * @returns {Number} 
	*/
    MoverPoint.distBetween = function(mp1, mp2) {
        return Math.sqrt(tabageos.MoverPoint.squaredDistanceBetween(mp1, mp2));
    };
    tabageos.MoverPoint = MoverPoint;
})();

//this.tabageos = this.tabageos || {};
(function() { 
	'use strict';
    /** 
    *
    *
    * @class MoverSkeleton
	*  @classdesc 
	*    A Class ready to utilize MoverPoints as velocity and thereby move.
	*    
	* 
	* @param x {Number} The x position of the MoverSkeleton
	* @param y {Number} The y position of the MoverSkeleton
	* @param width {Number} The width of the MoverSkeleton
	* @param height {Number} The height of the MoverSkeleton
	*  
	*/
    function MoverSkeleton(x, y, width, height) {
        this.width = width || 0;
        this.height = height || 0;
        this._middlePoint = new tabageos.MoverPoint();
        this._pos = new tabageos.MoverPoint(x,y);
        this._veloc = new tabageos.MoverPoint(0,0);
        this._lastVeloc = new tabageos.MoverPoint(0,0);
        this._lastPos = new tabageos.MoverPoint(x,y);
        this.x = x || 0;
        this.y = y || 0;
		this.maxSpeed = 20;
		this.mass = 2;
		this.dX = null;
		this.dY = null;
        this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
    };
	/** 
	*   
	*    
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype.constructor = MoverSkeleton;
    /** 
	*   
	*    To be the max speed of the MoverSkeleton,
	*    this "Skeleton" class does not really do anything with this variable.
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype.maxSpeed = 20;
    /** 
	*    To be the mass of the MoverSkeleton,
	*    this "Skeleton" class does not really do anything with this variable.
	*    
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype.mass = 2;
    /** 
	*   
	*    The velocity MoverPoint for the MoverSkeleton
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype._veloc = null;
    /** 
	*   The position MoverPoint for the MoverSkeleton
	*    
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype._pos = null;
    /** 
	*   
	*    The last position MoverPoint that the MoverSkeleton had.
	*    The update method sets this value.
	*
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype._lastPos = null;
    /** 
	*   The last velocity MoverPoint that the MoverSkeleton had.
	*    The update method sets this value.
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype._lastVeloc = null;
    /** 
	*   
	*    The Rectangle bounds of the MoverSkeleton,
	*    it is created during construction of the MoverSkeleton,
	*    and is updated and referenced via the getRectangle method.
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype._rect = null;
    /** 
	*   
	*   The x direction of the MoverSkeleton, 1,-1, or 0. This value is updated during setX calls. 
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype.dX = null;
    /** 
	*   
	*    The x location of the MoverSkeleton.
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype.x = null;
    /** 
	*   
	*    The y direction of the MoverSkeleton, this value is updated during setY calls.
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype.dY = null;
    /** 
	*   
	*    The y location of the MoverSkeleton.
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype.y = null;
    /** 
	*   
	*    The width of the MoverSkeleton
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype.width = null;
    /** 
	*   
	*    The height of the MoverSkeleton
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype.height = null;
    /** 
	*   
	*    The middle MoverPoint of the MoverSkeleton,
	*    updated and referenced via the getMiddle method.
	*    
	* @memberof MoverSkeleton 
	*  
	*/
    MoverSkeleton.prototype._middlePoint = null;
    /** 
	*   Returns the height of the MoverSkeleton
	*    
	*    
	* @memberof MoverSkeleton.prototype 
	* @method getHeight
    * @returns {Number} 
	*/
    MoverSkeleton.prototype.getHeight = function() {
        return this.height;
    };
    /** 
	*   Returns the vertical direction of the MoverSkeleton, 1,-1, or 0, if setY are being used.
	*    
	*    
	* @memberof MoverSkeleton.prototype 
	* @method getVerticalDirection
    * @returns {Number} 
	*/
    MoverSkeleton.prototype.getVerticalDirection = function() {
        return this.dY;
    };
    /** 
	*   
	*    Returns the horizontal direction of the MoverSkeleton, 1, -1, 0, if setX is being used.
	*    
	* @memberof MoverSkeleton.prototype 
	* @method getHorizontalDirection
    * @returns {Number} 
	*/
    MoverSkeleton.prototype.getHorizontalDirection = function() {
        return this.dX;
    };
    /** 
	*   Returns the width of the MoverSkeleton
	*    
	*    
	* @memberof MoverSkeleton.prototype 
	* @method getWidth
    * @returns {Number} 
	*/
    MoverSkeleton.prototype.getWidth = function() {
        return this.width;
    };
    /** 
	*   
	*    Returns the position MoverPoint of the MoverSkeleton
	*    
	* @memberof MoverSkeleton.prototype 
	* @method getPosition
    * @returns {MoverPoint} 
	*/
    MoverSkeleton.prototype.getPosition = function() {
        return this._pos;
    };
    /** 
	*   
	*    Sets the position MoverPoint to the one given.
	* 	 Also updates x and y to the x and y of the MoverPoint given.
	*    
	* @memberof MoverSkeleton.prototype 
	* @method setPosition
	* @param toThis {MoverPoint} The MoverPoint to set the position to.
    * 
	*/
    MoverSkeleton.prototype.setPosition = function(toThis) {
        this._pos = toThis;
        this.x = this._pos.x+1-1;
        this.y = this._pos.y+1-1;
    };
    /** 
	*   Returns the velocity MoverPoint of this MoverSkeleton
	*    
	*    
	* @memberof MoverSkeleton.prototype 
	* @method getVelocity
    * @returns {MoverPoint} 
	*/
    MoverSkeleton.prototype.getVelocity = function() {
        return this._veloc;
    };
    /** 
	*   
	*    Sets the velocity MoverPoint of this MoverSkeleton to the one given.
	*    
	* @memberof MoverSkeleton.prototype 
	* @method setVelocity
	* @param toThis {MoverPoint} The MoverPoint to set velocity to
    * 
	*/
    MoverSkeleton.prototype.setVelocity = function(toThis) {
        this._veloc = toThis;
    };
    /** 
	*   
	*    Returns the x position of the MoverSkeleton
	*    
	* @memberof MoverSkeleton.prototype 
	* @method getX
    * @returns {Number} 
	*/
    MoverSkeleton.prototype.getX = function() {
        return this.x;
    };
    /** 
	*   
	*    Sets the x position of the MoverSkeleton,
	*    also updating .dX and _pos.x
    *
    *    These methods setX, setY, are used in the update method of MapMovers, and so MapMovers auto update dX and dY, but only MapMovers do such.
    *    In all other cases you would have to use setX and setY yourself if you wanted dX and dY to update, or you could update dX and dY yourself.
    *    In MapTravelers you have _lastPos and _lastVeloc that get updated which can be used to do the same things dX and dY would be used for.
	*    
	* @memberof MoverSkeleton.prototype 
	* @method setX
	* @param toThis {Number} The Number to set x to.
	* @param notDX {Boolean} If true will not set dX. The default behavior is to set .dX to 1,-1, or 0 based on what is given.
    * 
	*/
    MoverSkeleton.prototype.setX = function(toThis, notDX) {
		if(!notDX) {
			if (toThis > this.x) {
				this.dX = 1;
			}
			if (toThis < this.x) {
				this.dX = -1;
			}
			if (toThis == this.x) {
				this.dX = 0;
			}
		}
        this.x = toThis+1-1;
        this._pos.x = toThis+1-1;
    };
    /** 
	*   
	*    Returns the y position of the MoverSkeleton
	*    
	* @memberof MoverSkeleton.prototype 
	* @method getY
    * @returns {Number} 
	*/
    MoverSkeleton.prototype.getY = function() {
        return this.y;
    };
    /** 
	*   
	*    Sets the y value of the MoverSkeleton, and also updates _pos.y and .dY
	*    
	* @memberof MoverSkeleton.prototype 
	* @method setY
	* @param toThis {Number} The number to set y to.
	* @param notDY {Boolean} If true will not set direction y; this.dY. The default behavior is to update this.dY to 1,-1, or 0 when this method is used.
    * 
	*/
    MoverSkeleton.prototype.setY = function(toThis, notDY) {
		if(!notDY) {
			if (toThis > this.y) {
				this.dY = 1;
			}
			if (toThis < this.y) {
				this.dY = -1;
			}
			if (toThis == this.y) {
				this.dY = 0;
			}
		}
        this.y = toThis+1-1;
        this._pos.y = toThis+1-1;
    };
    /** 
	*   Returns the middle MoverPoint (_middlePoint) based on x/y width/height.
	*    
	*    
	* @memberof MoverSkeleton.prototype 
	* @method getMiddle
    * @returns {MoverPoint} 
	*/
    MoverSkeleton.prototype.getMiddle = function() {
        this._middlePoint.reset();
        this._middlePoint.x = this.x + (this.width >> 1);
        this._middlePoint.y = this.y + (this.height >> 1);
        return this._middlePoint;
    };
    /** 
	*   
	*    Returns the Rectangle bounds of the MoverSkeleton.
	*    
	* @memberof MoverSkeleton.prototype 
	* @method getRectangle
	* @param wOffset 
	* @param hOffset 
    * @returns {Rectangle} 
	*/
    MoverSkeleton.prototype.getRectangle = function(wOffset,hOffset) {
        
        this._rect.x = this.x+1-1;
        this._rect.y = this.y+1-1;
        this._rect.width = this.width+1-1 + (wOffset||0);
        this._rect.height = this.height+1-1 + (hOffset||0);
        return this._rect;
        
    };
    /** 
	*   
	*    This method matches _lastPos to _pos, and _lastVeloc to _veloc 
	* 	 If _veloc/_pos are changed after this method is called, _lastVeloc/_lastPos therefore would hold the previous values.
	*    
	* 	 Classes that extend MoverSkeleton override this method adding in more functionality.
	*
	* @memberof MoverSkeleton.prototype 
	* @method update
    * 
	*/
    MoverSkeleton.prototype.update = function() {
        this._lastPos.x = this._pos.x +1-1;
        this._lastPos.y = this._pos.y +1-1;
        this._lastVeloc.x = this._veloc.x+1-1;
        this._lastVeloc.y = this._veloc.y+1-1;
        
    };
    tabageos.MoverSkeleton = MoverSkeleton;
})();


//
(function() { 

	'use strict';
	
	/** 
    *
    * @class MovingPlatform
	*   @classdesc
	*    A MapTraveler designated to be treated as a moving platform.
	*    
	* 
	* @param direcX 
	* @param direcY 
	* @param x 
	* @param y 
	* @param width 
	* @param height 
	* @param map 
	* @param ca 
	* @param dontCloneMap 
	* @param dt 
	* @param tw 
	* @param th 
	* @param mr 
	* @param mc  
	*  
	*/
    function MovingPlatform(direcX,direcY,x,y,width,height, map,ca,dontCloneMap, dt,tw,th, mr, mc) {
		tabageos.TravelerSkeleton.call(this,x,y,width,height);
		tabageos.MapTraveler.call(this,x,y,width,height, map,ca,dontCloneMap, dt,tw,th,mr,mc);
		this.width = width || 0;
        this.height = height || 0;
        this._middlePoint = new tabageos.MoverPoint();
        this._pos = new tabageos.MoverPoint(x,y);
        this._veloc = new tabageos.MoverPoint(0,0);
        this._lastVeloc = new tabageos.MoverPoint(0,0);
        this._lastPos = new tabageos.MoverPoint(x,y);
        this._deltaTime = dt || tabageos.TimeKeeper._sae;
        this._map = dontCloneMap ? map : tabageos.BlitMath.cloneMultiArray(map);
        this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
        this._state = 1;
        this.forceApplier = new tabageos.MoverPoint();
        this.forceHolder = new tabageos.MoverPoint();
        this._canvasAnimation = ca || null;
        this._w = width || 0;
        this._h = height || 0;
        this.wanderOffset = new tabageos.MoverPoint(0,0);
        this.blankMO = new tabageos.MoverPoint();
        this._eventDispatcher = new tabageos.EventDispatcher();
        this.x = x || 0;
        this.y = y || 0;
		this._tw = tw;
		this._th = th;
        this._checkHelper = new tabageos.MoverPoint();
		this._inp = new tabageos.MoverPoint();
		this._direcX = direcX || 0;
		this._direcY = (direcY == -1 ? direcY : (direcY || 0));
		this._horizontal = this._direcX == -1 || this._direcX == 1;
	}
	/** 
	*   
	*    
	*    
	* @memberof MovingPlatform 
	*  
	*/
    MovingPlatform.prototype.constructor = MovingPlatform;
	MovingPlatform.prototype = Object.create(tabageos.TravelerSkeleton.prototype);
	Object.assign(MovingPlatform.prototype, tabageos.MapTraveler.prototype);
	/** 
	*   
	*    
	*    
	* @memberof MovingPlatform 
	*  
	*/
    MovingPlatform.prototype._inp;
	/** 
	*   
	*    
	*    
	* @memberof MovingPlatform 
	*  
	*/
    MovingPlatform.prototype._tw;
	/** 
	*   
	*    
	*    
	* @memberof MovingPlatform 
	*  
	*/
    MovingPlatform.prototype._th;
	/** 
	*   
	*    The direction the platofrm goes in; horizontal 1, or vertical 0.
	*    This value is set during construction based on the values for _direcX and _direcY given during construction.
	*    
	* @memberof MovingPlatform 
	*  
	*/
    MovingPlatform.prototype._horizontal = 1;
	/** 
	*   
	*    The x direction of the platform
	*    
	* @memberof MovingPlatform 
	*  
	*/
    MovingPlatform.prototype._direcX;
	/** 
	*   
	*   The y direction of the platform 
	*    
	* @memberof MovingPlatform 
	*  
	*/
    MovingPlatform.prototype._direcY;
	
	tabageos.MovingPlatform = MovingPlatform;
	
})();


(function() { 

	'use strict';
    
    /** 
	* 
    * @class NinjaSceneryThrower
	*  @classdesc A BasicNinja that also can pick up and throw SceneryObjects
	*    
	* @see BasicNinja
    * @see TravelingSceneryThrower
    * 
	* @param x 
	* @param y 
	* @param width 
	* @param height 
	* @param map 
	* @param ca 
	* @param dontCloneMap 
	* @param dt 
	* @param tWidth 
	* @param tHeight 
	* @param mr 
	* @param mc  
	*  
	*/
    function NinjaSceneryThrower(x,y,width,height, map, ca,dontCloneMap,dt,tWidth,tHeight,mr,mc) {
		tabageos.TravelerSkeleton.call(this,x,y,width,height);
		tabageos.BasicNinja.call(this,x,y,width,height, map, ca,dontCloneMap,dt,tWidth,tHeight,mr,mc);
        
        this.width = width || 0;
        this.height = height || 0;
        this._middlePoint = new tabageos.MoverPoint();
        this._pos = new tabageos.MoverPoint(x,y);
        this._veloc = new tabageos.MoverPoint(0,0);
        this._lastVeloc = new tabageos.MoverPoint(0,0);
        this._lastPos = new tabageos.MoverPoint(x,y);
        this._deltaTime = dt || tabageos.TimeKeeper._sae;
        this._map = dontCloneMap ? map : tabageos.BlitMath.cloneMultiArray(map);
        this._state = 1;
        this.x = x || 0;
        this.y = y || 0;
        this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
        this._canvasAnimation = ca || null;
        this._tH = tHeight || this.height;
        this._tW = tWidth || this.width;
        this._outAltered = new tabageos.MoverPoint();
        this.holdingRect = new tabageos.Rectangle(0,0,width,height);
        this.holdingOffsetX = 1;
        this.holdingOffsetY = 3;
        this._jumps = 1;
        this.easeProximity = 7;
        this._checkHelper = new tabageos.MoverPoint();
        this.forceApplier = new tabageos.MoverPoint();
        this.forceHolder = new tabageos.MoverPoint();
        this._w = width || 0;
        this._h = height || 0;
        this.wanderOffset = new tabageos.MoverPoint(0,0);
        this.blankMO = new tabageos.MoverPoint();
        this._eventDispatcher = new tabageos.EventDispatcher();
		this.holdings = [];
		this._holdingHelperRect = new tabageos.Rectangle(0,0,0,0);
		
        
    };
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype.constructor = NinjaSceneryThrower;
    NinjaSceneryThrower.prototype = Object.create(tabageos.TravelerSkeleton.prototype); 
	Object.assign(NinjaSceneryThrower.prototype, tabageos.BasicNinja.prototype);
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype.throwStrength = 10;
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype.health = 100;
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype.holding;
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype.holdings;
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype.holdingRect;
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype._holdingHelperRect;
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype._canvasAnimation = null;
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype._outAltered;
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype.holdingOffsetX = 1;
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype.holdingOffsetY = 3;
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype.nameOfThrower = "strawHat";

    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method alteredPosition
	* @param xAlterAmount 
	* @param yAlterAmount 
    * @returns {MoverPoint} 
	*/
    NinjaSceneryThrower.prototype.alteredPosition = function(xAlterAmount, yAlterAmount) {
        xAlterAmount = xAlterAmount || 0;
        yAlterAmount = yAlterAmount || 0;
        this._outAltered.x = this.x - xAlterAmount;
        this._outAltered.y = this.y - yAlterAmount;
        return this._outAltered;
    };
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method holdingImageRect
    * @returns {Rectangle} 
	*/
    NinjaSceneryThrower.prototype.holdingImageRect = function() {
        return this.holdingRect;
    };
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method pickUpTileData
	* @param td 
	* @param imageWidthAdjust 
	* @param imageHeightAdjust 
    * @returns {Boolean} 
	*/
    NinjaSceneryThrower.prototype.pickUpTileData = function(td, imageWidthAdjust, imageHeightAdjust) {
        if (!this.holding) {
            this.holding = td;
            this.holdingRect.x = this.holding.value[1] * (this._tw);
            this.holdingRect.y = this.holding.value[0] * (this._th);
            this.holdingRect.width = this._tw;
            this.holdingRect.height = this._th;
            if (imageWidthAdjust) {
                this.holdingRect.width += imageWidthAdjust;
            }
            if (imageHeightAdjust) {
                this.holdingRect.height += imageHeightAdjust;
            }
            return true;
        }
        return false;
    };
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method pickUpAndStoreTileData
	* @param obj 
	* @param imageWidthAdjust 
	* @param imageHeightAdjust 
	* @param dontReadyThrow 
    * @returns {Boolean} 
	*/
    NinjaSceneryThrower.prototype.pickUpAndStoreTileData = function(obj, imageWidthAdjust, imageHeightAdjust, dontReadyThrow) {
		
			this.holdings.push(obj);
			var hi = this.holdings.length - 1;
            this.holdingRect.x = this.holdings[hi].value[1] * (this._tw);
            this.holdingRect.y = this.holdings[hi].value[0] * (this._th);
            this.holdingRect.width = this._tw;
            this.holdingRect.height = this._th;
            if (imageWidthAdjust) {
                this.holdingRect.width += imageWidthAdjust;
            }
            if (imageHeightAdjust) {
                this.holdingRect.height += imageHeightAdjust;
            }
			
			if(!dontReadyThrow) { this._readyNextThrow(); } else { this.holding = null; }
			
            return true;
		
	};
	
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method removeFromStorageByValue
	* @param tValue {Array}
    *  
	*/
    NinjaSceneryThrower.prototype.removeFromStorageByValue = function(tValue) {
		
		var i = 0; var l = this.holdings.length;
		for (i; i < l; i ++) {
			if(this.holdings[i] && this.holdings[i].value) {
				if(this.holdings[i].value[0] == tValue[0] && this.holdings[i].value[1] == tValue[1]) {
					
					this.holdings.splice(i, 1); break;
				}
			} else {
				if(this.holdings[i] && this.holdings[i].tileValue) {
					if(this.holdings[i].tileValue[0] == tValue[0] && this.holdings[i].tileValue[1] == tValue[1]) {
					
						this.holdings.splice(i, 1); break;
					}
				}
			}
		}
	};
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method removeLastFromStorage
    * @returns {Object} 
	*/
    NinjaSceneryThrower.prototype.removeLastFromStorage = function() {
		
		if(this.holdings.length) {
			var sceneobj = this.holdings.pop();
			sceneobj.setX( this.x+1-1 );sceneobj.setY(  this.y+1-1 );
			this.holding = null;
			return sceneobj;
		} else {
			
			return null;
		}
		
		
	};
	
	
	/** 
	*   
	*    @private
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype._tempDivs = [];
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype._displayStorageClearRect;
	
	
	
	
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method displayStorage
	* @param img 
	* @param cameraLayer 
	* @param backgroundFromRect 
	* @param bgx 
	* @param bgy 
	* @param tw 
	* @param th 
	* @param stx 
	* @param sty 
	* @param descriptions 
    *  
	*/
    NinjaSceneryThrower.prototype.displayStorage = function(img,cameraLayer,backgroundFromRect,bgx,bgy,tw,th, stx, sty, descriptions) {
		
		var i = 0; var l = this.holdings.length; var j = 0; 
		if(!this._displayStorageClearRect) {
			this._displayStorageClearRect = new tabageos.Rectangle(backgroundFromRect.x + tw + 4, backgroundFromRect.y + th + 4, tw, th);
		}
		var xlc = stx +1-1; var ylc = sty +1-1;
		cameraLayer.copyPixels(img, backgroundFromRect, new tabageos.MoverPoint( bgx, bgy ), backgroundFromRect.width, backgroundFromRect.height);
		for (i; i < l; i++) { 
			
			var val = this.holdings[i].value ? this.holdings[i].value : this.holdings[i].tileValue;
			
			cameraLayer.copyPixels(img, new tabageos.Rectangle(val[1]*tw, val[0]*th, tw, th), new tabageos.MoverPoint( xlc, ylc ), tw, th);
			if(!this._tempDivs[i]) this._tempDivs[i] = document.createElement("div");
			this._tempDivs[i].sceneryThrower = this;
			this._tempDivs[i].cDisplay = cameraLayer;
			this._tempDivs[i]._img = img;
			this._tempDivs[i]._dscr = this._displayStorageClearRect;
			
			var ttle = "";
			if(descriptions && descriptions.length >= 1) {
				for (j = 0; j < descriptions.length; j++) {
					if(descriptions[j][0] == val[0] && descriptions[j][1] == val[1]) {
						ttle = descriptions[j][2];
					}
				}
			}
			this._tempDivs[i].setAttribute("title", ttle);
			this._tempDivs[i].setAttribute("id", val[0]+"v"+val[1]+"");
			this._tempDivs[i].setAttribute("style", "position:absolute;width:"+tw+"px;height:"+th+"px;top:"+ylc+"px;left:"+xlc+"px;cursor:pointer;z-index:99999999999999999999999999999999999999999999999999999999999999999");
			this._tempDivs[i].removeEventListener(tabageos.seekTouch() ? "touchstart" : "click", this.removeFromDisplayedStorage, false);
			this._tempDivs[i].addEventListener(tabageos.seekTouch() ? "touchstart" : "click", this.removeFromDisplayedStorage, false);
			cameraLayer.canvas.offsetParent.appendChild(this._tempDivs[i]);
			
			xlc += tw*2;
			if(xlc >= tw*14) {
				
				xlc = stx +1-1;
				ylc += th*2;
			}
		}
	};
	
	
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower 
	*  
	*/
    NinjaSceneryThrower.prototype._removedFromStorage = [];
	
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method removeFromDisplayedStorage
	* @param e 
    * 
	*/
    NinjaSceneryThrower.prototype.removeFromDisplayedStorage = function(e) {
		
		
		var ele = e.target;
		var aVal = ele.id.split("v"); 
		function dep(sx) { 
			return Number(sx.replace("px",""));
		};
		
		aVal[0] = Number(aVal[0]); aVal[1] = Number(aVal[1]);
		ele.sceneryThrower.removeFromStorageByValue(aVal);
		ele.sceneryThrower._removedFromStorage.push(aVal);
		ele.cDisplay.copyPixels(ele._img, ele._dscr, new tabageos.MoverPoint(dep(ele.style.left), dep(ele.style.top)), dep(ele.style.width), dep(ele.style.height));
		ele.removeEventListener(tabageos.seekTouch() ? "touchstart" : "click", ele.sceneryThrower.removeFromDisplayedStorage, false);
		ele.offsetParent.removeChild(ele);
		
		
		
	};
	
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method pickUpAndStore
	* @param obj 
	* @param imageWidthAdjust 
	* @param imageHeightAdjust 
	* @param dontReadyThrow 
    * @returns {Boolean} 
	*/
    NinjaSceneryThrower.prototype.pickUpAndStore = function(obj, imageWidthAdjust, imageHeightAdjust, dontReadyThrow) {
		
			this.holdings.push(obj);
			var hi = this.holdings.length - 1;
            this.holdingRect.x = this.holdings[hi].tileValue[1] * (obj.width);
            this.holdingRect.y = this.holdings[hi].tileValue[0] * (obj.height);
            this.holdingRect.width = obj.width;
            this.holdingRect.height = obj.height;
            if (imageWidthAdjust) {
                this.holdingRect.width += imageWidthAdjust;
            }
            if (imageHeightAdjust) {
                this.holdingRect.height += imageHeightAdjust;
            }
			
			if(!dontReadyThrow) { this._readyNextThrow(); } else { this.holding = null; }
			
            return true;
		
	};
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method pickUp
	* @param obj 
	* @param imageWidthAdjust 
	* @param imageHeightAdjust 
    * @returns {Boolean} 
	*/
    NinjaSceneryThrower.prototype.pickUp = function(obj, imageWidthAdjust, imageHeightAdjust) {
        if (!this.holding) {
            this.holding = obj;
            this.holdingRect.x = obj.tileValue[1] * (obj.width);
            this.holdingRect.y = obj.tileValue[0] * (obj.height);
            this.holdingRect.width = obj.width;
            this.holdingRect.height = obj.height;
            if (imageWidthAdjust) {
                this.holdingRect.width += imageWidthAdjust;
            }
            if (imageHeightAdjust) {
                this.holdingRect.height += imageHeightAdjust;
            }
            return true;
        }
        return false;
    };
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method _throwHolding
    * 
	*/
    NinjaSceneryThrower.prototype._throwHolding = function() {
        
		if(this.holdings.indexOf(this.holding) != -1) {
			this.holdings.splice(this.holdings.indexOf(this.holding), 1);
		}
        this.holding = null;
        
    };
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method _readyNextThrow
    * 
	*/
    NinjaSceneryThrower.prototype._readyNextThrow = function() {
		
		if(this.holdings.length) {
			
			
				
				this.holding = this.holdings[this.holdings.length-1];
				if(this.holding.tileValue) {
					this.holdingRect.x = this.holding.tileValue[1] * (this.holding.width);
					this.holdingRect.y = this.holding.tileValue[0] * (this.holding.height);
					this.holdingRect.width = this.holding.width;
					this.holdingRect.height = this.holding.height;
				} else {
					this.holdingRect.x = this.holding.value[1] * (this._tW);
					this.holdingRect.y = this.holding.value[0] * (this._tH);
					this.holdingRect.width = this._tW;
					this.holdingRect.height = this._tH;

					
				}
				
			
		}
		
	};
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method valueFromHolding
	* @param holdin 
    * @returns {Object} 
	*/
    NinjaSceneryThrower.prototype.valueFromHolding = function(holdin) {
		
		return (holdin.value || holdin.tileValue);		
	};
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method rectFromHolding
	* @param holdin 
    * @returns {Rectangle} 
	*/
    NinjaSceneryThrower.prototype.rectFromHolding = function(holdin) {
		
				if(holdin.tileValue) {
					this._holdingHelperRect.x = holdin.tileValue[1] * (holdin.width);
					this._holdingHelperRect.y = holdin.tileValue[0] * (holdin.height);
					this._holdingHelperRect.width = holdin.width;
					this._holdingHelperRect.height = holdin.height;
				} else {
					this._holdingHelperRect.x = holdin.value[1] * (this._tW);
					this._holdingHelperRect.y = holdin.value[0] * (this._tH);
					this._holdingHelperRect.width = this._tW;
					this._holdingHelperRect.height = this._tH;
				}
		return this._holdingHelperRect;
	};
    /** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method throwSceneryObject
	* @param w 
	* @param h 
	* @param jumps 
    * @returns {SceneryObject} 
	*/
    NinjaSceneryThrower.prototype.throwSceneryObject = function(w,h,jumps) {
        var scenery;
		
		if(this.holding == null && this.holdings.length) {
			this._readyNextThrow();
		}
		
        if (this.holding) {
            
            scenery = new tabageos.SceneryObject(this.x+1-1,this.y+1-1,w||this._tw,h||this._th,this._map,null,1, this._deltaTime, this._tw, this._th,this._mapRows,this._mapColumns);
            scenery._jumps = (jumps == 0 ? 0 : 1);
            scenery.playerHoldingThis = this;
            scenery.tileValue = this.holding.value || this.holding.tileValue;
            scenery.tileRect = new tabageos.Rectangle(this.holdingRect.x,this.holdingRect.y,this.holdingRect.width,this.holdingRect.height);

            this._throwHolding();
			
            return scenery;
        }
        return null;
    };
	/** 
	*   
	*    
	*    
	* @memberof NinjaSceneryThrower.prototype 
	* @method throwSceneryObjectTraveler
	* @param w 
	* @param h 
	* @param jumps 
    * @returns {SceneryObjectTraveler} 
	*/
    NinjaSceneryThrower.prototype.throwSceneryObjectTraveler = function(w,h,jumps) {
        var scenery;
		
		if(this.holding == null && this.holdings.length) {
			this._readyNextThrow();
		}
		
        if (this.holding) {
            
            scenery = new tabageos.SceneryObjectTraveler(this.x+1-1,this.y+1-1,w||this._tw,h||this._th,this._map,null,1, this._deltaTime, this._tw, this._th,this._mapRows,this._mapColumns);
            scenery._jumps = (jumps == 0 ? 0 : 1);
            scenery.playerHoldingThis = this;
            scenery.tileValue = this.holding.value || this.holding.tileValue;
            scenery.tileRect = new tabageos.Rectangle(this.holdingRect.x,this.holdingRect.y,this.holdingRect.width,this.holdingRect.height);

            this._throwHolding();
			
            return scenery;
        }
        return null;
    };
    tabageos.NinjaSceneryThrower = NinjaSceneryThrower;
})();

(function() { 
	'use strict';
    /** 
    *@class PatternActionEvent
    * @classdesc
	*   An Event that is dispatched via the BlitMath.dispatchFunctionAssignments method.
	*    It will hold information about a tile computed during the BlitMath.dispatchFunctionAssignments method,
	*    and is dispatched using the EventDispatcher passed to the BlitMath.dispatchFunctionAssignments method.
	*	 see BlitMath.dispatchFunctionAssignments.    
	*
	* 
	* @param tileValue {Object} The value of the tile in the pattern
	* @param tileXIndex {Number} The x index of the tile in the pattern
	* @param tileYIndex {Number} The y index of the tile in the pattern
	* @param patternIndex {Number} The index of the pattern; 0.
	* @param autoCompute {Boolean} Auto calculate the x and y specific location of the tile in the pattern. Uses BlitMath._specs.blitWidth and BlitMath._specs.blitHeight  *  the tileXIndex and tileYIndex given. 
	* @param type {String} The type of PatternActionEvent either "patternActionEvent" or "functionAssignment"
	* @param x {Number} The specific x location of the tile referenced by this Event.
	* @param y  {Number} The specific y location, in the pattern given to BlitMath.dispatchFunctionAssignments, of the tile referenced by this Event.
	*  
	*/
    function PatternActionEvent(tileValue, tileXIndex, tileYIndex, patternIndex, autoCompute, type, x, y) {
		tabageos.Event.call(this,type);
        this.type = type || "patternActionEvent";
        this.potato = this.potato || {};
		this.target = null;
        this.typeToBe = type;
        this.tileValue = tileValue;
        this.tileXIndex = tileXIndex;
        this.tileYIndex = tileYIndex;
        this.autoCompute = autoCompute;
        this.patternIndex = patternIndex;
        this.x = x || 0;
        this.y = y || 0;
        if (autoCompute) {
            this.x = this.tileXIndex * tabageos.BlitMath._specs.blitWidth;
            this.y = this.tileYIndex * tabageos.BlitMath._specs.blitHeight;
        }
    };
	/** 
	*   
	*    
	*    
	* @memberof PatternActionEvent 
	*  
	*/
    PatternActionEvent.prototype.constructor = PatternActionEvent;
	PatternActionEvent.prototype = Object.create(tabageos.Event.prototype);
    PatternActionEvent.PATTERN_ACTION_EVENT = "patternActionEvent";
    PatternActionEvent.FUNCTION_ASSIGNMENT = "functionAssignment";
    /** 
	*   
	*    
	*    
	* @memberof PatternActionEvent 
	*  
	*/
    PatternActionEvent.prototype.tileValue = null;
    /** 
	*   
	*    
	*    
	* @memberof PatternActionEvent 
	*  
	*/
    PatternActionEvent.prototype.tileXIndex = 0;
    /** 
	*   
	*    
	*    
	* @memberof PatternActionEvent 
	*  
	*/
    PatternActionEvent.prototype.tileYIndex = 0;
    /** 
	*   
	*    
	*    
	* @memberof PatternActionEvent 
	*  
	*/
    PatternActionEvent.prototype.patternIndex = 0;
    /** 
	*   
	*    
	*    
	* @memberof PatternActionEvent 
	*  
	*/
    PatternActionEvent.prototype.typeToBe = null;
    /** 
	*   
	*    
	*    
	* @memberof PatternActionEvent 
	*  
	*/
    PatternActionEvent.prototype.autoCompute = false;
    /** 
	*   
	*    
	*    
	* @memberof PatternActionEvent 
	*  
	*/
    PatternActionEvent.prototype.x = 0;
    /** 
	*   
	*    
	*    
	* @memberof PatternActionEvent 
	*  
	*/
    PatternActionEvent.prototype.y = 0;
    /** 
	*   
	*    Clones the PatternActionEvent.
	*    
	* @memberof PatternActionEvent.prototype 
	* @method clone
    * @returns {PatternActionEvent} 
	*/
    PatternActionEvent.prototype.clone = function() {
        var pae = new PatternActionEvent(this.tileValue,this.tileXIndex,this.tileYIndex,this.patternIndex,this.autoCompute,this.typeToBe,this.x,this.y);
        return pae;
    };
    tabageos.PatternActionEvent = PatternActionEvent;
})();


(function() { 
	'use strict';
	
	
	
	
    /** 
	*   
	*    Constructs a new Rectangle.
	*    
	* @class Rectangle
	* @classdesc  A basic Rectangle class representing x y width and height.
	* @param x {Number}
	* @param y {Number}
	* @param width {Number}
	* @param height  {Number}
	*  
	*/
    function Rectangle(x, y, width, height) {
        this.x = x || 0;
        this.y = y || 0;
        this.height = height || 0;
        this.width = width || 0;
    };
	
	/** 
	*   
	*    
	*    
	* @memberof Rectangle 
	*  
	*/
	Rectangle.prototype.constructor = Rectangle;
	Rectangle.prototype = new Object();
	
	/** 
	*   
	*    
	*    
	* @memberof Rectangle 
	*  
	*/
    Rectangle.prototype.x = 0;
    /** 
	*   
	*    
	*    
	* @memberof Rectangle 
	*  
	*/
    Rectangle.prototype.y = 0;
    /** 
	*   
	*    
	*    
	* @memberof Rectangle 
	*  
	*/
    Rectangle.prototype.width = 0;
    /** 
	*   
	*    
	*    
	* @memberof Rectangle 
	*  
	*/
    Rectangle.prototype.height = 0;
	
    
    tabageos.Rectangle = Rectangle;
})();

(function() { 

	'use strict';


    /** 
    *@class RotatingShooter
    * @classdesc
	*   A RotatingTraveler that is also set up to shoot BlittedTraveler bullets.
	*    
	*    
	* 
	* @param wd {WayDeterminer}
	* @param source {Image}
	* @param canvas {CanvasObject}
	* @param fromRect {Rectangle}
	* @param x {Number}
	* @param y {Number}
	* @param width {Number}
	* @param height {Number}
	* @param rotationImage {CanvasObject}
	* @param rotationFromRect {Rectangle}
	* @param bulletCanvas {CanvasObject}
	* @param bulletFromRect  {Rectangle}
    * @param bulletMap {Array} If set then the bullets shot will be MapTravelers instead of BlittedTravelers.
	*  
	*/
    function RotatingShooter(wd, source, canvas, fromRect, x, y, width, height, rotationImage, rotationFromRect, bulletCanvas, bulletFromRect, bulletMap) {
		tabageos.TravelerSkeleton.call(this,x,y,width,height);
		tabageos.Traveler.call(this,x,y,width,height);
		tabageos.BlittedTraveler.call(this,source, canvas, fromRect, x, y, width, height);
		tabageos.WDTraveler.call(this,wd, source, canvas, fromRect, x, y, width, height);
		tabageos.RotatingTraveler.call(this, wd, source, canvas, fromRect, x, y, width, height, rotationImage, rotationFromRect);
        this.init(source, canvas, fromRect, x, y, width, height);
        this._cWD = wd;
        this._wayDeterminer = wd;
        this.rImageHolder = rotationImage;
        this.rFromRect = rotationFromRect;
        this.roExA = 0;
        this.rToPoint = new tabageos.MoverPoint(-((this.rImageHolder.width - this.roExA) / 2),-((this.rImageHolder.height - this.roExA) / 2));
        this._brFromRct = new tabageos.Rectangle(0,0,this.rFromRect.width,this.rFromRect.height);
        this.bulletHolder = [];
        this._bulletCanvas = bulletCanvas;
        this.bulletFromRect = bulletFromRect;
        this.bulletSpeed = 14;
    };
	/** 
	*   
	*    
	*    
	* @memberof RotatingShooter 
	*  
	*/
    RotatingShooter.prototype.constructor = RotatingShooter;
	RotatingShooter.prototype = Object.create(tabageos.TravelerSkeleton.prototype);
	Object.assign(RotatingShooter.prototype, tabageos.Traveler.prototype, tabageos.BlittedTraveler.prototype, tabageos.WDTraveler.prototype, tabageos.RotatingTraveler.prototype);
	
    /** 
	*   
	*    
	*    
	* @memberof RotatingShooter 
	*  
	*/
    RotatingShooter.prototype.bulletHolder = [];
    /** 
	*   
	*    
	*    
	* @memberof RotatingShooter 
	*  
	*/
    RotatingShooter.prototype.bulletFromRect;
    /** 
	*   
	*    
	*    
	* @memberof RotatingShooter 
	*  
	*/
    RotatingShooter.prototype._bulletCanvas;
    /** 
	*   
	*    
	*    
	* @memberof RotatingShooter 
	*  
	*/
    RotatingShooter.prototype.bulletSpeed = 14;
    /** 
	*   
	*    Populates bulletHolder with the given amount of bullets ready to be shot.
	*    
	* @memberof RotatingShooter.prototype 
	* @method reload
	* @param amount {Number}
    * 
	*/
    RotatingShooter.prototype.reload = function(amount) {
		var b, bulletCa, brc;
        while (this.bulletHolder.length < amount) {
			brc = new tabageos.Rectangle(this.bulletFromRect.x+1-1,this.bulletFromRect.y+1-1, this.bulletFromRect.width+1-1, this.bulletFromRect.height+1-1);
			if(this.bulletType === 1) {
				b = new tabageos.BlittedTraveler(this._source,this._bulletCanvas,brc,0,0,this.bulletFromRect.width,this.bulletFromRect.height);
				
			} else { 
				bulletCa = new tabageos.CanvasAnimation(this._source,this._bulletCanvas,brc,0,0,this.bulletFromRect.width,this.bulletFromRect.height);
				b = new tabageos.MapTraveler(0,0,this.bulletFromRect.width,this.bulletFromRect.height,this.bulletMap, bulletCa,1);
				
			}
			this.bulletHolder.push(b);
        }
    };
    /** 
	*   
	*    Shoots a bullet, the x and y position and _veloc is adjusted to shoot from the middle of the RotatingShooter.
	*    
	* @memberof RotatingShooter.prototype 
	* @method shoot
    * @returns {BlittedTraveler | MapTraveler} 
	*/
    RotatingShooter.prototype.shoot = function() {
        if (this.bulletHolder.length <= 0) {
            this.reload(100);
        }
        var b = this.bulletHolder.pop();
        b.setX(this.x + this.width / 2);
        b.setY(this.y + this.height / 2);
        b._veloc.x = Math.cos(Math.PI * (this.nr / 180)) * this.bulletSpeed;
        b._veloc.y = Math.sin(Math.PI * (this.nr / 180)) * this.bulletSpeed;
        return b;
    };
	/** 
	*   
	*    Resets the bullets x y and veloc and puts it back into bulletHolder.
	*    
	* @memberof RotatingShooter.prototype 
	* @method reclaimBullet
	* @param b 
    * 
	*/
    RotatingShooter.prototype.reclaimBullet = function(b) {
		if(b) {
			b.setX(0);
			b.setY(0);
			b._veloc.x = 0;
			b._veloc.y = 0;
			this.bulletHolder.unshift(b);
		}
    };
    tabageos.RotatingShooter = RotatingShooter;
})();


//this.tabageos = this.tabageos || {};
(function() { 

	'use strict';

   /** 
	*   
	*    
	*    
	* @class RotatingTraveler
    * @classdesc A RotatingTraveler is a WDTraveler that has a animation that can rotate.
	* @constructor
    *
    * @param wd {WayDeterminer} A WayDeterminer instance for collision stuffs 
	* @param source {Image} HTML Image or Canvas Element, the sprite sheet to draw from
	* @param canvas {CanvasObject} CanvasObject to draw to
	* @param fromRect {Rectangle} fromRect used as WDTraveler/BlittedTraveler
	* @param x {Number} x position
	* @param y {Number} y position
	* @param width {Number} width
	* @param height {Number} height
	* @param rotationImage {CanvasObject} A CanvasObject that is 3x larger than the rotation image. For example if the rotation image is 32x32 this CanvasObject needs to be 96x96.
    *                                       This CanvasObject will get rotated offscreen and during blit it is drawn from on top of anything else.
    *                                       For example, if you have a normal animation defined (see BlittedTraveler) it would get drawn first into canvas,
    *                                       then the rotationImage is used to draw from next into canvas. setRotation and rotateWithMoverPoint rotate rotationImage.
    *                                       Your image needs to be facing right.
	* @param rotationFromRect {Rectangle}  A Rectangle defining where in the source to get the 3x area that has the 1x rotation image in the middle.
    *                                      For example, if your image is 32x32 it needs to be in the middle of 96x96 space, and this Rectangle would define that 96x96 area in the source.
    *                                       Your image needs to be facing right, see the top down rotating gun shooter example.
	*  
    * @see WDTraveler
    * @see BlittedTraveler
    *
	*/
    function RotatingTraveler( wd, source, canvas, fromRect, x, y, width, height, rotationImage, rotationFromRect) {

		tabageos.TravelerSkeleton.call(this,x,y,width,height);
		tabageos.Traveler.call(this,x,y,width,height);
		tabageos.BlittedTraveler.call(this,source, canvas, fromRect, x, y, width, height);
		tabageos.WDTraveler.call(this,wd, source, canvas, fromRect, x, y, width, height);
        this.init(source, canvas, fromRect, x, y, width, height);
        this._cWD = wd;
        this._wayDeterminer = wd;
        this.rImageHolder = rotationImage;
        this.rFromRect = rotationFromRect;
        this.roExA = 0;
        //rotation extended area 
        if (rotationImage) {
            this.rToPoint = new tabageos.MoverPoint(-((this.rImageHolder.width - this.roExA) / 2),-((this.rImageHolder.height - this.roExA) / 2));
            this._brFromRct = new tabageos.Rectangle(0,0,this.rFromRect.width,this.rFromRect.height);
        }
    };
	/** 
	*   
	*    
	*    
	* @memberof RotatingTraveler 
	*  
	*/
    RotatingTraveler.prototype.constructor = RotatingTraveler;
	RotatingTraveler.prototype = Object.create(tabageos.TravelerSkeleton.prototype);
	Object.assign(RotatingTraveler.prototype, tabageos.Traveler.prototype, tabageos.BlittedTraveler.prototype, tabageos.WDTraveler.prototype);
    /** 
	*   
	*    Rotation, use getRotation
	*    
	* @memberof RotatingTraveler
	*  
	*/
    RotatingTraveler.prototype.nr;
    
    /** 
	*   
	*    Returns the current rotation
	*    
	* @memberof RotatingTraveler.prototype 
	* @method getRotation
    * @returns {Number} 
	*/
    RotatingTraveler.prototype.getRotation = function() {
        return this.nr;
    };
    /** 
	*   
	*    Rotates the rImageHolder, when blit is called the result is seen.
	*    
	* @memberof RotatingTraveler
	* @method setRotation
	* @param toThis {Number} A number from 0 to 180 or -1 to -180
    * 
	*/
    RotatingTraveler.prototype.setRotation = function(toThis) {
        this.nr = toThis;
        var rhw = (this.rImageHolder.width - this.roExA) / 2;
        var rhh = (this.rImageHolder.height - this.roExA) / 2;
        this.rImageHolder.context.clearRect(0, 0, this.rImageHolder.width, this.rImageHolder.height);
        this.rImageHolder.context.save();
        this.rImageHolder.context.translate(rhw, rhh);
        this.rImageHolder.context.rotate(((Math.PI) * 2 * (this.nr / 360)));
        this.rImageHolder.copyPixels(this._source, this.rFromRect, this.rToPoint, this.rFromRect.width, this.rFromRect.height);
        this.rImageHolder.context.restore();
    };
    /** 
	*   
	*    
	*    @private
	* @memberof RotatingTraveler 
	*  
	*/
    RotatingTraveler.prototype.roExA = 0;
    
    /** 
	*   
	*    The CanvasObject that holds the image to rotate.
	* @type CanvasObject
	*    
	* @memberof RotatingTraveler
	*  
	*/
    RotatingTraveler.prototype.rImageHolder;
    
    /** 
	*   
	*    The rotation from Rectangle, defined during construction.
    *    To change what the rotation image is on the fly, simply change this rectangle.
    * @type Rectangle
	*    
	* @memberof RotatingTraveler
	*  
	*/
    RotatingTraveler.prototype.rFromRect;
    /** 
	*   
	*    
	*    @private
	* @memberof RotatingTraveler
	*  
	*/
    RotatingTraveler.prototype._brFromRct;
    /** 
	*   
	*    @private
	*    
	* @memberof RotatingTraveler
	*  
	*/
    RotatingTraveler.prototype.rToPoint;
    /** 
	*   
	*    @private
	*    
	* @memberof RotatingTraveler 
	*  
	*/
    RotatingTraveler.prototype._aro = 0;
    /** 
	*   
	*    @private
	*    
	* @memberof RotatingTraveler 
	*  
	*/
    RotatingTraveler.prototype._defaultAro = 0;
    /** 
	*   
	*    When called any animation would not show during blit, just the rotation.
    *   To bring back animations call this method again.
	*    
	* @memberof RotatingTraveler.prototype 
	* @method alwaysDisplayRotationOnly
    * 
	*/
    RotatingTraveler.prototype.alwaysDisplayRotationOnly = function() {
        this._defaultAro = (this._defaultAro == 0 ? 1 : 0);
        this._aro = 1;
    };
    /** 
	*   Rotate with a MoverPoint.
	*    
	*    
	* @memberof RotatingTraveler.prototype 
	* @method rotateWithMoverPoint
	* @param mp {MoverPoint} MoverPoint to rotate with.
	* @param addedY {Number} optional added y.
	* @param addedX {Number} optional added x.
	* 
    *
	*/
    RotatingTraveler.prototype.rotateWithMoverPoint = function(mp, addedY, addedX, offsetPoint) {
        this.nr = Math.atan2((mp.y + (addedY || 0)) - this.y, (mp.x + (addedX || 0)) - this.x) * 180 / Math.PI;
        var rhw = (this.rImageHolder.width - this.roExA) / 2;
        var rhh = (this.rImageHolder.height - this.roExA) / 2;
        this.rImageHolder.context.clearRect(0, 0, this.rImageHolder.width, this.rImageHolder.height);
        this.rImageHolder.context.save();
        this.rImageHolder.context.translate(rhw, rhh);
        this.rImageHolder.context.rotate(((Math.PI) * 2 * (this.nr / 360)));
        this.rImageHolder.copyPixels(this._source, this.rFromRect, this.rToPoint, this.rFromRect.width, this.rFromRect.height);
        this.rImageHolder.context.restore();
    };
    /** 
	*   
	*    Animate the rotation only,
    *   to use, call before calling blit.
    *   
	*   To maintain just showing the rotation you would have to keep calling this before calling blit.
    *   When just this method is used, subsequent blit calls would go back to animating both the defined animations and the rotation.
    *   To keep it only animating the roation use the alwaysDisplayRotationOnly method.
	* @memberof RotatingTraveler.prototype 
	* @method animateRotationOnly
    * 
	*/
    RotatingTraveler.prototype.animateRotationOnly = function() {

        this.animate();
        this.rFromRect.width = this.fromRect.width;
        // + this.fromWidthOffset;
        this.rFromRect.height = this.fromRect.height;
        // + this.fromHeightOffset;
        this.rFromRect.x = this.fromRect.x;
        this.rFromRect.y = this.fromRect.y;
        this._aro = 1;

    };
    /** 
	*   
	*    If animateRotationOnly has not been called, this method will display any animationSpecs defined animations first,
    *    and then it will draw the rotation image on top.
    *
    *    If animateRotationOnly has been called, then only the roation image is drawn.
    *   
	*    
	* @memberof RotatingTraveler.prototype 
	* @method blit
	* @param r {Object}
	* @param p {Object}
	* @param rop {Object}
    * 
	*/
    RotatingTraveler.prototype.blit = function(r, p) {
        if (r)
            this.fromRect = r;
        if (p) {
            this.toPoint = p;
        } else {
            this.toPoint.x = this.x+1-1;
            this.toPoint.y = this.y+1-1;
        }
        if (this._aro == 0) {
            this._canvas.copyPixels(this._source, this.fromRect, this.toPoint, this.fromRect.width + this.fromWidthOffset, this.fromRect.height + this.fromHeightOffset);
        } else {
            this._aro = this._defaultAro;
        }
        this._canvas.copyPixels(this.rImageHolder.canvas, this._brFromRct, this.toPoint, this.rFromRect.width, this.rFromRect.height);
    };

    tabageos.RotatingTraveler = RotatingTraveler;
})();


(function() { 
	'use strict'; 
	/**
	*
	* 
	*
	* @class RPEase
    * @classdesc
    *  Easing methods by Robert Penner. Used by the TweenMath Class.
    *
    *
	*/
    function RPEase( ) {};
	RPEase.easeOptions = {
        "Linear": true,
        "InLinear": true,
        "OutLinear": 1,
        "InOutLinear": 1,
        "InElastic": 1,
        "OutElastic": 1,
        "InOutElastic": 1,
        "InQuad": 1,
        "OutQuad": 1,
        "InOutQuad": 1,
        "InBounce": 1,
        "InOutBounce": 1,
        "OutBounce": 1,
        "InCirc": 1,
        "InBack": 1,
        "OutBack": 1,
        "InOutBack": 1,
        "InQuint": 1,
        "OutQuint": 1,
        "InOutQuint": 1,
        "OutCirc": 1,
        "InOutCirc": 1,
        "In": 1,
        "Out": 1,
        "InOut": 1,
        "InSine": 1,
        "OutSine": 1,
        "InOutSine": 1
    };
    /**
    *
    *
    * @memberof RPEase
    * @method InBack
    *
    */
    RPEase.InBack = function(t, b, c, d, s) {
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
    }
    ;
    RPEase.OutBack = function(t, b, c, d, s) {
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    }
    ;
    RPEase.InOutBack = function(t, b, c, d, s) {
        if ((t /= d / 2) < 1)
            return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
        return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
    }
    ;
    /**
    *
    *
    * @memberof RPEase
    * @method OutBounce
    *
    */
    RPEase.OutBounce = function(t, b, c, d) {
        if ((t /= d) < (1 / 2.75)) {
            return c * (7.5625 * t * t) + b;
        } else if (t < (2 / 2.75)) {
            return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
        } else if (t < (2.5 / 2.75)) {
            return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
        } else {
            return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
        }
    }
    ;
     /**
    *
    *
    * @memberof RPEase
    * @method InBounce
    *
    */
    RPEase.InBounce = function(t, b, c, d) {
        return c - RPEase.OutBounce(d - t, 0, c, d) + b;
    }
    ;
    RPEase.InOutBounce = function(t, b, c, d) {
        if (t < d / 2)
            return RPEase.InBounce(t * 2, 0, c, d) * .5 + b;
        else
            return RPEase.OutBounce(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
    }
    ;
    /**
    *
    *
    * @memberof RPEase
    * @method InCirc
    *
    */
    RPEase.InCirc = function(t, b, c, d) {
        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    }
    ;
    RPEase.OutCirc = function(t, b, c, d) {
        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    }
    ;
    RPEase.InOutCirc = function(t, b, c, d) {
        if ((t /= d / 2) < 1)
            return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    }
    ;
    /**
    *
    *
    * @memberof RPEase
    * @method In
    *
    */
    RPEase.In = function(t, b, c, d) {
        return c * (t /= d) * t * t + b;
    }
    ;
    /**
    *
    *
    * @memberof RPEase
    * @method Out
    *
    */
    RPEase.Out = function(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t + 1) + b;
    }
    ;
    RPEase.InOut = function(t, b, c, d) {
        if ((t /= d / 2) < 1)
            return c / 2 * t * t * t + b;
        return c / 2 * ((t -= 2) * t * t + 2) + b;
    }
    ;
    /**
    *
    *
    * @memberof RPEase
    * @method InElastic
    *
    */
    RPEase.InElastic = function(t, b, c, d, a, p) {
        if (t == 0)
            return b;
        if ((t /= d) == 1)
            return b + c;
        if (!p)
            p = d * .3;
        if (!a || a < Math.abs(c)) {
            a = c;
            var s = p / 4;
        } else
            s = p / (2 * Math.PI) * Math.asin(c / a);
        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    }
    ;
    RPEase.OutElastic = function(t, b, c, d, a, p) {
        if (t == 0)
            return b;
        if ((t /= d) == 1)
            return b + c;
        if (!p)
            p = d * .3;
        if (!a || a < Math.abs(c)) {
            a = c;
            var s = p / 4;
        } else
            s = p / (2 * Math.PI) * Math.asin(c / a);
        return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
    }
    ;
    RPEase.InOutElastic = function(t, b, c, d, a, p) {
        if (t == 0)
            return b;
        if ((t /= d / 2) == 2)
            return b + c;
        if (!p)
            p = d * (.3 * 1.5);
        if (!a || a < Math.abs(c)) {
            a = c;
            var s = p / 4;
        } else
            s = p / (2 * Math.PI) * Math.asin(c / a);
        if (t < 1)
            return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
    }
    ;
    /**
    *
    *
    * @memberof RPEase
    * @method InExpo
    *
    */
    RPEase.InExpo = function(t, b, c, d) {
        return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
    }
    ;
    RPEase.OutExpo = function(t, b, c, d) {
        return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
    }
    ;
    RPEase.InOutExpo = function(t, b, c, d) {
        if (t == 0)
            return b;
        if (t == d)
            return b + c;
        if ((t /= d / 2) < 1)
            return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
        return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
    }
    ;
    /**
    *
    *
    * @memberof RPEase
    * @method Linear
    *
    */
    RPEase.Linear = function(t, b, c, d) {
        return c * t / d + b;
    }
    ;
    RPEase.InLinear = function(t, b, c, d) {
        return c * t / d + b;
    }
    ;
    RPEase.OutLinear = function(t, b, c, d) {
        return c * t / d + b;
    }
    ;
    RPEase.InOutLinear = function(t, b, c, d) {
        return c * t / d + b;
    }
    ;
    /**
    *
    *
    * @memberof RPEase
    * @method InQuad
    *
    */
    RPEase.InQuad = function(t, b, c, d) {
        return c * (t /= d) * t + b;
    }
    ;
    RPEase.OutQuad = function(t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
    }
    ;
    RPEase.InOutQuad = function(t, b, c, d) {
        if ((t /= d / 2) < 1)
            return c / 2 * t * t + b;
        return -c / 2 * ((--t) * (t - 2) - 1) + b;
    }
    ;
    /**
    *
    *
    * @memberof RPEase
    * @method InQuart
    *
    */
    RPEase.InQuart = function(t, b, c, d) {
        return c * (t /= d) * t * t * t + b;
    }
    ;
    RPEase.OutQuart = function(t, b, c, d) {
        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    }
    ;
    RPEase.InOutQuart = function(t, b, c, d) {
        if ((t /= d / 2) < 1)
            return c / 2 * t * t * t * t + b;
        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
    }
    ;
    /**
    *
    *
    * @memberof RPEase
    * @method InQuint
    *
    */
    RPEase.InQuint = function(t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b;
    }
    ;
    RPEase.OutQuint = function(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    }
    ;
    RPEase.InOutQuint = function(t, b, c, d) {
        if ((t /= d / 2) < 1)
            return c / 2 * t * t * t * t * t + b;
        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    }
    ;
    /**
    *
    *
    * @memberof RPEase
    * @method InSine
    *
    */
    RPEase.InSine = function(t, b, c, d) {
        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
    }
    ;
    RPEase.OutSine = function(t, b, c, d) {
        return c * Math.sin(t / d * (Math.PI / 2)) + b;
    }
    ;
    RPEase.InOutSine = function(t, b, c, d) {
        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
    }
    ;
    tabageos.RPEase = RPEase;
})();


(function() { 
	'use strict';
    
   /** 
	*   
	*    Constructs a new SceneryObject
	*    
	* @class SceneryObject
    * @classdesc 
    *
    *  A MapMover that is designated as a scenery object.
    *
    *
	* @param x {Number}
	* @param y {Number}
	* @param width {Number}
	* @param height {Number}
	* @param map {Array}
	* @param ca {CanvasAnimation}
	* @param dontCloneMap {Object}
	* @param dt {Number} Default is TimeKeeper._sae
	* @param tw {Number} tile height
	* @param th {Number} tile width
	* @param mr {Number} map rows
	* @param mc {Number} map columns 
	*  
	*/
    function SceneryObject(x,y,width,height,map,ca,dontCloneMap,dt,tw,th,mr,mc) {
		tabageos.MoverSkeleton.call(this,x,y,width,height);
		tabageos.MapMover.call(this,x,y,width,height, map,ca,dontCloneMap, dt, tw, th,mr,mc);
        this.width = width || 0;
        this.height = height || 0;
        this._middlePoint = new tabageos.MoverPoint();
        this._pos = new tabageos.MoverPoint(x || 0,y || 0);
        this._veloc = new tabageos.MoverPoint(0,0);
        this._lastVeloc = new tabageos.MoverPoint(0,0);
        this._lastPos = new tabageos.MoverPoint(x,y);
        this._deltaTime = dt || tabageos.TimeKeeper._sae;
        this._map = dontCloneMap ? map : tabageos.BlitMath.cloneMultiArray(map);
        this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
        this._state = 1;
        this.x = x || 0;
        this.y = y || 0;
        this._tH = th || this.height;
        this._tW = tw || this.width;
        this._canvasAnimation = ca || null;
        this.playerHoldingThis = null;
        this.tileValue = null;
        this.weight = 24;
        this.xDirection = 1;
		this._solidSit = 0;this._eHit = 0;
		this.tileRect = null;
        this._checkHelper = new tabageos.MoverPoint();
    };
	/** 
	*   
	*    
	*    
	* @memberof SceneryObject 
	*  
	*/
    SceneryObject.prototype.constructor = SceneryObject;
	SceneryObject.prototype = Object.create(tabageos.MoverSkeleton.prototype);
	Object.assign(SceneryObject.prototype, tabageos.MapMover.prototype);
    /** 
	*   
	*    Designates the player that is holding this SceneryObject.
	*    
	* @memberof SceneryObject.prototype 
	*  
	*/
    SceneryObject.prototype.playerHoldingThis; //SceneryThrower
    /** 
	*   
	*    
	*    
	* @memberof SceneryObject.prototype  
	*  
	*/
    SceneryObject.prototype.weight = 1;
    /** 
	*   
	*    
	*    
	* @memberof SceneryObject.prototype  
	*  
	*/
    SceneryObject.prototype._canvasAnimation = null;
    /** 
	*   
	*    
	*    
	* @memberof SceneryObject.prototype  
	*  
	*/
    SceneryObject.prototype.xDirection = 1;
    /** 
	*   
	*    The [y,x] tile value or other tile value of the SceneryObject.
	*    
	* @memberof SceneryObject.prototype  
	*  
	*/
    SceneryObject.prototype.tileValue = null;
    /** 
	*   
	*    The Rectangle defining the scenery object graphic location in the sprite sheet.
	*    
	* @memberof SceneryObject.prototype  
	*  
	*/
    SceneryObject.prototype.tileRect = null;
	/** 
	*   
	*    To designate that a AISceneryThrower threw it.
	*    
	* @memberof SceneryObject.prototype  
	*  
	*/
    SceneryObject.prototype._eHit = 0;
	/** 
	*   
	*    To designate that the SceneryObject is collidable
	*    
	* @memberof SceneryObject.prototype  
	*  
	*/
    SceneryObject.prototype._solidSit = 0;
    
    tabageos.SceneryObject = SceneryObject;
})();

(function() { 

	'use strict';
   
    /** 
    * @classdesc
	*   A BlittedTraveler designated as a SceneryObject 
	*    
	*    
	* @class SceneryObjectBlittedTraveler
	* @param source 
	* @param canvasObject 
	* @param fromRect 
	* @param x 
	* @param y 
	* @param width 
	* @param height  
	*  
	*/
    function SceneryObjectBlittedTraveler(source, canvasObject, fromRect, x, y, width, height) {
		tabageos.TravelerSkeleton.call(this,x,y,width,height);
		tabageos.Traveler.call(this,x,y,width,height);
		tabageos.BlittedTraveler.call(this,source,canvasObejct,fromRect,x,y,width,height);
        this.init(source, canvasObject, fromRect, x, y, width, height);
        this.playerHoldingThis = null;
        this.tileValue = null;
        this.weight = 1;
        this.xDirection = 1;
    };
	/** 
	*   
	*    
	*    
	* @memberof SceneryObjectBlittedTraveler 
	*  
	*/
    SceneryObjectBlittedTraveler.prototype.constructor = SceneryObjectBlittedTraveler;
	SceneryObjectBlittedTraveler.prototype = Object.create(tabageos.TravelerSkeleton.prototype);
	Object.assign(SceneryObjectBlittedTraveler.prototype, tabageos.Traveler.prototype, tabageos.BlittedTraveler.prototype);
    /** 
	*   
	*    Used to reference the player Class instance that is holding this SceneryObjectBlittedTraveler
	*    
	* @memberof SceneryObjectBlittedTraveler 
	*  
	*/
    SceneryObjectBlittedTraveler.prototype.playerHoldingThis;
    /** 
	*   
	*    The optional weight of the SceneryObjectBlittedTraveler
	*    
	* @memberof SceneryObjectBlittedTraveler 
	*  
	*/
    SceneryObjectBlittedTraveler.prototype.weight = 1;
    /** 
	*   
	*    Optional horizontal direction of the SceneryObjectBlittedTraveler
	*    
	* @memberof SceneryObjectBlittedTraveler 
	*  
	*/
    SceneryObjectBlittedTraveler.prototype.xDirection = 1;
    /** 
	*   
	*    Optional tile value of the SceneryObjectBlittedTraveler,
	*    would be the value in whatever map this SceneryObjectBlittedTraveler came from.
	*    
	* @memberof SceneryObjectBlittedTraveler 
	*  
	*/
    SceneryObjectBlittedTraveler.prototype.tileValue = null;

    tabageos.SceneryObjectBlittedTraveler = SceneryObjectBlittedTraveler;
})();


(function() { 

	'use strict';
   
    /** 
	*   
	*    @classdesc
    *     A MapTraveler designated as a SceneryObject
	*    
	* @class SceneryObjectTraveler
	* @param x 
	* @param y 
	* @param width 
	* @param height 
	* @param map 
	* @param ca 
	* @param dontCloneMap 
	* @param dt 
	* @param tileW 
	* @param tileH  
	*  
	*/
    function SceneryObjectTraveler(x,y,width,height, map,ca,dontCloneMap, dt, tileW, tileH) {
		tabageos.TravelerSkeleton.call(this,x,y,width,height);
		tabageos.MapTraveler.call(this,x,y,width,height, map,ca,dontCloneMap, dt, tileW, tileH);
		
        this.playerHoldingThis = null;
        this.tileValue = null;
        this.weight = 1;
        this.xDirection = 1;
    };
	/** 
	*   
	*    
	*    
	* @memberof SceneryObjectTraveler 
	*  
	*/
    SceneryObjectTraveler.prototype.constructor = SceneryObjectTraveler;
	SceneryObjectTraveler.prototype = Object.create(tabageos.TravelerSkeleton.prototype);
	Object.assign(SceneryObjectTraveler.prototype, tabageos.MapTraveler.prototype);
    /** 
	*   
	*    
	*    
	* @memberof SceneryObjectTraveler 
	*  
	*/
    SceneryObjectTraveler.prototype.playerHoldingThis;
    /** 
	*   
	*    
	*    
	* @memberof SceneryObjectTraveler 
	*  
	*/
    SceneryObjectTraveler.prototype.weight = 1;
    /** 
	*   
	*    
	*    
	* @memberof SceneryObjectTraveler 
	*  
	*/
    SceneryObjectTraveler.prototype.xDirection = 1;
    /** 
	*   
	*    
	*    
	* @memberof SceneryObjectTraveler 
	*  
	*/
    SceneryObjectTraveler.prototype.tileValue = null;

    tabageos.SceneryObjectTraveler = SceneryObjectTraveler;
})();


(function() {

	'use strict';
	
    /** 
	*   
	*    Constructs a new SceneryThrower.
	*    
	* @class SceneryThrower
    * @classdesc
    *
    *  A MapMover designated as a thrower of SceneryObjects, 
    *  with methods for throwing and picking up and referencing SceneryObjects.
    *
	* @param x {Number}
	* @param y {Number}
	* @param width {Number}
	* @param height {Number}
	* @param map {Array}
	* @param ca {CanvasAnimation}
	* @param dontCloneMap {Boolean}
	* @param dt {Number} Default is TimeKeeper._sae
	* @param tWidth {Number} tile width
	* @param tHeight {Number} tile height
	* @param mr {Number} map rows
	* @param mc {Number} map columns 
    *
    * @see MapMover
	*  
	*/
    function SceneryThrower(x,y,width,height, map, ca,dontCloneMap,dt,tWidth,tHeight,mr,mc) {
		tabageos.MoverSkeleton.call(this,x,y,width,height);
		tabageos.MapMover.call(this,x,y,width,height, map, ca,dontCloneMap,dt,tWidth,tHeight,mr,mc);
        //this.init(source, canvasObject, fromRect, x, y, width, height);
        this.width = width || 0;
        this.height = height || 0;
        this._middlePoint = new tabageos.MoverPoint();
        this._pos = new tabageos.MoverPoint(x || 0,y || 0);
        this._veloc = new tabageos.MoverPoint(0,0);
        this._lastVeloc = new tabageos.MoverPoint(0,0);
        this._lastPos = new tabageos.MoverPoint(x,y);
        this._deltaTime = dt || tabageos.TimeKeeper._sae;
        this._map = dontCloneMap ? map : tabageos.BlitMath.cloneMultiArray(map);
        this._state = 1;
        this.x = x || 0;
        this.y = y || 0;
        this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
        this._canvasAnimation = ca || null;
        this._tH = tHeight || 16;
        this._tW = tWidth || 16;
        this._outAltered = new tabageos.MoverPoint();
        this.holdingRect = new tabageos.Rectangle(0,0,width,height);
        this.holdingOffsetX = 1;
        this.holdingOffsetY = 3;
		this.health = 100;
		this.holding = null;
		this.nameOfThrower = "strawHat";
        this._checkHelper = new tabageos.MoverPoint();
    };
	/** 
	*   
	*    
	*    
	* @memberof SceneryThrower 
	*  
	*/
    SceneryThrower.prototype.constructor = SceneryThrower;
    SceneryThrower.prototype = Object.create(tabageos.MoverSkeleton.prototype); 
	Object.assign(SceneryThrower.prototype, tabageos.MapMover.prototype);
    /** 
	*   
	*    
	*    
	* @memberof SceneryThrower 
	*  
	*/
    SceneryThrower.prototype.throwStrength = 10;
    /** 
	*   
	*    
	*    
	* @memberof SceneryThrower
	*  
	*/
    SceneryThrower.prototype.health = 100;
    /** 
	*   
	*    Designated to hold a reference to whatever is being held.
	* 
	* @memberof SceneryThrower
	*  
	*/
    SceneryThrower.prototype.holding;//TileData
    /** 
	*   
	*    
	*    
	* @memberof SceneryThrower 
	*  
	*/
    SceneryThrower.prototype.holdingRect;
    /** 
	*   
	*    
	*    
	* @memberof SceneryThrower 
	*  
	*/
    SceneryThrower.prototype._canvasAnimation = null;
    /** 
	*   
	*    
	*    
	* @memberof SceneryThrower 
	*  
	*/
    SceneryThrower.prototype._outAltered;
    /** 
	*   
	*    
	*    
	* @memberof SceneryThrower 
	*  
	*/
    SceneryThrower.prototype.holdingOffsetX = 1;
    /** 
	*   
	*    
	*    
	* @memberof SceneryThrower
	*  
	*/
    SceneryThrower.prototype.holdingOffsetY = 3;
    /** 
	*   
	*    
	*    
	* @memberof SceneryThrower 
	*  
	*/
    SceneryThrower.prototype.nameOfThrower = "strawHat";

    /** 
	*   
	*    Returns a reference to altered position.
	*    
	* @memberof SceneryThrower.prototype 
	* @method alteredPosition
	* @param xAlterAmount {Number}
	* @param yAlterAmount {Number}
    * @returns {MoverPoint} 
	*/
    SceneryThrower.prototype.alteredPosition = function(xAlterAmount, yAlterAmount) {
        xAlterAmount = xAlterAmount || 0;
        yAlterAmount = yAlterAmount || 0;
        this._outAltered.x = this.x - xAlterAmount;
        this._outAltered.y = this.y - yAlterAmount;
        return this._outAltered;
    };
    /** 
	*   
	*    Returns the from Rectangle for the SceneryObject it is holding,
    *       used to know where to draw from a sprite sheet.
	*    
	* @memberof SceneryThrower.prototype 
	* @method holdingImageRect
    * @returns {Rectangle} 
	*/
    SceneryThrower.prototype.holdingImageRect = function() {
        return this.holdingRect;
    };
    /** 
	*   
	*    Pick up TileData, this.holding will be set to the TileData passed,
    *       and the holdingRect will be calculated.
	*    
	* @memberof SceneryThrower.prototype 
	* @method pickUpTileData
	* @param td {TileData} the TileData to pick up.
	* @param imageWidthAdjust {Number} Optional width to adjust holding rect result.
	* @param imageHeightAdjust {Number} Optional height to adjust holding rect result.
    * @returns {Boolean} Returns true of td was picked up. 
	*/
    SceneryThrower.prototype.pickUpTileData = function(td, imageWidthAdjust, imageHeightAdjust) {
        if (!this.holding) {
            this.holding = td;
            this.holdingRect.x = this.holding.value[1] * (this._tw);
            this.holdingRect.y = this.holding.value[0] * (this._th);
            this.holdingRect.width = this._tw;
            this.holdingRect.height = this._th;
            if (imageWidthAdjust) {
                this.holdingRect.width += imageWidthAdjust;
            }
            if (imageHeightAdjust) {
                this.holdingRect.height += imageHeightAdjust;
            }
            return true;
        }
        return false;
    };
    /** 
	*   
	*    Picks up a SceneryObject, this.holding will be set to the obj.
    *       and this.holdingRect will be calculated.
	*    
	* @memberof SceneryThrower.prototype 
	* @method pickUp
	* @param obj {SceneryObject} The SceneryObject to pick up.
	* @param imageWidthAdjust {Number} Optional width to adjust holding rect result.
	* @param imageHeightAdjust {Number} Optional height to adjust holding rect result. 
    * @returns {Boolean} Returns true if obj was picked up. 
	*/
    SceneryThrower.prototype.pickUp = function(obj, imageWidthAdjust, imageHeightAdjust) {
        if (!this.holding) {
            this.holding = obj;
            this.holdingRect.x = obj.tileValue[1] * (obj.width);
            this.holdingRect.y = obj.tileValue[0] * (obj.height);
            this.holdingRect.width = obj.width;
            this.holdingRect.height = obj.height;
            if (imageWidthAdjust) {
                this.holdingRect.width += imageWidthAdjust;
            }
            if (imageHeightAdjust) {
                this.holdingRect.height += imageHeightAdjust;
            }
            return true;
        }
        return false;
    };
    /** 
	*   
	*    Sets this.holding to null.
	*    
	* @memberof SceneryThrower.prototype 
	* @method _throwHolding
    * 
	*/
    SceneryThrower.prototype._throwHolding = function() {
        
        this.holding = null;
        
    };
    /** 
	*   
	*    Throws what it is holding as a SceneryObject.
    *    this.holding becomes null after this method is called.
	*    
	* @memberof SceneryThrower.prototype 
	* @method throwSceneryObject
	* @param w {Number} Tile width, default is the tile width set at construction or 16.
	* @param h {Number} Tile height, default is the tile height set at construction or 16.
	* @param jumps {Number} Should gravity be applied to the SceneryObject, default is 0.
    * @returns {SceneryObject} 
	*/
    SceneryThrower.prototype.throwSceneryObject = function(w,h,jumps) {
        var scenery;
        if (this.holding) {
            
            scenery = new tabageos.SceneryObject(this.x+1-1,this.y+1-1,w||this._tw,h||this._th,this._map,null,1,this._deltaTime, this._tw, this._th,this._mapRows,this._mapColumns);
            scenery._jumps = jumps || 0;
            scenery.playerHoldingThis = this;
            scenery.tileValue = this.holding.value || this.holding.tileValue;
            scenery.tileRect = new tabageos.Rectangle(this.holdingRect.x,this.holdingRect.y,this.holdingRect.width,this.holdingRect.height);

            this._throwHolding();
            return scenery;
        }
        return null;
    };
    tabageos.SceneryThrower = SceneryThrower;
})();
(function() { 
	'use strict';
    /** 
	*   @classdesc
    *   Used by the ScreenOrganizer Class.
	*    
	*    
	* @class ScreenChangeEvent
	* @param scn 
	* @param type 
	* @param potato  
	*  
	*/
    function ScreenChangeEvent(scn, type, potato) {
		tabageos.Event.call(this,type,potato);
		this.target = null;
        this.screenChangeNumber = scn || 0;
        this.type = type || "screenChange";
        this.potato = potato || {};
    }
    ;
	/** 
	*   
	*    
	*    
	* @memberof ScreenChangeEvent 
	*  
	*/
    ScreenChangeEvent.prototype.constructor = ScreenChangeEvent;
	ScreenChangeEvent.prototype = Object.create(tabageos.Event.prototype);
    /** 
	*   
	*    
	*    
	* @memberof ScreenChangeEvent 
	*  
	*/
    ScreenChangeEvent.prototype.screenChangeNumber = 0;
    /**
    *
    * @memberof ScreenChangeEvent
    *
    */
    ScreenChangeEvent.SCREEN_CHANGE = "screenChange";
    /**
    *
    * @memberof ScreenChangeEvent
    *
    */
    ScreenChangeEvent.COVER = "cover";
    /**
    *
    * @memberof ScreenChangeEvent
    *
    */
    ScreenChangeEvent.UNCOVER = "unCover";
    /**
    *
    * @memberof ScreenChangeEvent
    *
    */
    ScreenChangeEvent.UNDER_COVER_CHANGES_COMPLETE = "underCoverChangesComplete";
    tabageos.ScreenChangeEvent = ScreenChangeEvent;
})();



(function() { 
	'use strict';
    /** 
    * @classdesc
	*   Holds and references the Objects that make up a games various screens,
	*   and has methods for switching between them with graphical transitions.
	* @see EventDispatcher
	*    
	* @class ScreenOrganizer
	* @param game {CanvasObjectContainer} A reference to the CanvasObjectContainer that is holding the whole game.
	* @param screenClasses {Array} An Array of Classes or Objects that this screen organizer will hold. Other CanvasObjectContainers or CanvasObjects that will act as different screens for the game.
	* @param [screenConfigs] {Array} An optional Array of methods to call when each screen is initialized.
    *
    * 
    * 
	*  
	*/
    function ScreenOrganizer(game, screenClasses, screenConfigs) {
		tabageos.EventDispatcher.call(this);
        if (game && screenClasses) {
            this.init(game, screenClasses, screenConfigs);
        }
		this._thrott = 0;
		this.pr = 0;
		this._aid = 0;
		if(ScreenOrganizer._instance) {
			throw "ScreenOrganizer is a singleton, there should only be one ScreenOrganizer.";
		} else {
			ScreenOrganizer._instance = this;
		}
    };
	/** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype.constructor = ScreenOrganizer;
	ScreenOrganizer.prototype = Object.create(tabageos.EventDispatcher.prototype);
	/** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype._thrott = 0;
	/** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype.pr = 0;
	/** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype._aid = 0;
	ScreenOrganizer._instance = null;
    /** 
	*   
	*    Acts like a super function.
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method init
	* @param game {Object} A reference to the CanvasObjectContainer that holds the whole game.
	* @param screenClasses {Array} An Array of Classes or Objects that will make up the game. If you pass Classes, they will be instantiated.
	* @param screenConfigs {Array} An optional Array of methods to call when each related class is added
    * 
	*/
    ScreenOrganizer.prototype.init = function(game, screenClasses, screenConfigs) {
        var i = 0;
        this.theGame = game;
        if (!this.theGame.div && !this.theGame.floor) {
            throw "game must be a CanvasObjectContainer";
        }
        this.myEvents = new tabageos.EventDispatcher();
        this.coverShape = new tabageos.CanvasObject(null,this.theGame.getWidth(),this.theGame.getHeight());
        this.screenChanging = new tabageos.ScreenChangeEvent(0,tabageos.ScreenChangeEvent.SCREEN_CHANGE);
        this.covered = new tabageos.ScreenChangeEvent(0,tabageos.ScreenChangeEvent.COVER);
        this.uncovered = new tabageos.ScreenChangeEvent(0,tabageos.ScreenChangeEvent.UNCOVER);
        this.rectRef = new tabageos.Rectangle(0,0,0,0);
        this._screens = [];
        if (screenClasses) {
            this.gameTitleScreen = (typeof screenClasses[0] == "function" ? new screenClasses[0]() : screenClasses[0]);
            this._screens[0] = this.gameTitleScreen;
            if (this._screens[0] == null)
                throw ("The first screen should be the title screen and must be a CanvasObjectContainer.");
            for (i = 0; i < screenClasses.length; i++) {
                if (typeof screenClasses[i] == "function") {
                    if (i != 0)
                        this._screens[i] = new screenClasses[i]();
                } else {
                    if (i != 0)
                        this._screens[i] = screenClasses[i];
                }
                if (screenConfigs && screenConfigs.length != 0 && screenConfigs[i] && typeof screenConfigs[i] == "function") {
                    screenConfigs[i]();
                }
            }
        }
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype.gameTitleScreen = null;
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype.currentScreen = null;
   
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype.myEvents = null;
    /** 
	*   Holds a reference to each screen.
    *
	*    @type Array
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype._screens = null;
    /** 
	*   
	*    @private 
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype._waitForUnderCoverChanges = null;
    /** 
	*   @private 
	*    
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype.theGame = null;
    /** 
	*   
	*    @private 
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype.screenChanging = null;
    /** 
	*   
	*    @private 
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype.covered = null;
    /** 
	*   
	*    @private 
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype.uncovered = null;
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype.coverShape = null;
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype.coverTimer = null;
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype.transitioning = 0;
    /** 
	*   
	*    Returns true if a transition is currently happening.
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method getTransitionStatus
    * @returns {Boolean} 
	*/
    ScreenOrganizer.prototype.getTransitionStatus = function() {
        return this.transitioning > 0;
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method getScreens
    * @returns {Array} 
	*/
    ScreenOrganizer.prototype.getScreens = function() {
        return this._screens;
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method getGameReference
    * @returns {Object} 
	*/
    ScreenOrganizer.prototype.getGameReference = function() {
        return this.theGame;
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method getCoverAnimationRate
    * @returns {Number} 
	*/
    ScreenOrganizer.prototype.getCoverAnimationRate = function() {
        return this.coverTimer ? this.coverTimer.delay : 0;
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method setCoverAnimationRate
	* @param toThis {Number}
    * 
	*/
    ScreenOrganizer.prototype.setCoverAnimationRate = function(toThis) {
        if (this.coverTimer) {
            this.coverTimer.delay = toThis;
        }
    };
    /** 
	*   
	*    @type {String}
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype._cColor = "#000000";
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method getCoverColor
    * @returns {String} 
	*/
    ScreenOrganizer.prototype.getCoverColor = function() {
        return this._cColor;
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method setCoverColor
	* @param toThis 
    * 
	*/
    ScreenOrganizer.prototype.setCoverColor = function(toThis) {
        this._cColor = toThis;
        this.coverShape.fillRect(new tabageos.Rectangle(0,0,this.theGame.width,this.theGame.height), toThis);
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method getWaitForUnderCoverChanges
    * @returns {Boolean} 
	*/
    ScreenOrganizer.prototype.getWaitForUnderCoverChanges = function() {
        return this._waitForUnderCoverChanges;
    };
    /** 
	*   
	*    If set to true then the transition will wait for any under cover changes to complete before transitioning back.
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method setWaitForUnderCoverChanges
	* @param toThis {Boolean}
    * 
	*/
    ScreenOrganizer.prototype.setWaitForUnderCoverChanges = function(toThis) {
        this._waitForUnderCoverChanges = toThis;
    };
    /** 
	*   
	*    Transition foward without removing screens. Used by changeScreen.
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method showCoverNoKill
	* @param ts 
    *  
	*/
    ScreenOrganizer.prototype.showCoverNoKill = function(ts) {
		
		if(ScreenOrganizer._instance._thrott == 0) ScreenOrganizer._instance._thrott = ts;
		ScreenOrganizer._instance.pr = ts - ScreenOrganizer._instance._thrott;
		if(ScreenOrganizer._instance.pr >= 15) {
			ScreenOrganizer._instance._thrott = ts;
			var forward = ScreenOrganizer._instance.transitionForward();
			if (forward) {
				window.cancelAnimationFrame(ScreenOrganizer._instance._aid);
				ScreenOrganizer._instance.myEvents.dispatchEvent(ScreenOrganizer._instance.screenChanging);
				
				return;
			} 
		}
		
		ScreenOrganizer._instance._aid = window.requestAnimationFrame(ScreenOrganizer._instance.showCoverNoKill);
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method initializeTransition
    * 
	*/
    ScreenOrganizer.prototype.initializeTransition = function() {
        this.coverShape.setAlpha(1);
        this.rectRef.width = 0;
        this.rectRef.height = 0;
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method addScreenUnderCover
	* @param e 
    * 
	*/
    ScreenOrganizer.prototype.addScreenUnderCover = function(e) {
	   window.cancelAnimationFrame(ScreenOrganizer._instance._aid);
        this.myEvents.removeEventListener(tabageos.ScreenChangeEvent.SCREEN_CHANGE, "addScreenUnderCover", this);
        if (this._waitForUnderCoverChanges == true) {
            this.addEventListener(tabageos.ScreenChangeEvent.UNDER_COVER_CHANGES_COMPLETE, "initRemoveCover", this);
        }
        if (this._screens[e.screenChangeNumber] && this._screens[e.screenChangeNumber] != this.theGame && this.theGame.contains(this.coverShape)) {
            this.theGame.removeChild(this.coverShape);
            this.theGame.addChild(this._screens[e.screenChangeNumber]);
            this.theGame.addChild(this.coverShape);
        }
        this.currentScreen = e.screenChangeNumber;
        this.covered.screenChangeNumber = e.screenChangeNumber;
        if (this._waitForUnderCoverChanges == true) {
            this.dispatchEvent(this.covered);
        } else {
            this.dispatchEvent(this.covered);
            this.initRemoveCover();
        }
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer 
	*  
	*/
    ScreenOrganizer.prototype.rectRef = null;
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method transitionBackward
    * @returns {Boolean} Returns true when transition is complete 
	*/
    ScreenOrganizer.prototype.transitionBackward = function() {
        this.rectRef.width = this.coverShape.width;
        this.rectRef.height += 16;
        this.coverShape.context.clearRect(this.rectRef.x, this.rectRef.y, this.rectRef.width, this.rectRef.height);
        var b = this.rectRef.height >= this.coverShape.height;
        if (b) {
            this.rectRef.width = 0;
            this.rectRef.height = 0;
        }
        return b;
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method transitionForward
    * @returns {Boolean} Returns true when transition is complete 
	*/
    ScreenOrganizer.prototype.transitionForward = function() {
        this.rectRef.width = this.coverShape.width;
        this.rectRef.height += 16;
        this.coverShape.drawRect(this.rectRef, "#000000");
        var b = this.rectRef.height >= this.coverShape.height;
        if (b) {
            this.rectRef.width = 0;
            this.rectRef.height = 0;
        }
        return b;
    };
    /** 
	*   
	*    Change to the screen without removing other screens.
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method changeScreen
	* @param toThis {Number}
    * 
	*/
    ScreenOrganizer.prototype.changeScreen = function(toThis) {
        if (this.transitioning == 0) {
		   window.cancelAnimationFrame(ScreenOrganizer._instance._aid);
            this.myEvents.addEventListener(tabageos.ScreenChangeEvent.SCREEN_CHANGE, "addScreenUnderCover", this);
            if (this.theGame.getNumChildren() == 0 || !this.theGame.contains(this.coverShape)) {
                if (this.theGame.contains(this.coverShape)) {
                    this.theGame.removeChild(this.coverShape);
                }
                this.theGame.addChild(this.coverShape);
            }
            this.transitioning = 1;
            this.initializeTransition();
            this.screenChanging.screenChangeNumber = toThis;
			
			ScreenOrganizer._instance._aid = window.requestAnimationFrame(this.showCoverNoKill);
        }
    };
    /** 
	*   
	*    Switch to a screen and remove all others.
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method switchScreen
	* @param toThis 
    * 
	*/
    ScreenOrganizer.prototype.switchScreen = function(toThis) {
        if (this.transitioning == 0) {
		  window.cancelAnimationFrame(ScreenOrganizer._instance._aid);
            this.myEvents.addEventListener(tabageos.ScreenChangeEvent.SCREEN_CHANGE, "addScreenUnderCover", this);
            if (this.theGame.getNumChildren() == 0 || !this.theGame.contains(this.coverShape)) {
                if (this.theGame.contains(this.coverShape)) {
                    this.theGame.removeChild(this.coverShape);
                }
                this.theGame.addChild(this.coverShape);
            }
            this.transitioning = 1;
            this.initializeTransition();
            this.screenChanging.screenChangeNumber = toThis;
			
			ScreenOrganizer._instance._aid = window.requestAnimationFrame(this.showCoverAndKill);
        }
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method initRemoveCover
	* @param e 
    * 
	*/
    ScreenOrganizer.prototype.initRemoveCover = function(e) {
        this.removeEventListener(tabageos.ScreenChangeEvent.UNDER_COVER_CHANGES_COMPLETE, "initRemoveCover", this);
        this.myEvents.addEventListener(tabageos.ScreenChangeEvent.SCREEN_CHANGE, "uncoverDone", this);
		ScreenOrganizer._instance._aid = window.requestAnimationFrame(ScreenOrganizer._instance.removeCoverByFadeOut);
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method removeCoverByFadeOut
	* @param ts 
    *  
	*/
    ScreenOrganizer.prototype.removeCoverByFadeOut = function(ts) {
		
		if(ScreenOrganizer._instance._thrott == 0) ScreenOrganizer._instance._thrott = ts;
		ScreenOrganizer._instance.pr = ts - ScreenOrganizer._instance._thrott;
		if(ScreenOrganizer._instance.pr >= 15) {
			ScreenOrganizer._instance._throt = ts;
			var back = ScreenOrganizer._instance.transitionBackward();
			if (back) {
				window.cancelAnimationFrame(ScreenOrganizer._instance._aid);
				if (ScreenOrganizer._instance.theGame.contains(ScreenOrganizer._instance.coverShape)) {
					ScreenOrganizer._instance.theGame.removeChild(ScreenOrganizer._instance.coverShape);
				}
				
				ScreenOrganizer._instance.myEvents.dispatchEvent(ScreenOrganizer._instance.screenChanging);
				return;
			} 
		
		}
		
		ScreenOrganizer._instance._aid = window.requestAnimationFrame(ScreenOrganizer._instance.removeCoverByFadeOut);
    };
    /** 
	*   
	*    Transitions foward and removes all children from theGame. Used by switchScreen.
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method showCoverAndKill
	* @param ts 
    * 
	*/
    ScreenOrganizer.prototype.showCoverAndKill = function(ts) {
		
		if(ScreenOrganizer._instance._thrott == 0) ScreenOrganizer._instance._thrott = ts;
		ScreenOrganizer._instance.pr = ts - ScreenOrganizer._instance._thrott;
		if(ScreenOrganizer._instance.pr >= 15) {
			ScreenOrganizer._instance._thrott = ts;
			var forward = ScreenOrganizer._instance.transitionForward();
			if (forward) {
				window.cancelAnimationFrame(ScreenOrganizer._instance._aid);
				//window.console.log("k canc");
				while (ScreenOrganizer._instance.theGame.getNumChildren() > 0) {
					ScreenOrganizer._instance.theGame.removeChild(ScreenOrganizer._instance.theGame.getChildAt(ScreenOrganizer._instance.theGame.getNumChildren() - 1));
				}
				ScreenOrganizer._instance.theGame.addChildAt(ScreenOrganizer._instance.coverShape, 0);
				
				ScreenOrganizer._instance.myEvents.dispatchEvent(ScreenOrganizer._instance.screenChanging);
				return;
			} 
		
		}
		//window.console.log("k raf");
		ScreenOrganizer._instance._aid = window.requestAnimationFrame(ScreenOrganizer._instance.showCoverAndKill);
    };
    /** 
	*   
	*    
	*    
	* @memberof ScreenOrganizer.prototype 
	* @method uncoverDone
	* @param e 
    * 
	*/
    ScreenOrganizer.prototype.uncoverDone = function(e) {
        this.myEvents.removeEventListener(tabageos.ScreenChangeEvent.SCREEN_CHANGE, "uncoverDone", this);
        this.uncovered.screenChangeNumber = e.screenChangeNumber;
        this.transitioning = 0;
        this.dispatchEvent(this.uncovered);
        this.dispatchEvent(new tabageos.ScreenChangeEvent(e.screenChangeNumber,tabageos.ScreenChangeEvent.SCREEN_CHANGE));
    };
    tabageos.ScreenOrganizer = ScreenOrganizer;
})();


(function() { 
	'use strict';
    /** 
	*   
	*@classdesc
    *   A ScreenSkeleton is a CanvasObjectContainer representing a game screen that can be used with the ScreenOrganizer Class.
    *
	*    
	* @class ScreenSkeleton
	* @param screenOrg {ScreenOrganizer}
	* @param divID {String}
	* @param width {Number}
	* @param height {Number}
	* @param rootCanvasObjectContainer {CanvasObjectContainer} 
	* @param floorColorString  {String}
	*  
	*/
    function ScreenSkeleton(screenOrg, divID, width, height, rootCanvasObjectContainer, floorColorString) {
		tabageos.EventDispatcher.call(this);
		tabageos.CanvasObjectContainer.call(this, divID, width, height, rootCanvasObjectContainer, floorColorString);
        this._screenOrg = screenOrg || null;
        this.init(divID, width, height, rootCanvasObjectContainer, floorColorString);
    };
	/** 
	*   
	*    
	*    
	* @memberof ScreenSkeleton 
	*  
	*/
    ScreenSkeleton.prototype.constructor = ScreenSkeleton;
	ScreenSkeleton.prototype = Object.create(tabageos.EventDispatcher.prototype);
	Object.assign(ScreenSkeleton.prototype, tabageos.CanvasObjectContainer.prototype);
    /** 
	*   
	*    
	*    
	* @memberof ScreenSkeleton 
	*  
	*/
    ScreenSkeleton.prototype._buttons = {};
    /** 
	*   
	*    
	*    
	* @memberof ScreenSkeleton 
	*  
	*/
    ScreenSkeleton.prototype._screenOrg = null;
    /** 
	*   
	*    
	*    
	* @memberof ScreenSkeleton 
	*  
	*/
    ScreenSkeleton.prototype._index = null;
    /** 
	*   
	*    
	*    
	* @memberof ScreenSkeleton 
	*  
	*/
    ScreenSkeleton.prototype._currentArea = "";
    /** 
	*   
	*    Establish an area of the ScreenSkeleton as clickable
    *    This method is using the MouseController Class to grab global events and the _buttons Object to handle specifics.
    *    This method sets up the _buttons Object and global mouse events.
	*    
	* @memberof ScreenSkeleton.prototype 
	* @method establishClickArea
	* @param name {String} name of the click area
	* @param clickObject {Object} Object that has the click handler method
	* @param clickHandlerString {String} click handler method name
	* @param left {Number} left x position of click area
	* @param right {Number} right x position of click area
	* @param top {Number} top y position of click area
	* @param bottom {Number} bottom y position of click area
	* @param overHandler {Function} function for mouse over
	* @param outHandler {Function} function for mouse out
    * 
	*/
    ScreenSkeleton.prototype.establishClickArea = function(name, clickObject, clickHandlerString, left, right, top, bottom, overHandler, outHandler) {
        this._buttons[name] = [clickObject, clickHandlerString, left, right, top, bottom, overHandler, outHandler];
        tabageos.MouseController.removeEventListener("mouseUp", "handleClicks", this);
        tabageos.MouseController.removeEventListener("mouseMove", "mousePositionHandler", this);
        tabageos.MouseController.addEventListener("mouseUp", "handleClicks", this);
        tabageos.MouseController.addEventListener("mouseMove", "mousePositionHandler", this);
        this._index = this._screenOrg._screens.indexOf(this);
    };
	/** 
	*   
	*    Disable all click areas.
	*    
	* @memberof ScreenSkeleton.prototype 
	* @method disableClickAreas
    *  
	*/
    ScreenSkeleton.prototype.disableClickAreas = function() {
		tabageos.MouseController.removeEventListener("mouseUp", "handleClicks", this);
        tabageos.MouseController.removeEventListener("mouseMove", "mousePositionHandler", this);
	};
	/** 
	*   
	*    Enable all click areas.
	*    
	* @memberof ScreenSkeleton.prototype 
	* @method enableClickAreas
    * 
	*/
    ScreenSkeleton.prototype.enableClickAreas = function() {
		tabageos.MouseController.removeEventListener("mouseUp", "handleClicks", this);
        tabageos.MouseController.removeEventListener("mouseMove", "mousePositionHandler", this);
		tabageos.MouseController.addEventListener("mouseUp", "handleClicks", this);
        tabageos.MouseController.addEventListener("mouseMove", "mousePositionHandler", this);
	};
    /** 
	*   
	*    Remove this screen from the _screenOrg
	*    
	* @memberof ScreenSkeleton.prototype 
	* @method remove
	* @param e 
    * 
	*/
    ScreenSkeleton.prototype.remove = function(e) {
        this._screenOrg.removeEventListener(tabageos.ScreenChangeEvent.COVER, "remove", this);
        if (!e || e.screenChangeNumber != this._index) {
            this._screenOrg.theGame.removeChild(this);
        }
        tabageos.MouseController.removeEventListener("mouseUp", "handleClicks", this);
        tabageos.MouseController.removeEventListener("mouseMove", "mousePositionHandler", this);
    };
    /** 
	*   
	*    Handles clicks, setup with establishClickArea
	*    
	* @memberof ScreenSkeleton.prototype 
	* @method handleClicks
	* @param e 
    * 
	*/
    ScreenSkeleton.prototype.handleClicks = function(e) {
        var a;
        var s;
        var cs = this._screenOrg.currentScreen;
        for (s in this._buttons) {
            a = this._buttons[s];
            if (e.x > a[2] && e.x < a[3] && e.y > a[4] && e.y < a[5] && cs == this._index) {
                if (a[0] != null && a[0][a[1]])
                    a[0][a[1]]();
            }
        }
    };
    /** 
	*   
	*    Handles mouse over and mouse out, setup by establishClickArea
	*    
	* @memberof ScreenSkeleton.prototype 
	* @method mousePositionHandler
	* @param e 
    * 
	*/
    ScreenSkeleton.prototype.mousePositionHandler = function(e) {
        var show;
        var a;
        var s;
        for (s in this._buttons) {
            a = this._buttons[s];
            if (e.x > a[2] && e.x < a[3] && e.y > a[4] && e.y < a[5]) {
                show = true;
                this._currentArea = s;
                if (a[6] != null)
                    a[6]();
            } else {
                if (a[7] != null && this._currentArea == s) {
                    a[7]();
                    this._currentArea = "";
                }
                if (this._currentArea == s) {
                    this._currentArea = "";
                }
            }
        }
        if (show) {
            this.floor.canvas.setAttribute("style", "position:absolute;z-index:-1;cursor:pointer");
        } else {
            this.floor.canvas.setAttribute("style", "position:absolute;z-index:-1;cursor:auto");
        }
    };
    tabageos.ScreenSkeleton = ScreenSkeleton;
})();

(function() { 

	'use strict';
    /** 
	*   @classdesc
    *    A CanvasAnimation designated for isometric scenes.
	*    
	*    
	* @class SimpleIsoAnimation
	* @param source {Image}
	* @param canvasObject {CanvasObject}
	* @param fromRect {Rectangle}
	* @param x {Number}
	* @param y {Number}
	* @param width {Number}
	* @param height  {Number}
	*  
    * @see CanvasAnimation
    *
	*/
    function SimpleIsoAnimation(source, canvasObject, fromRect, x, y, width, height) {
				tabageos.CanvasAnimation.call(this,source, canvasObject, fromRect, x, y, width, height);
                if (source || canvasObject) {
                    this.init(source, canvasObject, fromRect, x, y, width, height);
                }
                this._currentValue = [];
    }
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoAnimation 
	*  
	*/
    SimpleIsoAnimation.prototype.constructor = SimpleIsoAnimation;
    SimpleIsoAnimation.prototype = Object.create(tabageos.CanvasAnimation.prototype);
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoAnimation 
	*  
	*/
    SimpleIsoAnimation.prototype._currentValue = [];
    /** 
	*   
	*    The map value of the current animation, with map values being [y,x] index arrays.
	*    
	* @memberof SimpleIsoAnimation.prototype 
	* @method getAnimationValue
    * @returns {Array} 
	*/
    SimpleIsoAnimation.prototype.getAnimationValue = function() {
              
                var yi = this.animationSpecs[this.currentAnimation][0];
                var xi = this.animationSpecs[this.currentAnimation][1][Math.floor(this.ani)];
                this._currentValue[0] = yi+1-1; this._currentValue[1] = xi+1-1;
                return this._currentValue;
                
            };
            
            tabageos.SimpleIsoAnimation = SimpleIsoAnimation;
})();

(function() { 

	'use strict';
    
    /** 
	*   
	*   @classdesc
    *   A MoverSkeleton designated for isometric movement.
    *
    *  
	*    
	* @class SimpleIsoBox
	* @param x {Number}
	* @param y {Number}
	* @param z {Number}
	* @param width {Number}
	* @param height {Number}
	* @param depth  {Number}  Default is same as height.
	*  
	*/
    function SimpleIsoBox(x,y,z,width,height,depth) {
				tabageos.MoverSkeleton.call(this,x,y,width,height);
                this.width = width || 0;
                this.height = height || 0;
                this._middlePoint = new tabageos.MoverPoint();
                this._pos = new tabageos.MoverPoint(x || 0,y || 0);
                this._veloc = new tabageos.MoverPoint(0,0);
                this._lastVeloc = new tabageos.MoverPoint(0,0);
                this._lastPos = new tabageos.MoverPoint(x || 0,y || 0);
                this.x = x || 0;
                this.y = y || 0;
                this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
                this.z = z || 0;
                this.dX = 0; this.dY = 0;this.face = 1;
                this.depth = depth || this.height+1-1;//0 would be a flat tile
                this._passCalcs = {x1:0,y1:0,x2:0,y2:0,x3:0,y3:0};
                this._ddX = 0;
                this._ddY = 0;
                this.moveLimits = [];
				this.directions = {
					1:"north",
					3:"south",
					2:"east",
					4:"west",
					6:"northeast",
					7:"southeast",
					5:"northwest",
					8:"southwest"
				};
    };
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoBox 
	*  
	*/
    SimpleIsoBox.prototype.constructor = SimpleIsoBox;
    SimpleIsoBox.prototype = Object.create(tabageos.MoverSkeleton.prototype);
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoBox 
	*  
	*/
    SimpleIsoBox.prototype.z = 0;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoBox 
	*  
	*/
    SimpleIsoBox.prototype.depth = 100;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoBox 
	*  
	*/
    SimpleIsoBox.prototype.face = 1;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoBox 
	*  
	*/
    SimpleIsoBox.prototype.moveLimits = [];    
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoBox 
	*  
	*/
    SimpleIsoBox.prototype.directions = {
                1:"north",
                3:"south",
                2:"east",
                4:"west",
                6:"northeast",
                7:"southeast",
                5:"northwest",
                8:"southwest"
    }; 
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoBox.prototype 
	* @method directionFacing
    * @returns {String} 
	*/
    SimpleIsoBox.prototype.directionFacing = function() {
                return this.directions[this.face];
    };   
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoBox.prototype 
	* @method getX
    * @returns {Number} 
	*/
    SimpleIsoBox.prototype.getX = function() {
                return this.x;
    };
    /** 
	*   
	*    Sets x position, and dX and face accordingly
	*    
	* @memberof SimpleIsoBox.prototype 
	* @method setX
	* @param toThis {Number}
    * 
	*/
    SimpleIsoBox.prototype.setX = function(toThis) {
                if (toThis > this.x) {
                    this.dX = 1;
                    
                    if (this.dY == 0) {
                        this.face = 2;//"east";
                    } else if (this.dY==1) {
                        this.face = 7;//"southeast";
                       // this.dX = this.dY=0.5;
                    } else {
                        this.face = 6;//"northeast";
                        //this.dX=0.5;
                        //this.dY=-0.5;
                    }
                }
                if (toThis < this.x) {
                    this.dX = -1;
                    
                    if (this.dY == 0) {
                        this.face = 4;//"west";
                    } else if (this.dY==1) {
                        this.face = 8;//"southwest";
                       // this.dY=0.5;
                        //this.dX=-0.5;
                    } else {
                        this.face = 5;//"northwest";
                       // this.dX = this.dY=-0.5;
                    }
                }
                if (toThis == this.x) {
                    this.dX = 0;
                    
                    if (this.dY == 0) {
                        //this.face="west";
                    } else if (this.dY==1) {
                        this.face = 3;//"south";
                    } else {
                        this.face = 1;//"north";
                    }
                }
                this.x = toThis+1-1;
                this._pos.x = toThis+1-1;
            };
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoBox.prototype 
	* @method getY
    * @returns {Number} 
	*/
    SimpleIsoBox.prototype.getY = function() {
                return this.y;
    };
    /** 
	*   
	*    Sets y position, and dY and face accordingly.
	*    
	* @memberof SimpleIsoBox.prototype 
	* @method setY
	* @param toThis {Number}
    * 
	*/
    SimpleIsoBox.prototype.setY = function(toThis) {
                if (toThis > this.y) {
                    this.dY = 1;
                    
                    if(this.dX == 0) {
                       this.face = 3;//south
                       
                    } else if (this.dX == 1) {
                        this.face =  7;//southeast
                        //this.dX = this.dY=0.5; 
                    } else {
                        this.face = 8;//"southwest";
                       // this.dY=0.5;
                       // this.dX=-0.5;
                    }
                }
                if (toThis < this.y) {
                    this.dY = -1;
                    
                    if(this.dX == 0) {
                       this.face = 1;//north
                       
                    } else if (this.dX == 1) {
                        this.face = 6;//"northeast";
                       // this.dX=0.5;
                       // this.dY=-0.5;
                    } else {
                        this.face = 5;//"northwest";
                      //  this.dX = this.dY=-0.5;
                    }
                }
                if (toThis == this.y) {
                    this.dY = 0;
                    
                    if(this.dX == 0) {
                        
                    } else if(this.dX == 1) {
                        this.face = 2;//"east";
                    } else {
                        this.face = 4;//"west";
                    }
                }
                this.y = toThis+1-1;
                this._pos.y = toThis+1-1;
            };
            
            
    /** 
	*   
	*    Future direction x
	*    
	* @memberof SimpleIsoBox 
	*  
	*/
    SimpleIsoBox.prototype._ddX = 0;//to store futures
    /** 
	*   
	*    Future direction y
	*    
	* @memberof SimpleIsoBox 
	*  
	*/
    SimpleIsoBox.prototype._ddY = 0;
            
    /**
    *
    *  Sets ._ddX and ._ddY
    *  
    *
    *       
	*   
	*    
	*    
	* @memberof SimpleIsoBox.prototype 
	* @method desiredDirection
	* @param left {Boolean}
	* @param right {Boolean}
	* @param up {Boolean}
	* @param down {Boolean}
	* @param [altCheck] {MoverSkeleton} you can pass in another MoverSkeleton to check,
    *    in that case ._ddX and ._ddY would denote its future direction.
    *    altCheck would be typically used with the .traveler of 
    *    SimpleIsoCharacters that extend SimpleIsoBox.
    * 
	*/
    SimpleIsoBox.prototype.desiredDirection = function(left,right,up,down, altCheck) {
                var xh = this.x +1-1;
                var yh = this.y +1-1;
                var dxh = this.dX+1-1;
                var dyh = this.dY+1-1;
                this.dX = 0; this.dY = 0;
                var actualCheck = altCheck || this;
                
                if(up) {
                    this.setY(actualCheck.y-actualCheck._veloc.y);
                }
                if(down) {
                    this.setY(actualCheck.y+actualCheck._veloc.y);
                }

                if(left) {
                    this.setX(actualCheck.x-actualCheck._veloc.x);
                }

                if(right) {
                    this.setX(actualCheck.x+actualCheck._veloc.x);
                }
                this._ddX = this.dX+1-1;
                this._ddY = this.dY+1-1;
                
                this.x = xh; this.y = yh;
                this._pos.x = xh; this._pos.y = yh;
                this.dX = dxh;this.dY=dyh;
            };
            
            
    /**
    *  Unlike MapMovers.move method, for this method we do pass in
    *  the directions we want to go instead of the directions we are going.
    *  So we can just pass in whether or not the left button is pressed, etc.
    *  
    *      
	*   
	*    
	*    
	* @memberof SimpleIsoBox.prototype 
	* @method move
	* @param left {Boolean}
	* @param right {Boolean}
	* @param up {Boolean}
	* @param down {Boolean}
	* @param map {Array}
	* @param tw {Number}
	* @param th {Number}
	* @param npv  {Array} an Array containing the values that the box should collide with.
    * @param offd  {Number} offsetDivision for the canPassOnMap call, see canPassOnMap
    * @param offm  {Number} offsetMinus for the canPassOnMap call, see canPassOnMap
    *
    * @returns {Boolean} Returns true when movement happened 
	*/
    SimpleIsoBox.prototype.move = function(left,right,up,down, map, tw, th, npv, offd, offm) {
                this.dX = 0; this.dY = 0;
                this.desiredDirection(left,right,up,down);//get future directions and face
                var toMove = 1;
                if(map) { //collision detect based on future directions and face
                    if(!this.canPassOnMap(map, tw||this.width,th||this.height, npv, offd, offm)) {
                        toMove = 0;
                    }
                }
                var xsee = this.x+1-1; var ysee = this.y+1-1;
                if(toMove) {
                    if(up) {
                       this.setY(this.y-this._veloc.y);
                    }
                    if(down) {
                       this.setY(this.y+this._veloc.y);
                    }

                    if(left) {
                        this.setX(this.x-this._veloc.x);
                    }

                    if(right) {
                       this.setX(this.x+this._veloc.x);
                    }
                }
                if(xsee == this.x && ysee == this.y) { toMove = 0; }
                
                return toMove;//scene should re-render when there is movement
            };
            
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoBox 
	*  
	*/
    SimpleIsoBox.prototype._passCalcs = {x1:0,y1:0,x2:0,y2:0,x3:0,y3:0};
            
            
            
    /**
    *  Used along with .setX and .setY or the .move function.
    *  If .x and .y are updated manually this method will not compute properly.
    *  .move encapsulates this method
    *  ._ddX denoting future x direction and ._ddY denoting future y direction
    *  are used by this method.
    *
    *  Manual use of this method would be;
    *  this.desiredDirection();
    *  if(this.canPassOnMap()) {   this.setX(); this.setY(); }
    *  
    *  The .move method encapsulates all those calls.
    *
    *  
	*   
	*    
	*    
	* @memberof SimpleIsoBox.prototype 
	* @method canPassOnMap
	* @param map {Array}
	* @param tw {Number}
	* @param th {Number}
	* @param noPassValues {Array} Array containing values the box should collide with
	* @param offsetDivision {Number} The number that tw and th are divided by to account for screen/iso offset
    *                        the default is 2, this number will cause the box to be closer or farther away from walls during collisions
    *                        this number has a lesser effect than offsetMinus and should be from 1 to tw.
    *  @param offsetMinus {Number} the total offset is subtracted by this number, use this to bring the box closer or farther away from collisions,
    *                     which means, when stopped, how close or far it is from the wall or object, default is 0,
    *                     a game that has all boxes and scenery the same size does not really need to mess with any of the offsets.
    *  Both offsetDivision and Minus can be set during .move calls as well.
    * .move fully encapsulates this method and all its params. 
    * @returns {Number} 0 or 1 
	*/
    SimpleIsoBox.prototype.canPassOnMap = function(map,tw,th,noPassValues,offsetDivision, offsetMinus) {
                var result=1;
                var tih = th||this.height;
                var tiw = tw||this.width;
                var vxOffset = Math.abs(this._veloc.x)-((tw/(offsetDivision||2))*-this._ddX) - (offsetMinus||0);
                var vyOffset = Math.abs(this._veloc.y)-((th/(offsetDivision||2))*-this._ddY) - (offsetMinus||0);
                var TLx=this.x  + vxOffset+ (this._veloc.x * this._ddX);
                var TLy=this.y  + vyOffset+ (this._veloc.y * this._ddY);
                var TRx=TLx+ (tiw);
                var TRy=TLy;
                var BRx=TRx;
                var BRy=TLy+ (tih);
                var BLx=TLx;
                var BLy=BRy;
                this._passCalcs.x3 = -99999; this._passCalcs.y3 = -99999;
                
                switch (this.face) {
                    case 1:
                        this._passCalcs.x1 = TLx;this._passCalcs.y1 = TLy;
                        this._passCalcs.x2 = TRx;this._passCalcs.y2 = TRy;
                    break;
                    case 3:
                        this._passCalcs.x1 = BLx;this._passCalcs.y1 = BLy;
                        this._passCalcs.x2 = BRx;this._passCalcs.y2 = BRy;
                    break;
                    case 2:
                        this._passCalcs.x1 = BRx;this._passCalcs.y1 = BRy;
                        this._passCalcs.x2 = TRx;this._passCalcs.y2 = TRy;
                    break;
                    case 4:
                        this._passCalcs.x1 = TLx;this._passCalcs.y1 = TLy;
                        this._passCalcs.x2 = BLx;this._passCalcs.y2 = BLy;
                    break;
                    case 6:
                        this._passCalcs.x1 = TRx;this._passCalcs.y1 = TRy;
                        this._passCalcs.x2 = BRx;this._passCalcs.y2 = BRy;
                        this._passCalcs.x3 = TLx;this._passCalcs.y3 = TLy;
                    break;
                    case 7:
                        this._passCalcs.x1 = TRx;this._passCalcs.y1 = TRy;
                        this._passCalcs.x2 = BRx;this._passCalcs.y2 = BRy;
                        this._passCalcs.x3 = BLx;this._passCalcs.y3 = BLy;
                    break;
                    case 5:
                        this._passCalcs.x1 = TRx;this._passCalcs.y1 = TRy;
                        this._passCalcs.x2 = BLx;this._passCalcs.y2 = BLy;
                        this._passCalcs.x3 = TLx;this._passCalcs.y3 = TLy;
                    break;
                    case 8:
                        this._passCalcs.x1 = TLx;this._passCalcs.y1 = TLy;
                        this._passCalcs.x2 = BRx;this._passCalcs.y2 = BRy;
                        this._passCalcs.x3 = BLx;this._passCalcs.y3 = BLy;
                    break;
                }
               
                var i = 0; var l = noPassValues.length; var v;var check;
                if(map[Math.floor(this._passCalcs.y1/tih)] 
                   && map[Math.floor(this._passCalcs.y1/tih)][Math.floor(this._passCalcs.x1/tiw)]) {
                    check = map[Math.floor(this._passCalcs.y1/tih)][Math.floor(this._passCalcs.x1/tiw)];
                     for(  i; i < l; i++ ) { v = noPassValues[i];
                        if((check == v) || (check && check[0] >= 0 && check[0] == v[0] && check[1] == v[1])  ) {
                            result = 0;
                        }
                    }
                } else { return 0; }
                if(map[Math.floor(this._passCalcs.y2/tih)] 
                   && map[Math.floor(this._passCalcs.y2/tih)][Math.floor(this._passCalcs.x2/tiw)]) {
                    check = map[Math.floor(this._passCalcs.y2/tih)][Math.floor(this._passCalcs.x2/tiw)]; i = 0; 
                     for(  i; i < l; i++ ) { v = noPassValues[i];
                        if((check == v) || (check && check[0] >= 0 && check[0] == v[0] && check[1] == v[1])  ) {
                            result = 0;
                        }
                    }
                } else { return 0; }
                if(this._passCalcs.x3 != -99999) {
                    if(map[Math.floor(this._passCalcs.y3/tih)] 
                       && map[Math.floor(this._passCalcs.y3/tih)][Math.floor(this._passCalcs.x3/tiw)]) {
                        check =  map[Math.floor(this._passCalcs.y3/tih)][Math.floor(this._passCalcs.x3/tiw)]; i = 0; 
                         for(  i; i < l; i++ ) { v = noPassValues[i];
                            if((check == v) || (check && check[0] >= 0 && check[0] == v[0] && check[1] == v[1])  ) {
                                result = 0;
                            }
                        }
                    } else { return 0; }
                } return result;
                
            };
            tabageos.SimpleIsoBox = SimpleIsoBox;
})();
            
(function() { 

	'use strict';
            
    /** 
	*   
	*  @classdesc
    *    A SimpleIsoBox designated to be the main character in a scene.
    *
    *    See the isometric example here: https://www.tabageos.com/examples/isometricExample
	*    
	* @class SimpleIsoCharacter
	* @param source {Image}
	* @param canvasObject {CanvasObject}
	* @param fromRect {Rectangle}
	* @param x {Number}
	* @param y {Number}
	* @param z {Number}
	* @param width {Number}
	* @param height {Number}
	* @param depth {Number}
	* @param scene {SimpleIsoScene}
	* @param aWidth {Number} animation width
	* @param aHeight  {Number} animation height
    *
    * @see SimpleIsoBox
	*  
	*/
    function SimpleIsoCharacter(source, canvasObject, fromRect, x,y,z,width,height,depth,scene,aWidth,aHeight) {
				tabageos.MoverSkeleton.call(this,x,y,width,height);
				tabageos.SimpleIsoBox.call(this,x,y,z,width,height,depth);
                this.width = width || 0;
                this.height = height || 0;
                this._middlePoint = new tabageos.MoverPoint();
                this._pos = new tabageos.MoverPoint(x,y);
                this._veloc = new tabageos.MoverPoint(0,0);
                this._lastVeloc = new tabageos.MoverPoint(0,0);
                this._lastPos = new tabageos.MoverPoint(x,y);
                this.x = x || 0;
                this.y = y || 0;
                this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
                this.z = z || 0;
                this.dX = 0; this.dY = 0;
                this.depth = depth || this.height+1-1;//0 would be a flat tile
                this._passCalcs = {x1:0,y1:0,x2:0,y2:0,x3:0,y3:0};
                this._ddX = 0;
                this._ddY = 0;
                this.moveLimits = [];
                this.scene = scene;
                this.animation = new tabageos.SimpleIsoAnimation(source, canvasObject, fromRect, x,y,aWidth||width,aHeight||height);
                this.traveler = new tabageos.Traveler(x,y,width,height);
               // this.traveler._veloc.x = -9999;
    };
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoCharacter 
	*  
	*/
    SimpleIsoCharacter.prototype.constructor = SimpleIsoCharacter;
    SimpleIsoCharacter.prototype = Object.create(tabageos.MoverSkeleton.prototype);
    Object.assign(SimpleIsoCharacter.prototype, tabageos.SimpleIsoBox.prototype);
    /** 
	*   
	*    
	*    @type SimpleIsoScene
	* @memberof SimpleIsoCharacter 
	*  
	*/
    SimpleIsoCharacter.prototype.scene;
    /** 
	*   
	*    
	*    @type SimpleIsoAnimation
	* @memberof SimpleIsoCharacter 
	*  
	*/
    SimpleIsoCharacter.prototype.animation;
    /** 
	*   
	*    
	*    @type Traveler
	* @memberof SimpleIsoCharacter 
	*  
	*/
    SimpleIsoCharacter.prototype.traveler;
    /** 
	*   
	*    changes animation.currentAnimation to directionFacing()
    *    and calls animate
	*    
	* @memberof SimpleIsoCharacter.prototype 
	* @method animateInScene
	* @param speed {Number} optional speed of animation
    * 
	*/
    SimpleIsoCharacter.prototype.animateInScene = function(speed) {
                //change animation to current way facing
                this.animation.currentAnimation = this.directionFacing();
                //animate updates the fromRect
                this.animation.animate(speed||1);
    };
    /** 
	*   
	*    Set the velocity to the same as its traveler, and potentially x and y.
	*    
	* @memberof SimpleIsoCharacter.prototype 
	* @method matchTraveler
	* @param all {Boolean} Match both x and y
	* @param sx {Boolean} Match just x 
	* @param sy {Boolean} Match just y
    * 
	*/
    SimpleIsoCharacter.prototype.matchTraveler = function(all,sx,sy) {
                this._veloc.x = this.traveler._veloc.x+1-1; this._veloc.y = this.traveler._veloc.y+1-1;
                if(all) {
                    this.setX(this.traveler.x+1-1);
                    this.setY(this.traveler.y+1-1);
                } else if(sx) {
                    this.setX(this.traveler.x+1-1);
                } else if(sy) {
                    this.setY(this.traveler.y+1-1);
                }
    };
    /** 
	*   
	*    Set the velocity of the traveler to this, and if all is true also x and y and _pos.
	*    
	* @memberof SimpleIsoCharacter.prototype 
	* @method travelerMatchThis
	* @param all {Boolean} if true will update x and y and _pos also.
    * 
	*/
    SimpleIsoCharacter.prototype.travelerMatchThis = function(all) {
                this.traveler._veloc.x = this._veloc.x+1-1; this.traveler._veloc.y = this._veloc.y+1-1;
                if(all) {
                    this.traveler.x = this.x+1-1;this.traveler.y=this.y+1-1;
                    this.traveler._pos.x = this._pos.x+1-1;this.traveler._pos.y = this._pos.y+1-1;
                }
    };
            
    tabageos.SimpleIsoCharacter = SimpleIsoCharacter;
    
})();


(function() { 

	'use strict';

    /** 
	*   
	*    
	*    
	* @class SimpleIsoPoint
    * @classdesc 
    *    A point with x y and z params. And methods for iso point conversion.
    *
	* @param x {Number}
	* @param y {Number}
	* @param z {Number}
	* @param spacing  {Number} Default is 45
	*  
	*/
    function SimpleIsoPoint(x,y,z, spacing) {
                
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.spacing = spacing || 45;
                
    }
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoPoint 
	*  
	*/
    SimpleIsoPoint.prototype.constructor = SimpleIsoPoint;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoPoint 
	*  
	*/
    SimpleIsoPoint.prototype.x = 0;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoPoint 
	*  
	*/
    SimpleIsoPoint.prototype.y = 0;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoPoint 
	*  
	*/
    SimpleIsoPoint.prototype.z = 0;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoPoint 
	*  
	*/
    SimpleIsoPoint.prototype.spacing = 45;
            
    /** 
	*   
	*    Converts a MoverPoint into a SimpleIsoPoint
    *
    *    
	* @memberof SimpleIsoPoint.prototype 
	* @method mpIntoIso
	* @param mp {MoverPoint} The MoverPoint to convert into the SimpleIsoPoint
	* @param isop {SimpleIsoPoint} The SimpleIsoPoint to use, if not given the instance will be used.
    * 
	*/
    SimpleIsoPoint.prototype.mpIntoIso = function(mp, isop) {
        if(!isop) {
            this.x = mp.x-mp.y;
            this.y = (mp.x+mp.y)/2;
        } else {
            isop.x = mp.x-mp.y;
            isop.y = (mp.x+mp.y)/2;
        }
    };
    /** 
	*   Convert the SimpleIsoPoint into a existing MoverPoint.
    *   If you don't pass another SimpleIsoPoint, this instance will be used.
	*    
	*    
	* @memberof SimpleIsoPoint.prototype 
	* @method isoIntoMp
	* @param mp {MoverPoint} The MoverPoint to convert the iso cords into.
	* @param isop {SimpleIsoPoint} The SimpleIsoPoint to convert into the MoverPoint, in not given the instance will be used.
    * 
	*/
    SimpleIsoPoint.prototype.isoIntoMp = function(mp, isop) {
        if(isop) {
            mp.x = (2*isop.y+isop.x)/2;
            mp.y = (2*isop.y-isop.x)/2;
        } else {
            mp.x = (2*this.y+this.x)/2;
            mp.y = (2*this.y-this.x)/2;
        }
    };
    /** 
	*   Returns either the x or y iso point with spacing, given a 2d point.
	*    
	*    
	* @memberof SimpleIsoPoint.prototype 
	* @method rawToIsoWithSpacing
	* @param x {Number}
	* @param y {Number}
    * @param returnX {Boolean}
    * @param returnY {Boolean}
    * @param spacing {Number}
    * @returns {Number} 
	*/
    SimpleIsoPoint.rawToIsoWithSpacing = function(x,y, returnX, returnY, spacing) {
        var xs = x/spacing; var ys = y/spacing;
        if(returnX) {
            return  (xs + (2*ys))/2;
        } else {
            return  (xs - (2*ys))/2;
        }
     };
    /** 
	*   
	*    Returns either the x or y screen point with spacing, given a 2d point and z index.
	*    
	* @memberof SimpleIsoPoint.prototype 
	* @method rawToScreenWithSpacing
	* @param x {Number}
	* @param y {Number}
    * @param z {Number}
    * @param returnX {Boolean}
    * @param returnY {Boolean}
    * @param spacing {Number}
    * @returns {Number} 
	*/
    SimpleIsoPoint.rawToScreenWithSpacing = function(x,y,z, returnX, returnY, spacing) {
        var rx = spacing * (x + y);
        var ry = (spacing/2) * (x - y);
        ry -= z*spacing*1.2;
        if(returnX) {
            return  rx;
        } else {
            return  ry;
        }
    };
    /** 
	*   
	*    Returns either the x or y screen point from a given 2d point.
    *
    *    Why only either x or y? To increase performance, in the cases where we only need the x or y, returning a whole Point Object would be wasteful.
    *     If we need both we just call the method twice, but only Numbers are ever returned.
	*    
	* @memberof SimpleIsoPoint.prototype 
	* @method rawToScreen
	* @param x {Number}
	* @param y {Number}
    * @param returnX {Boolean}
    * @param returnY {Boolean}
    * @returns {Number} 
	*/
    SimpleIsoPoint.rawToScreen = function(x,y,z, returnX,returnY) {
        if(returnX) {
             return  (2*y+x)/2;
        } else {
            return  (2*y-x)/2;
        }
    };
    /** 
	*   
	*    Returns either the x or y iso point from a given 2d point.
	*    
	* @memberof SimpleIsoPoint.prototype 
	* @method rawToIso
	* @param x {Number}
	* @param y {Number}
    * @param returnX {Boolean}
    * @param returnY {Boolean}
    * @returns {Number} 
	*/
    SimpleIsoPoint.rawToIso = function(x,y, returnX,returnY) {
        if(returnX) {
            return  x-y;
        } else {
            return  (x+y)/2;
        }
    };
            
    tabageos.SimpleIsoPoint = SimpleIsoPoint;
})();
            
            //
(function() { 

	'use strict';
            
            
    /** 
    *@class SimpleIsoScene
    * @classdesc
	*   Used to display a basic isometric scene.
	*    
	*    See the isometric exmaple here:  https://www.tabageos.com/examples/isometricExample
    *
    *     You just construct it and then call .render in a loop. The SimpleIsoCharacter Class move method returns true when it actually moves,
    *       so you only need to call render when any SimpleIsoCharacter actually moves or when the scene changes.
    *
    *      All of the propertiesd and methods are used during the .render method, it encapsulates everything to render the scene.
    *       But if you really want to tackle it, everything is also pieced out in different methods and properties.
	* 
	* @param tileWidth {Number} The width of each tile.
	* @param tileHeight {Number} The height of each tile.
	* @param floorCO {CanvasObject} The bottom most CanvsObject, the floor will be rendered on it.
	* @param canvasObject {CanvasObject} The CanvasObject that is displayed on top of floorCo, characters will be rendered on it
	* @param player {SimpleIsoCharacter} The SimpleIsoCharacter that will be moved around by the player.
	* @param map {Array} A 2D Array defining the tiles to be drawn, the inner values should be [y,x] arrays denoting the y and x index of where in the sprite sheet to draw from.
    *                       Set this map up as if your looking at standard top down 2d, the class converts to iso for you.
	* @param tileSheetImg {Image} The Image to use as the tile set, the tile set to draw from.
	* @param playerValue {Array} The [y,x] value of the first frame of the first animation defined for the player
	* @param noPassValue {Array} Array of [y,x,y,x,y,x...] pairs denoting [y,x] values in map that are not passable.
	* @param floorValues {Array} Array of [y,x,y,x,y,x...] pairs denoting [y,x] values in map that are the floor tiles.
	* @param xOffset {Number} optional amount to horizontally offset whole scene
	* @param yOffset {Number} optional amount to vertically offset whole scene
	* @param spread {Number} A number normally between .009 and 1, default is .009, play with it until your scene looks how you want.
	* @param xSpreadShifter {Number} A number that shifts the x position of each tile as a scene, default is 0.00. Sometimes this number may need to be .10 or such, it is another value to play with, also if your tiles are not exact values (like 32x16 instead of 32x32) then you may need to mess with this value. 
	* @param ySpreadShifter {Number} A number that shifts the y position of each tile as a scene, default is 0.00.  Sometimes this number may need to be .10 or such, it is another value to play with, also if your tiles are not exact values (like 32x16 instead of 32x32) then you may need to mess with this value.
	* @param camera {BasicCamera} A BasicCamera to use.
	*  
	*/
    function SimpleIsoScene(tileWidth, tileHeight, floorCO, canvasObject, player, map, tileSheetImg, playerValue, noPassValue, floorValues,  xOffset, yOffset, spread, xSpreadShifter,ySpreadShifter, camera) {
                
                this._helperPoint = new tabageos.SimpleIsoPoint(0,0,0);
                this._mp = new tabageos.MoverPoint();
                this._rect = new tabageos.Rectangle();
                this._rect2 = new tabageos.Rectangle();
                this._focusTile = new tabageos.SimpleIsoPoint();
                this._focusPoint = new tabageos.SimpleIsoPoint();
                this.sceneXOffset = xOffset || 100;
                this.sceneYOffset = yOffset || 100;
                this._twidth = tileWidth;
                this._theight = tileHeight;
                this._canvas = canvasObject;
                this._floor = floorCO || null;
                this._player = player;
                this._map = map;
                this._img = tileSheetImg;
                this._yIndex = 0;
                this.noPassValue = noPassValue || [1,3];
                this.floorValues = floorValues || [0,0];
                this._spread = spread || .009;
                if(this._spread >=2 ) {
                    window.console.warn("spread spreads out each tile, normally it should be 0 through .9, default is .009, smaller and negative values will bring tiles closer together, each decimal place moves things greatly");
                }
                this.playerTileValue = playerValue;
                this._secondDraws = [];
                this._overDraws = [];
                this._xSpreadShifter = xSpreadShifter || 0.00;
                this._ySpreadShifter = ySpreadShifter || 0.00;
                this.movingBoxes = [];
                this._cam = camera || null;
                this._effRect1 = new tabageos.Rectangle();
                this._effRect2 = new tabageos.Rectangle();
                this._blittOnce = 0;
    };
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype.constructor = SimpleIsoScene;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype.sceneYOffset = 500;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype.sceneXOffset = 250;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._helperPoint;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._rect;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._rect2;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._mp;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._focusTile;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._focusPoint;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._canvas;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._floor;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._player;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype.playerTileValue;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._map;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._spread = .009;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._img;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._twidth = 50;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._theight = 50;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._xSpreadShifter = 0;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._ySpreadShifter = 0.02;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._upperTileOffset = 1;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype.noPassValue = [1,3];
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype.floorValues = [0,0];
     /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype.movingBoxes = [];
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._cam;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._secondDraws = [];
    
    
    
    /**
    *
    *
    *
    *
    * @memberof SimpleIsoScene
    *
    */
    SimpleIsoScene.prototype._floorScreenCordsArray = [];
    
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._overDraws = [];
            
    /** 
	*   
	*    Updates _focusTile and _focusPoint
    *     
	*    
	* @memberof SimpleIsoScene.prototype 
	* @method updateTileCoordinates
	* @param x {Number} The x index of the focus tile
	* @param y {Number} The y index of the focus tile
	* @param tw {Number} The tile width
	* @param th {Number} The tile height
	* @param fp {MoverPoint} If passed then _focusPoint will be this point instead of from the focus tile.
    *  
	*/
    SimpleIsoScene.prototype.updateTileCoordinates = function(x,y, tw,th, fp) {
                
                this._focusTile.x=Math.round(x/tw);
                this._focusTile.y=Math.round(y/th);
                if(fp) { this._focusPoint.x = fp.x +1-1; this._focusPoint.y = fp.y +1-1;}
                else { this._focusPoint.x = this._focusTile.x *tw; this._focusPoint.y = this._focusTile.y *th; }
                
    };
            
    /**
    * Draws a tile from a tilesheet into the scene using BlitMath notation;
    *  [y,x] value denote the y and x index in the tilesheet to draw from.
    *  tw and th are the tile width and height, the y x index from value is multiplied by tw or th to get the position to draw from.
    *  tx and ty are the 2d point to draw to, pass in the 2d grid based point, this method translates to iso for you,
    *  ._spread, ._xSpreadShifter and ._ySpreadShifter can be used to make specific graphical adjustemnts,
    *  play with values from 0.9 to +/-0.000009 to get it looking exactly right for your graphics. (whole numbers are too much)
    *
    *  renderXOffset and renderYOffset offset the whole scene on the subject
    *
    *       
	*   This method is used inside of the specificPatternBlit method which is used inside of the render method.
	*    
	*    
	* @memberof SimpleIsoScene.prototype 
	* @method draw
	* @param subject {CanvasObject}
	* @param source {Image}
	* @param value {Array} This method is expecting [y,x] values.
	* @param tw {Number}
	* @param th {Number}
	* @param tx {Number}
	* @param ty {Number}
	* @param renderXOffset {Number} 
	* @param renderYOffset {Number}
	* @param renderSpread {Number}
    * 
	*/
    SimpleIsoScene.prototype.draw = function(subject, source, value, tw,th, tx,ty, renderXOffset, renderYOffset, renderSpread) {
                
                var spread = renderSpread || this._spread;
                var tileNum = value[1];
                var yIndex = value[0];
                var destY = ty;
                var destX =tx;
                var sourceX = tileNum * tw;
                var sourceY = yIndex * th;
                        
                this._rect.width = tw;
                this._rect.height = th;
                this._rect.x = sourceX;
                this._rect.y = sourceY;
                        
                var twdth = tw > th ? tw/th : th/tw;
                var thdtw = th > tw ? tw/th : th/tw;
                
                twdth += this._xSpreadShifter;
                thdtw += this._ySpreadShifter;
                        
                var offX = (twdth)/2  + spread;//spread separates each tile a bit
                var offY = (thdtw)/2  + spread;
                
                this._mp.x =  offX  * ((thdtw)/twdth) * tabageos.SimpleIsoPoint.rawToIso(destX,destY,1,0) + (renderXOffset||this.sceneXOffset);
                this._mp.y =  offY  * ((twdth)/thdtw) * tabageos.SimpleIsoPoint.rawToIso(destX,destY,0,1) + (renderYOffset||this.sceneYOffset);
                
                this._mp.x -= (tw - this._twidth);
                this._mp.y -= (th - this._theight);
                
                if(this._cam) {
                
                    this._effRect1.x = this._cam.v.x;
                    this._effRect1.y = this._cam.v.y;
                    this._effRect1.width = this._cam.viewPortWidth;
                    this._effRect1.height = this._cam.viewPortHeight;

                    this._effRect2.x = this._mp.x;
                    this._effRect2.y = this._mp.y;
                    this._effRect2.width = tw;
                    this._effRect2.height = th;
                    if(tabageos.GeometricMath.rectanglesOverlapAmount(this._effRect1, this._effRect2)/tw >= 1) {
                        subject.copyPixels(source, this._rect, this._mp, tw,th);
                    }
                    
                } else {
                    subject.copyPixels(source, this._rect, this._mp, tw,th);
                }
            };
            
    /** 
	*   
	*    Used inside of the render method. Updates destination Rectangles.  _rect and _rect2
	*    
	* @memberof SimpleIsoScene.prototype 
	* @method rectUpdate
	* @param destX {Number}
	* @param destY {Number}
	* @param tw {Number}
	* @param th {Number}
    * 
	*/
    SimpleIsoScene.prototype.rectUpdate = function(destX, destY, tw, th) {
                this._rect.x = this._focusPoint.x;
                this._rect.y = this._focusPoint.y;
                this._rect.width = (tw > th ? tw : th) + tw/2;
                this._rect.height = (th) + tw/2;
                this._rect2.x = destX;
                this._rect2.y = destY;
                this._rect2.width = (tw > th ? tw : th) + tw/2;
                this._rect2.height = (th) + tw/2;
    };
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._yIndex = 0;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._effRect1;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._effRect2;
    /** 
	*   
	*    
	*    
	* @memberof SimpleIsoScene 
	*  
	*/
    SimpleIsoScene.prototype._blittOnce = 0;
    
    /** 
	*   
	*    Returns the tile value in the patt. This is the same as BlitMath.checkTileValueAt 
    *    
	*    
	* @memberof SimpleIsoScene.prototype 
	* @method checkTileValueAt
	* @param x {Number}
	* @param y {Number}
	* @param patt {Array}
	* @param tileWidth {Number} 
	* @param tileHeight {Number}
	* @param indexHolderPoint {MoverPoint}
    * @returns {Object} 
	*/
    SimpleIsoScene.prototype.checkTileValueAt = function(x,y,patt,tileWidth,tileHeight,indexHolderPoint) {
                
                return tabageos.BlitMath.checkTileValueAt(x,y,patt,tileWidth,tileHeight,indexHolderPoint);
                
    };
    
    /**
    *
    * Using a 2D Array of [y,x] based index values, draws an iso scene using a tilesheet.
    * 
    *
    *   It's actually not simple... you can use this method along with the others, or you can just call render().
	*   
	*    This is called specificPatternBlit because it expects the specific [y,x] style of inner values in the pattern.
	*    
	* @memberof SimpleIsoScene.prototype 
	* @method specificPatternBlit
	* @param subject {CanvasObject} CanvasObject to draw to.
	* @param source {Image} Source Image to draw from
	* @param pattern {Array} Must be a 2D Array of [y,x] values, denoting the y and x index (not exact location) of each tile.
	* @param tw {Number} Tile width
	* @param th {Number} Tile height
	* @param renderXOffset {Number} It's better to use the _xSpreadShifter _ySpreadShifter and  sceneXOffset sceneYOffset properties during construction, and then just call render.
	* @param renderYOffset {Number} When these values are not set, _xSpreadShifter _ySpreadShifter sceneXOffset sceneYOffset properties of this Class are what is being used in this method.
	* @param renderSpread {Number}
    * 
	*/
    SimpleIsoScene.prototype.specificPatternBlit = function(subject, source, pattern, tw, th, renderXOffset, renderYOffset, renderSpread) {
                
                var i = 0; var j = 0; var l = pattern.length; var jl = pattern[0].length;
                var spread = renderSpread || this._spread;
                var rowPatt; var tileNum; var yIndex; var destY; var destX; var sourceY; var sourceX;
                var olad; var ola;var oi = 0;var twdth;var thdtw;var offX;var offY;var isFloorTile;
                this._overDraws.length = 0;var ei; var el;var en;
                this._secondDraws.length = 0;
                for(i; i < l; i++) { j = 0;
                    for(j; j < jl; j++) {
                        
                        rowPatt = pattern[i];
                        tileNum = rowPatt[j][1] >= 0 ? rowPatt[j][1] : rowPatt[j];
                        yIndex = rowPatt[j][0] >= 0 ? rowPatt[j][0] : this._yIndex;
                        
                        destY = i * (th);
                        destX = j * (tw);
                        
                        sourceX = tileNum * tw;
                        sourceY = yIndex * th;
                        
                        this._rect.width = tw;
                        this._rect.height = th;
                        this._rect.x = sourceX;
                        this._rect.y = sourceY;
                        
                        twdth = tw > th ? tw/th : th/tw;
                        thdtw = th > tw ? tw/th : th/tw;
                        
                        twdth += this._xSpreadShifter;
                        thdtw += this._ySpreadShifter;
                        
                        offX = (twdth)/2  + spread;//spread separates each tile a bit, a lower or negative spread brings the tiles together
                        offY = (thdtw)/2  + spread;//to adjust for your specific graphics play with ._xSpreadShifter/._ySpreadShifter and .spread before trying anything else 
                        
                        this._mp.x =  offX  * ((thdtw)/twdth) * tabageos.SimpleIsoPoint.rawToIso(destX,destY,1,0) + (renderXOffset||this.sceneXOffset);
                        this._mp.y =  offY  * ((twdth)/thdtw) * tabageos.SimpleIsoPoint.rawToIso(destX,destY,0,1) + (renderYOffset||this.sceneYOffset);
                        
                        isFloorTile = 0;//tileNum == flov2 && yIndex == flov1;
                        oi = 0;
                        for(oi;oi < this.floorValues.length; oi+=2) {
                            if (tileNum == this.floorValues[oi+1] && yIndex==this.floorValues[oi]) {
                                isFloorTile = 1; break;
                            }
                        }
                        
                        if(isFloorTile) { //draw floor tiles first
                            //only draw if in camera view area, great performance gain
                            if(this._blittOnce == 0 && this._floor) {
                                this._floor.copyPixels(source, this._rect, this._mp, tw,th);
                                
                            } else if (!this._floor) {
                                if(this._cam) {
                                    this._effRect1.x = this._cam.v.x;
                                    this._effRect1.y = this._cam.v.y;
                                    this._effRect1.width = this._cam.viewPortWidth;
                                    this._effRect1.height = this._cam.viewPortHeight;

                                    this._effRect2.x = this._mp.x;
                                    this._effRect2.y = this._mp.y;
                                    this._effRect2.width = tw;
                                    this._effRect2.height = th;
                                    if(tabageos.GeometricMath.rectanglesOverlapAmount(this._effRect1, this._effRect2)/tw >= 1) {
                                        subject.copyPixels(source, this._rect, this._mp, tw,th);
                                    }
                                } else {
                                    subject.copyPixels(source, this._rect, this._mp, tw,th);
                                }
                            }
                        } else { //hold to draw after this for loop finishes
                            this._secondDraws.push(i*th);
                            this._secondDraws.push(j*tw);
                            this._secondDraws.push(rowPatt[j]);
                        }
                        
                        if(isFloorTile && rowPatt[j][2]) { //an object on the floor
                            this.draw(subject,source,[rowPatt[j][2],rowPatt[j][3]],tw,th,destX,destY,this.sceneXOffset,this.sceneYOffset,spread);
                        }
                        
                       
                        this._rect.x = this._focusPoint.x;
                        this._rect.y = this._focusPoint.y;
                        this._rect.width = (tw > th ? tw : th) + tw/2;
                        this._rect.height = (th) + tw/2;
                        
                        this._rect2.x = destX;
                        this._rect2.y = destY;
                        this._rect2.width = (tw > th ? tw : th) + tw/2;
                        this._rect2.height = (th) + tw/2;
                        
                        olad = tw > th ? tw : th;
                        ola = tabageos.GeometricMath.rectanglesOverlapAmount(this._rect, this._rect2)/olad;
                        
                        //if a moving box or the player is above the tile,
                        //draw them above it
                        
                        //moving boxes witdh x < player.x + player.width/2
                        ei = 0; el = this.movingBoxes.length;
                            for (ei; ei < el; ei++) {
                                en = this.movingBoxes[ei];
                                if(en.x < this._player.x + this._player.width/2) {
                                    this.updateTileCoordinates(en.x,en.y,en.width,en.height,en);
                                    this.rectUpdate(destX,destY,tw,th);
                                    ola = tabageos.GeometricMath.rectanglesOverlapAmount(this._rect, this._rect2)/olad;
                                    if(  (this._focusTile.x == j && this._focusTile.y == i && isFloorTile) 
                                        || (ola >= 0.01 && isFloorTile) ) {
                                        this.draw(subject,source,en.animation.getAnimationValue(),en.animation.width,en.animation.height,this._focusPoint.x,this._focusPoint.y,this.sceneXOffset,this.sceneYOffset,spread);
                                    }
                                }
                            }
                        //end moving boxes under player
                        
                        //player
                        this.updateTileCoordinates(this._player.x,this._player.y,this._player.width,this._player.height,this._player);
                        this.rectUpdate(destX,destY,tw,th);
                        ola = tabageos.GeometricMath.rectanglesOverlapAmount(this._rect, this._rect2)/olad;
                        if(  (this._focusTile.x == j && this._focusTile.y == i && isFloorTile) 
                              || (ola >= 0.01 && isFloorTile) ) {
                            this.draw(subject,source,this._player.animation.getAnimationValue(),this._player.animation.width,this._player.animation.height,this._focusPoint.x,this._focusPoint.y,this.sceneXOffset,this.sceneYOffset,spread);
                        } else if(destX > this._focusPoint.x + tw -1  && !isFloorTile ) {
                             this._overDraws.push(i*th);
                             this._overDraws.push(j*tw);
                             this._overDraws.push(rowPatt[j]);
                        }
                        
                        //moving boxes with x > player.x + player.width/2
                        ei = 0;
                        for (ei; ei < el; ei++) {
                                en = this.movingBoxes[ei];
                                if(en.x > this._player.x + this._player.width/2) {
                                    this.updateTileCoordinates(en.x,en.y,en.width,en.height,en);
                                    this.rectUpdate(destX,destY,tw,th);
                                    ola = tabageos.GeometricMath.rectanglesOverlapAmount(this._rect, this._rect2)/olad;
                                    if(  (this._focusTile.x == j && this._focusTile.y == i && isFloorTile) 
                                        || (ola >= 0.01 && isFloorTile) ) {
                                        this.draw(subject,source,en.animation.getAnimationValue(),en.animation.width,en.animation.height,this._focusPoint.x,this._focusPoint.y,this.sceneXOffset,this.sceneYOffset,spread);
                                    }
                                }
                            }//end moving boxes over player
                    }   
                }
                var drwval;var drwx;var drwy;var vertCheck;
                
                i = 0; l = this._secondDraws.length;
                for(i; i < l; i+=3) {//non-floor tiles
                    
                    drwval = this._secondDraws[i+2];
                    drwx = this._secondDraws[i+1];
                    drwy = this._secondDraws[i];
                    
                    this.draw(subject,source,drwval,tw,th,drwx,drwy,this.sceneXOffset,this.sceneYOffset,spread);
                    
                    this.updateTileCoordinates(this._player.x,this._player.y,this._player.width,this._player.height,this._player);
                    
                    this._rect.x = this._focusPoint.x;
                    this._rect.y = this._focusPoint.y;
                    this._rect.width = (tw > th ? tw : th) + tw*4;
                    this._rect.height = (th) + tw*4;
                        
                    this._rect2.x = drwx;
                    this._rect2.y = drwy;
                    this._rect2.width = (tw > th ? tw : th) + tw*4;
                    this._rect2.height = (th) + tw*4;
                        
                    olad = tw*2;//tw > th ? tw : th;
                    ola = tabageos.GeometricMath.rectanglesOverlapAmount(this._rect, this._rect2)/olad;
                    
                    
                    //moving boxes under player; SimpleIsoBox > SimpleIsoCharacter
                    ei = 0;
                    for (ei; ei < el; ei++) {
                                en = this.movingBoxes[ei];
                                if(en.x < this._player.x + this._player.width/2) {
                                    this.updateTileCoordinates(en.x,en.y,en.width,en.height,en);
                                    this.rectUpdate(drwx,drwy,tw,th);
                                    ola = tabageos.GeometricMath.rectanglesOverlapAmount(this._rect, this._rect2)/olad;
                                    if(  (ola >= 0.01) && this._rect2.x < this._focusPoint.x + tw + 1 && this._focusPoint.y + th > this._rect2.y ) {
                                        this.draw(subject,source,en.animation.getAnimationValue(),en.animation.width,en.animation.height,this._focusPoint.x,this._focusPoint.y,this.sceneXOffset,this.sceneYOffset,spread);
                                    }
                                }
                            }
                        //end moving boxes under player
                        
                    
                    //player
                        this.updateTileCoordinates(this._player.x,this._player.y,this._player.width,this._player.height,this._player);
                        this.rectUpdate(drwx,drwy,tw,th);
                        ola = tabageos.GeometricMath.rectanglesOverlapAmount(this._rect, this._rect2)/olad;
                        if( (ola >= 0.01) && this._rect2.x < this._focusPoint.x + tw + 1 && this._focusPoint.y + th > this._rect2.y) {
                            
                            this.draw(subject,source,this._player.animation.getAnimationValue(),this._player.animation.width,this._player.animation.height,this._focusPoint.x,this._focusPoint.y,this.sceneXOffset,this.sceneYOffset,spread);
                            
                        }
                    //moving boxes over player
                        ei = 0;
                        for (ei; ei < el; ei++) {
                                en = this.movingBoxes[ei];
                                if(en.x > this._player.x + this._player.width/2) {
                                    this.updateTileCoordinates(en.x,en.y,en.width,en.height,en);
                                    this.rectUpdate(drwx,drwy,tw,th);
                                    ola = tabageos.GeometricMath.rectanglesOverlapAmount(this._rect, this._rect2)/olad;
                                    if( (ola >= 0.01) && this._rect2.x < this._focusPoint.x + tw + 1 && this._focusPoint.y + th > this._rect2.y ) {
                                        this.draw(subject,source,en.animation.getAnimationValue(),en.animation.width,en.animation.height,this._focusPoint.x,this._focusPoint.y,this.sceneXOffset,this.sceneYOffset,spread);
                                    }
                                    
                                }
                            }//end enemies over player
                    
                    
                        vertCheck = 2;//[0,0] a normal tile,  [0,0,0,0] a tile with another on top, 7 is max amount; [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
                        
                        while(drwval[vertCheck] >= 0 && vertCheck <= 15) {
                        
                            if(drwval[vertCheck] >= 0) { //next tile up above previous
                                tileNum = drwval[vertCheck+1] >= 0 ? drwval[vertCheck+1] : drwval;
                                yIndex = drwval[vertCheck] >= 0 ? drwval[vertCheck] : 0;
                                sourceX = tileNum * tw;
                                sourceY = yIndex * th;
                                this._rect.width = tw;
                                this._rect.height = th;
                                this._rect.x = sourceX;
                                this._rect.y = sourceY;
                                this._mp.x =  offX  * ((thdtw)/twdth) * tabageos.SimpleIsoPoint.rawToIso(drwx,drwy,1,0) + (renderXOffset||this.sceneXOffset);
                                this._mp.y =  offY  * ((twdth)/thdtw) * tabageos.SimpleIsoPoint.rawToIso(drwx,drwy,0,1) + (renderYOffset||this.sceneYOffset)  - ((th/this._upperTileOffset)*(vertCheck/2));
                                if(this._cam) {
                                    this._effRect1.x = this._cam.v.x;
                                    this._effRect1.y = this._cam.v.y;
                                    this._effRect1.width = this._cam.viewPortWidth;
                                    this._effRect1.height = this._cam.viewPortHeight;
                                    this._effRect2.x = this._mp.x;
                                    this._effRect2.y = this._mp.y;
                                    this._effRect2.width = tw;
                                    this._effRect2.height = th;
                                    if(tabageos.GeometricMath.rectanglesOverlapAmount(this._effRect1, this._effRect2)/tw >= 1) {
                                        subject.copyPixels(source, this._rect, this._mp, tw,th);
                                    }
                                } else {
                                    subject.copyPixels(source, this._rect, this._mp, tw,th);
                                }
                                vertCheck += 2; 
                            } else {
                                vertCheck += 2;
                                break;
                            }
                        }
                    
                    
                    //if any of the player or moving boxes are going to be taller
                    //or as tall as the top most placed tile
                    //the moving box and player section loops will need to run again here
                    //it is simply assumed that they are not
                    
                }
                
                i = 0; l = this._overDraws.length;
                for(i; i < l; i+=3) {
                    drwval = this._overDraws[i+2];
                    drwx = this._overDraws[i+1];
                    drwy = this._overDraws[i];
                    this.draw(subject,source,drwval,tw,th,drwx,drwy,this.sceneXOffset,this.sceneYOffset,spread);
                    
                    vertCheck = 2;//[0,0] a normal tile,  [0,0,0,0] a tile with another on top, 7 is max amount; [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
                        
                        while(drwval[vertCheck] >= 0 && vertCheck <= 15) {
                        
                            if(drwval[vertCheck] >= 0) { //next tile up above previous
                                tileNum = drwval[vertCheck+1] >= 0 ? drwval[vertCheck+1] : drwval;
                                yIndex = drwval[vertCheck] >= 0 ? drwval[vertCheck] : 0;
                                sourceX = tileNum * tw;
                                sourceY = yIndex * th;
                                this._rect.width = tw;
                                this._rect.height = th;
                                this._rect.x = sourceX;
                                this._rect.y = sourceY;
                                this._mp.x =  offX  * ((thdtw)/twdth) * tabageos.SimpleIsoPoint.rawToIso(drwx,drwy,1,0) + (renderXOffset||this.sceneXOffset);
                                this._mp.y =  offY  * ((twdth)/thdtw) * tabageos.SimpleIsoPoint.rawToIso(drwx,drwy,0,1) + (renderYOffset||this.sceneYOffset)  - ((th/this._upperTileOffset)*(vertCheck/2));
                                if(this._cam) {
                                    this._effRect1.x = this._cam.v.x;
                                    this._effRect1.y = this._cam.v.y;
                                    this._effRect1.width = this._cam.viewPortWidth;
                                    this._effRect1.height = this._cam.viewPortHeight;
                                    this._effRect2.x = this._mp.x;
                                    this._effRect2.y = this._mp.y;
                                    this._effRect2.width = tw;
                                    this._effRect2.height = th;
                                    if(tabageos.GeometricMath.rectanglesOverlapAmount(this._effRect1, this._effRect2)/tw >= 1) {
                                        subject.copyPixels(source, this._rect, this._mp, tw,th);
                                    }
                                } else {
                                    subject.copyPixels(source, this._rect, this._mp, tw,th);
                                }
                                vertCheck += 2; 
                            } else {
                                vertCheck += 2;
                                break;
                            }
                        }
                    
                    
                    ei = 0;
                        for (ei; ei < el; ei++) {
                                en = this.movingBoxes[ei];
                                if(en.x > this._player.x + this._player.width/2) {
                                    this.updateTileCoordinates(en.x,en.y,en.width,en.height,en);
                                    this.rectUpdate(drwx,drwy,tw,th);
                                    ola = tabageos.GeometricMath.rectanglesOverlapAmount(this._rect, this._rect2)/olad;
                                    if( (ola >= 0.01) && this._rect2.x < this._focusPoint.x + tw + 1 && this._focusPoint.y + th > this._rect2.y ) {
                                        this.draw(subject,source,en.animation.getAnimationValue(),en.animation.width,en.animation.height,this._focusPoint.x,this._focusPoint.y,this.sceneXOffset,this.sceneYOffset,spread);
                                    }
                                    
                                }
                            }
                }
                
                this._blittOnce = 1;
            };
            
    /**
    *
    * Encapsulates all calls to render the scene, just instantiate the class with desired settings, and call render during a loop.
	*   
	*   
	*    
	* @memberof SimpleIsoScene.prototype 
	* @method render
	* @param clearWidth {Number}
	* @param clearHeight {Number}
    * 
	*/
    SimpleIsoScene.prototype.render = function(clearWidth,clearHeight) {
                
                this.updateTileCoordinates(this._player.x,this._player.y,this._player.width,this._player.height, this._player);
                this._canvas.context.clearRect(0,0,clearWidth||1000,clearHeight||1000);
                this.specificPatternBlit(this._canvas,this._img,this._map,this._twidth,this._theight,this.sceneXOffset,this.sceneYOffset,this._spread);
    };
            
        tabageos.SimpleIsoScene = SimpleIsoScene;

})();


(function() { 

	'use strict';
    
    /** 
	*   Basic HTML5 Audio sound system 
	*    
	*    
	* @class SoundSystem
    * @classdesc
    *
    *    A basic HTML5 sound system for playing sounds and music.
    *    To play a sound first add it with addSound, giving it a name,
    *     then call playSound with the name you gave it.
    *
    *    To play and loop a music track use addMusic and playMusic.
    *
    *
    *
	* @param [musicIntervalSeconds=60]  {Number} Default is 60.
    *  
	*/
    function SoundSystem(musicIntervalSeconds) {
		SoundSystem._musicInterval = musicIntervalSeconds || 60;
		
    };
	/** 
	*   
	*    
	*    
	* 
	*  
	*/
    SoundSystem.prototype.constructor = SoundSystem;
	/** 
	*   
	*    
	*    
	* @memberof SoundSystem
	*  
	*/
    SoundSystem.prototype._soundPlaying = "";
    /** 
	*   
	*    
	*    
	* @memberof SoundSystem
	*  
	*/
    SoundSystem.prototype._sounds = [];
    /** 
	*   
	*    
	*    
	* @memberof SoundSystem
	*  
	*/
    SoundSystem.prototype._soundTracks = [];
    /** 
	*   
	*    
	*    
	* @memberof SoundSystem
	*  
	*/
    SoundSystem.prototype._soundIndex = 0;
    /** 
	*   
	*    
	*    
	* @memberof SoundSystem
	*  
	*/
    SoundSystem.prototype._soundNames = [];
    /** 
	*   
	*    
	*    
	* @memberof SoundSystem
	*  
	*/
    SoundSystem.prototype._currentTrack;
     /** 
	*   
	*    
	*    
	* @memberof SoundSystem
	*  
	*/
	SoundSystem._trackPaused = 0;
     /** 
	*   
	*    default is 60
	*    
	* @memberof SoundSystem
	*  
	*/
	SoundSystem._musicInterval = 60;
    /** 
	*   
	*    
	*    
	* @memberof SoundSystem 
	*  
	*/
    SoundSystem.prototype._trackTimer;
    /** 
	*   
	*    Add a sound to be played with playSound
	*    
	* @memberof SoundSystem.prototype 
	* @method addSound
	* @param soundLocation {String} The Location of the sound to add.
	* @param name {String} A name for the sound
	* @param vol {Number} The volume of the sound 0 to 1.
	* @param poolAmount {Number} Amount to pre load, alows for faster one shots, default is 1.
    * 
	*/
    SoundSystem.prototype.addSound = function(soundLocation, name, vol, poolAmount) {
        var innera = [];
        var i = 0;
        var l = poolAmount || 1;
        for (i; i < l; i++) {
            var s = new Audio(soundLocation);
            s.volume = vol;
            s.load();
            innera[innera.length] = s;
        }
        this._soundNames.push(name);
        this._sounds[this._sounds.length] = innera;
    };
	/** 
	*   
	*    Clear all sounds added with addSound
	*    
	* @memberof SoundSystem.prototype 
	* @method clearAllSounds
    * 
	*/
    SoundSystem.prototype.clearAllSounds = function() {
		this._sounds.length = 0;
		this._soundNames.length = 0;
		
	};
    /** 
	*   
	*    Add a music track to be played with playMusic.
    *      The first track you add would be at index 0 in _soundTracks, and additional calls are adding to _soundTracks.
	*    
	* @memberof SoundSystem.prototype 
	* @method addMusic
	* @param soundLocation {String} The url location of the music track.
	* @param vol {Number} The volume of the track, 0 to 1.
	* @param loop {Boolean} Default is true
    * 
	*/
    SoundSystem.prototype.addMusic = function(soundLocation, vol, loop) {
        var s = new Audio(soundLocation);
        s.volume = vol;
		s.loop = (loop === false || loop === 0 || loop === -1) ? false : true;
        s.load();
        this._soundTracks[this._soundTracks.length] = s;
    };
    /** 
	*   
	*    play a sound added with addSound
	*    
	* @memberof SoundSystem.prototype 
	* @method playSound
	* @param name {String} The name of the sound to play, as defined during addSound
	* @param usePool {Boolean} If true, and you set a poolAmount during addSound, it will cycle through the preloaded pool, 
    *                           otherwise the sound will need to have finished first, before replay.
    *                           If what you want is fast one shots of the same sound that potentially overlap, then use a pool of 2 or up to 10.
    * 
	*/
    SoundSystem.prototype.playSound = function(name, usePool) {
		if(this._soundPlaying != name) {
			this._soundIndex = 0;
			this._soundPlaying = name;
		}
        var a = this._sounds[this._soundNames.indexOf(name)];
        var ind = usePool ? this._soundIndex : 0;
        if (a[ind] && (a[ind].currentTime == 0 || a[ind].ended)) {
            a[ind].play();
            if (this._soundIndex < a.length - 1) {
                this._soundIndex += 1;
            } else {
                this._soundIndex = 0;
            }
        }
    };
    /** 
	*   
	*    play a music track added with addMusic
	*    
	* @memberof SoundSystem.prototype 
	* @method playMusic
	* @param [index=0] {Number} The index of the track to play, the first track added with addMusic is at index 0, the default is index 0.
	* 
	*/
    SoundSystem.prototype.playMusic = function(index, intervalSeconds) {
        index = index || 0;
		if(intervalSeconds) SoundSystem._musicInterval = intervalSeconds;
        var s = this._soundTracks[index];
        if (s && (s.currentTime == 0 || s.ended || s.paused)) {
            s.play();
            this._currentTrack = s;
        }
        if (this._currentTrack) {
			SoundSystem._trackPaused = 0;
        }
    };
	/** 
	*   Clears all music added with addMusic.
	*    
	*    
	* @memberof SoundSystem.prototype 
	* @method clearMusicTracks
    * 
	*/
    SoundSystem.prototype.clearMusicTracks = function() {
		this._soundTracks.length = 0;
	};
    /** 
	*   
	*    Stops the currrent music track from playing.
	*    
	* @memberof SoundSystem.prototype 
	* @method stopMusic
    * 
	*/
    SoundSystem.prototype.stopMusic = function() {
        this._currentTrack.pause();
		SoundSystem._trackPaused = 0;
    };
    
    tabageos.SoundSystem = SoundSystem;
    
})();

(function() { 

	'use strict';

    /** 
	*   @class TileData
	*    @classdesc
    *      Used by the BlitMath Class in some methods.
	*    
	* 
	* @param p {MoverPoint}
	* @param value  {Object}
	*  
	*/
    function TileData(p, value) {
        this.position = p || new tabageos.MoverPoint();
        this.value = value;
    };
    /** 
	*   
	*    
	*    
	* @memberof TileData 
	*  
	*/
    TileData.prototype.constructor = TileData;
    /** 
	*   
	*    
	*    @type MoverPoint
	* @memberof TileData 
	*  
	*/
    TileData.prototype.position;
    /** 
	*   
	*    @type Object
	*    
	* @memberof TileData 
	*  
	*/
    TileData.prototype.value;
    TileData._pool = [];
    /** 
	*   
	*    Constructs a new TileData with the values given.
	*    @static
    * @method make
	* @memberof TileData 
	*  
    * @param x {Number}
    * @param y {Number}
    * @param value {Object} The value the tile holds
    *
    * @returns {TileData}
	*/
    TileData.make = function(x, y, value) {
        if (tabageos.TileData._pool.length <= 0) {
            var i = 0;
            for (i; i < 50; i++) {
                tabageos.TileData._pool.push(new tabageos.TileData(new tabageos.MoverPoint(),null));
            }
        }
        var td = tabageos.TileData._pool.pop();
        td.position.x = Math.floor(x);
        td.position.y = Math.floor(y);
        td.value = value;
        return td;
    };
    /** 
	*   
	*    Clones this TileData instance.
	*    
	* @memberof TileData.prototype 
	* @method clone
    * @returns {TileData} 
	*/
    TileData.prototype.clone = function() {
        return new tabageos.TileData(this.position,this.value);
    };

    tabageos.TileData = TileData;
})();

(function() { 

	'use strict';

    /** 
	*   
	*    Constructs a new TileSceneChanger
	*    
	* @class TileSceneChanger
    * @classdesc
    *
    *   A TileSceneChanger has methods for storing and referencing scene arrays and enemy arrays and other arrays.
    *   Its changeScene method also blits from your spriteSheet using the scene map changed to.
    *   The GameSkeleton Class uses this Class, doing much of the setup for you, or you can use this Class yourself to switch between various arrays. 
    *
    *
	* @param spriteSheetSource 
	* @param canvasObject 
	* @param sceneWidth 
	* @param sceneHeight 
	* @param tw 
	* @param th 
	* @param mainChar  
	*  
	*/
    function TileSceneChanger(spriteSheetSource, canvasObject, sceneWidth, sceneHeight, tw,th, mainChar) {
		tabageos.EventDispatcher.call(this);
        this.mainChar = mainChar;
        this._source = spriteSheetSource;
        this.sW = sceneWidth;
        this.sH = sceneHeight;
        this.tW = tw;
        this.tH = th;
        this._display = canvasObject;
        this._cameraPoint = new tabageos.MoverPoint();
		this._totalScenes = [0];
    };
	/** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype.constructor = TileSceneChanger;
    TileSceneChanger.prototype = Object.create(tabageos.EventDispatcher.prototype);
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype.sW;
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype.sH;
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype.tW;
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype.tH;
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype.mainChar;
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype._source;
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype._display;
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype._cameraPoint;
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype.currentMap;
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype._mapNumber = 1;
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype.currentScene = 1;
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype._map1;
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype._map2;
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype._totalScenes = [0];
    /** 
	*   
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype._direcs = {
        "left": 0,
        "right": 1,
        "down": 2,
        "up": 3
    };
    /** 
	*   
	*    Used by addEnemyArray and getEnemyArray.
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype._enemyArrays = [0];
    /** 
	*   Adds a enemy Array
	*    
	*    
	* @memberof TileSceneChanger.prototype 
	* @method addEnemyArray
	* @param arr {Array}
	* @param scene {Number}
    * 
	*/
    TileSceneChanger.prototype.addEnemyArray = function(arr, scene) {
        var narr = [];
        var i = 0;
        for (i; i < arr.length; i++) {
            narr[i] = arr[i];
        }
        this._enemyArrays[scene || this.currentScene] = narr;
    };
    /** 
	*   References a enemy Array.
	*    
	*    
	* @memberof TileSceneChanger.prototype 
	* @method getEnemyArray
	* @param scene {Number}
    * @returns {Array} 
	*/
    TileSceneChanger.prototype.getEnemyArray = function(scene) {
        return this._enemyArrays[scene];
    };
    /** 
	*   Used by addStoredArray and getStoredArray.
	*    
	*    
	* @memberof TileSceneChanger 
	*  
	*/
    TileSceneChanger.prototype._otherArrays = [0];
    /** 
	*   
	*    Adds a stored array. Retreve stored Arrays with getStoredArray
	*    
	* @memberof TileSceneChanger.prototype 
	* @method addStoredArray
	* @param arr {Array} An Array to store.
	* @param scene {Number} Index to store to, default is currentScene.
    * 
	*/
    TileSceneChanger.prototype.addStoredArray = function(arr, scene) {
        var narr = [];
        var i = 0;
        for (i; i < arr.length; i++) {
            narr[i] = arr[i];
        }
		if (i == 0) { narr = [0]; narr.length = 0; }
        this._otherArrays[scene || this.currentScene] = narr;
    };
    /** 
	*   
	*    Returns a refence to a stored array stored with addStoredArray.
	*    
	* @memberof TileSceneChanger.prototype 
	* @method getStoredArray
	* @param scene {Number}
    * @returns {Array} 
	*/
    TileSceneChanger.prototype.getStoredArray = function(scene) {
		if(!scene || scene <= 0) { scene = 1; }
        return this._otherArrays[scene];
    };
    /**
	* These methods use BlitMath.cloneMultiArray to clone the array you pass to them.
	* The array passed remains a separate array,
	* the method does not create a reference to the array passed in.
	*  Thereby ._map1 and ._map2 are unique until defineMap1/2 is called again
	* ._map1 and ._map2 should never be set directly. 
	*    
	*    
	* @memberof TileSceneChanger.prototype 
	* @method defineMap1
	* @param map2DArray {Array}
    * 
	*/
    TileSceneChanger.prototype.defineMap1 = function(map2DArray) {
        this._map1 = tabageos.BlitMath.cloneMultiArray(map2DArray);
    };
    /** 
	*   
	*    Defines _map2 see defineMap1.
	*    
	* @memberof TileSceneChanger.prototype 
	* @method defineMap2
    * @see defineMap1
	* @param map2DArray {Array}
    * 
	*/
    TileSceneChanger.prototype.defineMap2 = function(map2DArray) {
        this._map2 = tabageos.BlitMath.cloneMultiArray(map2DArray);
    };
    /**
	* These methods populate the ._totalScenes array with clones of the arrays you pass in.
	* the ._totalScenes array should not be handled directly.
	* Use referenceScene() if you need to reference scenes you add, 
	*  the reference index will be in the order you place them starting from 1.    
	*    
	* @memberof TileSceneChanger.prototype 
	* @method addScene
	* @param map2DArray 
    * @returns {} 
	*/
    TileSceneChanger.prototype.addScene = function(map2DArray) {
        this._totalScenes.push(tabageos.BlitMath.cloneMultiArray(map2DArray));
    };
    /** 
	*   
	*    Adds up to 5 scenes to _totalScenes
	*    
	* @memberof TileSceneChanger.prototype 
	* @method add5Scenes
	* @param map2DArray 
	* @param map2DArray2 
	* @param map2DArray3 
	* @param map2DArray4 
	* @param map2DArray5 
    * @returns {} 
	*/
    TileSceneChanger.prototype.add5Scenes = function(map2DArray, map2DArray2, map2DArray3, map2DArray4, map2DArray5) {
        this._totalScenes.push(tabageos.BlitMath.cloneMultiArray(map2DArray));
        this._totalScenes.push(tabageos.BlitMath.cloneMultiArray(map2DArray2));
        this._totalScenes.push(tabageos.BlitMath.cloneMultiArray(map2DArray3));
        this._totalScenes.push(tabageos.BlitMath.cloneMultiArray(map2DArray4));
        this._totalScenes.push(tabageos.BlitMath.cloneMultiArray(map2DArray5));
    };
    /** 
	*   
	*    Returns a reference to the scenes map.
	*    
	* @memberof TileSceneChanger.prototype 
	* @method referenceScene
	* @param referenceIndex 
    * @returns {} 
	*/
    TileSceneChanger.prototype.referenceScene = function(referenceIndex) {
        return this._totalScenes[referenceIndex] || null;
    };
	/** 
	*   
	*    clears _totalScenes, _otherArrays and _enemyArrays
	*    
	* @memberof TileSceneChanger.prototype 
	* @method clearAllArrays
    * @returns {} 
	*/
    TileSceneChanger.prototype.clearAllArrays = function() {
        this._totalScenes.length = 0;
		this._otherArrays.length = 0;
		this._enemyArrays.length = 0;
    };
    /** 
	*   
	*    Changes the currentMap. If _map1 or _map2 is defined they will be used, otherwise the map is _totalScenes[mapInteger]
	*    
	* @memberof TileSceneChanger.prototype 
	* @method changeCurrentMap
	* @param mapInteger {Number} The map to change to.
    * @returns {} 
	*/
    TileSceneChanger.prototype.changeCurrentMap = function(mapInteger) {
        if (mapInteger == 1 && this._map1) {
            this.currentMap = this._map1;
            this._mapNumber = 1;
        } else {
            this.currentMap = this._map2 || this._totalScenes[mapInteger];
            this._mapNumber = mapInteger;
        }
    };
	
	/** 
	*   
	*    Changes the current enemy Array being referrenced.
	*    
	* @memberof TileSceneChanger.prototype 
	* @method changeSceneEnemies
	* @param scene 
    * @returns {} 
	*/
    TileSceneChanger.prototype.changeSceneEnemies = function(scene) {
           
			var storedEnemies = this.getEnemyArray(scene);
			var enemyArray;
			
			if(storedEnemies) {
				enemyArray = storedEnemies;
			} else {
				this.addEnemyArray([], scene);
				storedEnemies = this.getEnemyArray(scene);
				enemyArray = storedEnemies;
			}
			
			
			return enemyArray;
	};
	/** 
	*   
	*    Changes the current scenery Array being referenced.
	*    
	* @memberof TileSceneChanger.prototype 
	* @method changeSceneryObjects
	* @param scene 
    * @returns {} 
	*/
    TileSceneChanger.prototype.changeSceneryObjects = function(scene) {
		var storedScenery = this.getStoredArray(scene);
            var sceneryArray;
			
			if(storedScenery) {
				sceneryArray = storedScenery;
				
			} else {
				this.addStoredArray([], scene);
				storedScenery = this.getStoredArray(scene);
				sceneryArray = storedScenery;
			}
		
		return sceneryArray;
	};
	/** 
	*   
	*    allow objects to be thrown into the next/previous scene
	*    
	* @memberof TileSceneChanger.prototype 
	* @method sceneryObjectSceneChange
	* @param sceneryObject {SceneryObject}
	* @param sceneryArray {Array}
	* @param limitLeft {Number}
	* @param limitRight {Number}
	* @param limitUp {Number}
	* @param limitDown {Number}
    * @returns {Number} Returns 1 if the object changed scene.
	*/
    TileSceneChanger.prototype.sceneryObjectSceneChange = function(sceneryObject, sceneryArray, limitLeft, limitRight, limitUp, limitDown) {
		//
		var obj = sceneryObject;
		var oa;
		var result = 0;
		if(limitLeft && obj.x <=limitLeft) { 
			if(this._totalScenes[this.currentScene-1]) {
				oa = this.getStoredArray(this.currentScene-1);
				if(oa) {
					oa.push(obj);
				} else {
					this.addStoredArray([], this.currentScene-1);
					oa = this.getStoredArray(this.currentScene-1);
					oa.push(obj);
				}
				sceneryArray.splice(sceneryArray.indexOf(obj),1);
			} else {
				if(this._totalScenes[this._totalScenes.length-1]) {
					oa = this.getStoredArray(this._totalScenes.length-1);
					if(oa) {
						oa.push(obj);
					} else {
						this.addStoredArray([], this._totalScenes.length-1);
						oa = this.getStoredArray(this._totalScenes.length-1);
						oa.push(obj);
					}
					sceneryArray.splice(sceneryArray.indexOf(obj),1);
				}
			}
			obj.setX(limitRight - 5);result = 1;
		}
		
		if(limitRight && obj.x >=limitRight) {
			if(this._totalScenes[this.currentScene+1]) {
				oa = this.getStoredArray(this.currentScene+1);
				if(oa) {
					oa.push(obj);
				} else {
					this.addStoredArray([], this.currentScene+1);
					oa = this.getStoredArray(this.currentScene+1);
					oa.push(obj);
				}
				sceneryArray.splice(sceneryArray.indexOf(obj),1);
			} else {
				if(this._totalScenes[1]) {
					oa = this.getStoredArray(1);
					if(oa) {
						oa.push(obj);
					} else {
						this.addStoredArray([], 1);
						oa = this.getStoredArray(1);
						oa.push(obj);
					}
					sceneryArray.splice(sceneryArray.indexOf(obj),1);
				}
			}
			obj.setX(limitLeft + 4); result = 1;
		} 
		
		
		if(limitUp && obj.y <=limitUp) { 
			if(this._totalScenes[this.currentScene-1]) {
				oa = this.getStoredArray(this.currentScene-1);
				if(oa) {
					oa.push(obj);
				} else {
					this.addStoredArray([], this.currentScene-1);
					oa = this.getStoredArray(this.currentScene-1);
					oa.push(obj);
				}
				sceneryArray.splice(sceneryArray.indexOf(obj),1);
			} else {
				if(this._totalScenes[this._totalScenes.length-1]) {
					oa = this.getStoredArray(this._totalScenes.length-1);
					if(oa) {
						oa.push(obj);
					} else {
						this.addStoredArray([], this._totalScenes.length-1);
						oa = this.getStoredArray(this._totalScenes.length-1);
						oa.push(obj);
					}
					sceneryArray.splice(sceneryArray.indexOf(obj),1);
				}
			}
			obj.setY(limitDown - 5);result = 1;
		}
		
		if(limitDown && obj.y >=limitDown) {
			if(this._totalScenes[this.currentScene+1]) {
				oa = this.getStoredArray(this.currentScene+1);
				if(oa) {
					oa.push(obj);
				} else {
					this.addStoredArray([], this.currentScene+1);
					oa = this.getStoredArray(this.currentScene+1);
					oa.push(obj);
				}
				sceneryArray.splice(sceneryArray.indexOf(obj),1);
			} else {
				if(this._totalScenes[1]) {
					oa = this.getStoredArray(1);
					if(oa) {
						oa.push(obj);
					} else {
						this.addStoredArray([], 1);
						oa = this.getStoredArray(1);
						oa.push(obj);
					}
					sceneryArray.splice(sceneryArray.indexOf(obj),1);
				}
			}
			obj.setY(limitUp + 4); result = 1;
		} 
		
		return result;
		
	};
	
    /**
	*
	* This method changes which map is being used and then blits it onto the canvasObject passed during construction of the Class.
	* It also sets the mainChars ._map and any associated MapMovers/Travelers or SceneryObjects ._map property.
	* And it will reset the camera as needed.
    *
	* @memberof TileSceneChanger.prototype 
	* @method changeScene
	* @param mapInteger the map to change to. 0 to change by added scenes and direction, 1 to change to the ._map1 of this class, 2 to change to ._map2 of this class.
	* @param direction the direction the player is going; "left" "right" "down" "up" or 0 1 2 3
	* 
	* @param camera {BasicCamera} a reference to the BasicCamera that is being used
	* @param faMethod {String} a String of the method name to call during BlitMath.dispatchFunctionAssignments.
	* @param faMethodObject {Object} the Object that contains the faMethod, normally the .game static Object for example from stage nine of the platformer tutorial.
	* @param directScene {Number}
	* @param dontResetCameraX {Boolean}
	* @param dontResetCameraY {Boolean}
	* @param dontUpdateEnemyMaps {Boolean}
	* @param frameTime {Number}
	* @param ts {Number}
	* @param tweenType {String}
    * @returns {} 
	*/
    TileSceneChanger.prototype.changeScene = function(mapInteger, direction, camera, faMethod, faMethodObject, directScene, dontResetCameraX, dontResetCameraY, dontUpdateEnemyMaps) {

        var direc = (typeof direction == "number" ? direction : (this._direcs[direction] || 1));
		
        if (!directScene) {

            if (mapInteger == 0) {
                //change by horizontal scenes
                if (direc == 0) {
                    
                    this.currentScene -= 1;
                    if (this._totalScenes[this.currentScene]) {
                        this.currentMap = this._totalScenes[this.currentScene];
                    } else {
                        this.currentScene = this._totalScenes.length - 1;
                        this.currentMap = this._totalScenes[this.currentScene] || this._map2;
                    }
					
					this.mainChar.setX(this.sW - (this.mainChar.width * 2));
					
                }
                if (direc == 1) {
                    
                    this.currentScene += 1;
                    if (this._totalScenes[this.currentScene]) {
                        this.currentMap = this._totalScenes[this.currentScene];
                    } else {
                        this.currentScene = 1;
                        this.currentMap = this._totalScenes[this.currentScene] || this._map1;
                    }
					
					this.mainChar.setX((this.mainChar.width * 2));
					
                }
				
				
				if (direc == 2) {
                    
					this.currentScene += 1;
                    if (this._totalScenes[this.currentScene]) {
                        this.currentMap = this._totalScenes[this.currentScene];
                    } else {
                        this.currentScene = 1;
                        this.currentMap = this._totalScenes[this.currentScene] || this._map1;
                    }
					
					this.mainChar.setY(2);
                    
                }
                if (direc == 3) {
                    
                    this.currentScene -= 1;
                    if (this._totalScenes[this.currentScene]) {
                        this.currentMap = this._totalScenes[this.currentScene];
                    } else {
                        this.currentScene = this._totalScenes.length - 1;
                        this.currentMap = this._totalScenes[this.currentScene] || this._map2;
                    }
					
					this.mainChar.setY(this.sH - (this.mainChar.width+1));
                }
            }

            if (mapInteger == 1 || mapInteger == 2) {
                //change between just the two ._maps 
                this.changeCurrentMap(mapInteger);
            }

            this.mainChar._map = tabageos.BlitMath.cloneMultiArray(this.currentMap);
          
            
			
        } else {

            if (this._totalScenes[directScene]) {
                this.currentScene = directScene;
                this.currentMap = this._totalScenes[this.currentScene];
                this.mainChar._map = tabageos.BlitMath.cloneMultiArray(this.currentMap);

            }

        }
		
		var i = 0;var en;var ena = this.getEnemyArray(this.currentScene);
		if(ena && !dontUpdateEnemyMaps) {
            for(i;i<ena.length;i++) {
				en = ena[i];
				en._map = this.mainChar._map;
            }
			
			i = 0;
			ena = this.getStoredArray(this.currentScene);
			if(ena) {
				for(i; i < ena.length; i++) {
					en = ena[i];
					en._map = this.mainChar._map;
					
				}
			}
			
		}
		 //clear the whole scene
        this._display.context.clearRect(0, 0, this.sW, this.sH);
       

        if (faMethod) {
            //if there is a faMethod call dispatchFunctionAssignments with it, .functionAssignments should already be set
            tabageos.BlitMath.dispatchFunctionAssignments(this, faMethod, faMethodObject, this.currentMap, this.tW, this.tH);
        }
        //redraw the whole scene
        if(this._source) {
			tabageos.BlitMath.specificPatternBlit(this._display, this._source, this.currentMap, this.tW, this.tH);
		} else {
			
			tabageos.BlitMath.drawSquaresFromPattern(this._display,this.currentMap,this.tW,this.tH,camera ? camera.colorValues : {});
		}
	   if (!directScene) { 
           if(camera) { 
				this._cameraPoint.x = Math.round(this.mainChar.x) -  (direc != 0 ? camera.cameraFollowOffsetX : -this.tW*2);
				this._cameraPoint.y = Math.round(this.mainChar.y) -  ((direc == 3 ) ? -this.tH*2 : camera.cameraFollowOffsetY);
			
				camera.reset(dontResetCameraX ? camera.v.x : (direc == 1 ? 0 : camera.v.width),dontResetCameraY ? camera.v.y : (direc == 2 ? 0 : camera.v.height));
				camera.tweenedBlitLayerRender(this._cameraPoint, 0,0, (frameTime && ts) ? Math.round(frameTime/ts) : 16,tweenType || "Linear",0,0);
			}
        }

    };

    tabageos.TileSceneChanger = TileSceneChanger;

})();
//this.tabageos = this.tabageos || {};

(function() { 
	'use strict';
    /**
    *
    * @class TimeKeeper
    * @classdesc
    *   A class of static methods that could be used to keep and get frame time
    *  TimeKeeper._sae is used as the deltaTime value in classes such as MapTraveler.
    *
    *
    */
    function TimeKeeper() {}
    TimeKeeper.started = false;
    TimeKeeper.time = 0;
    TimeKeeper.timeElapsed = 1;
    TimeKeeper.newTime = 0;
    TimeKeeper.slowness = 60;
	TimeKeeper._aid = 0;
	TimeKeeper._oaid = 0;
    /**
    *
    *  By default .666666666667, all Travelers are using this static value for delta frame time. 
    *
    * @memberof TimeKeeper
    *
    */
	TimeKeeper._sae = .666666666667;
    /**
    *
    *  sets TimeKeeper.time to now()
    *  and updates timeElapsed
    *
    * @memberof TimeKeeper
    * @method keepTime
    */
    TimeKeeper.keepTime = function() {
        if (tabageos.TimeKeeper.started == false) {
            tabageos.TimeKeeper.started = true;
            tabageos.TimeKeeper.time = TimeKeeper.now();
        }
        tabageos.TimeKeeper.newTime = TimeKeeper.now();
        tabageos.TimeKeeper.timeElapsed = tabageos.TimeKeeper.newTime - tabageos.TimeKeeper.time;
        tabageos.TimeKeeper.time = tabageos.TimeKeeper.newTime;
    };
    TimeKeeper._keepTime = function(tme) {
        tabageos.TimeKeeper.newTime = tme;
        tabageos.TimeKeeper.timeElapsed = tabageos.TimeKeeper.newTime - tabageos.TimeKeeper.time;
        tabageos.TimeKeeper.time = tabageos.TimeKeeper.newTime;
    };
    TimeKeeper.status = function(stat) {
        if (stat == false) {
            tabageos.TimeKeeper.timeElapsed = 1;
            tabageos.TimeKeeper.started = false;
        } else {
            tabageos.TimeKeeper.time = TimeKeeper.now();
            tabageos.TimeKeeper.started = true;
        }
    };
    TimeKeeper.reset = function(ts) {
        tabageos.TimeKeeper.status(false);
        tabageos.TimeKeeper.status(true);
        window.requestAnimationFrame(function(tstmp) {
            tabageos.TimeKeeper.time = tstmp;
        });
    };
    
    TimeKeeper.init = function() {
        TimeKeeper._sae = -99;
        TimeKeeper._aid = window.requestAnimationFrame(function(tstmp) {
            tabageos.TimeKeeper.time = tstmp;
			window.cancelAnimationFrame(TimeKeeper._aid);
            TimeKeeper._oaid = window.requestAnimationFrame(function(tstmp) {
                TimeKeeper._keepTime(tstmp);
                TimeKeeper.speedAdjustedElapsed();
            })
        });
    };
    TimeKeeper.speedAdjustedElapsed = function() {
        if (TimeKeeper._sae == -99) {
			window.cancelAnimationFrame(TimeKeeper._oaid);
			var lto = 1;
			if(TimeKeeper.timeElapsed > 1000/TimeKeeper.slowness) {	
				lto = TimeKeeper.timeElapsed / (1000/TimeKeeper.slowness);
			}
			TimeKeeper._sae = (TimeKeeper.timeElapsed/lto) - Math.floor(1000/TimeKeeper.slowness);
		}
        return TimeKeeper._sae;
    };
    TimeKeeper.now = function() {
        if (!performance || !performance.now) {
            return Date.now();
        } else {
            return performance.now();
        }
    };
    tabageos.TimeKeeper = TimeKeeper;
})();

(function() { 
	'use strict';
    /** 
    *
    * @classdesc
	*   A basic class able to utilize the TravelerSkeleton methods, extending TravelerSkeleton. 
	*   It has methods for movement, but only basic bounds collision handling.
	*    
	*    
	* @class Traveler
	* @param x {Number}
	* @param y  {Number}
	* @param width {Number}
	* @param height {Number}
	* @param [dt=.6666666667]  {Number} Delta time, default is tabageos.TimeKeeper._sae 
    *
    * @see TravelerSkeleton
	*  
	*/
    function Traveler(x, y, width, height, dt) {
		tabageos.TravelerSkeleton.call(this,x,y,width,height);
        if (x || y || width > 0 || height > 0) {
            this.init(x, y, width, height);
        }
		this._deltaTime = dt || tabageos.TimeKeeper._sae;
    };
	/** 
	*   
	*    
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.constructor = Traveler;
	Traveler.prototype = Object.create(tabageos.TravelerSkeleton.prototype);
    /** 
	*   
	*    Like super. Called during construction.
	*    
	* @memberof Traveler.prototype 
	* @method init
	* @param x 
	* @param y 
	* @param width 
	* @param height 
    * 
	*/
    Traveler.prototype.init = function(x, y, width, height) {
        this.x = x || 0;
        this.y = y || 0;
        this.height = height || 0;
        this.width = width || 0;
        this.travelType = this.easeTo;
        this.boundingMethod = tabageos.BoundMethods.boundTo;
        this.mass = 10;
        this.avoidSpace = 35;
        this.maxSpeed = 14;
        this.maxForce = 25;
		this.followDistance = 10;
		this.easeProximity = 2;
		this.wanderProximity = 10;
		this.wanderAngle = 5;
		this.wanderRadius = 20;
		this.wanderRange = 20;
		this._wallObject = null;
		this.spreadDistance = 10;
		this.circleDistance = 50;
		this.separationDistance = 10;
    };
    /** 
	*   
	*    A Function (one of the TravelerSkeleton methods) 
	*    to call for traveling, used by the travel method.
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.travelType = null;
    /** 
	*   
	*    One of the tabageos.BoundMethods bounding methods. If there is a _wallObject defined,
	*    this method would be used to bind the Traveler to the wall Object.
	*    
	* @memberof Traveler 
	*  @type {Function}
	*/
    Traveler.prototype.boundingMethod = null;
    /** 
	*   
	*    
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.spreadDistance = 10;
    /** 
	*   
	*    
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.circleDistance = 50;
    /** 
	*   
	*    
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.separationDistance = 10;
    /** 
	*   
	*    @private
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.bypassAvoidDistance = null;
    /** 
	*   
	*    
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.maxForce = 2;
    /** 
	*   
	*    A MoverPoint used to store and update the forces; mass, maxSpeed, maxForce, being applied to the Travelers velocity. (_veloc)
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.forceApplier = null;
    /** 
	*   
	*    Used by the followPath method
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.followDistance = 10;
    /** 
	*   
	*    
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.easeProximity = 2;
    /** 
	*   
	*    
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.wanderProximity = 10;
    /** 
	*   
	*    Used by the wander method
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.wanderAngle = 5;
    /** 
	*   
	*    Used by the wander method
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.wanderRadius = 20;
    /** 
	*   
	*    Used by the wander method
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.wanderRange = 20;
    /** 
	*   
	*    Used by the wander method
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.wanderOffset = null;
    /** 
	*   
	*    
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.avoidSpace = 20;
    /** 
	*   
	*    
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.avoidDistance = 20;
    /** 
	*   
	*    
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.visionDistance = 10;
    /** 
	*   
	*    
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.personalSpace = 20;
    /** 
	*   
	*    
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.mass = 5;
    /** 
	*   
	*    
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype.maxSpeed = 10;
	/** 
	*   
	*   Optional holder for an EventDispatcher instance. 
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype._eventDispatcher = null;
    /** 
	*   
	*    A MoverPoint or MoverSkeleton that would be the target of travel for this Traveler.
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype._destination = null;
    /** 
	*   
	*    A Rectangle that should define the outermost bounds for this Traveler to travel within.
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype._wallObject = null;
	/** 
	*   
	*    The deltaTime (based on the desired frame rate) for this Traveler, default is tabageos.TimeKeeper._sae.
    *	 see tabageos.TimeKeeper.
	*    
	* @memberof Traveler 
	*  
	*/
    Traveler.prototype._deltaTime = null;
    /** 
	*   
	*    Sets the _wallObject property 
	*    
	* @memberof Traveler.prototype 
	* @method setWallObject
	* @param toThis {Rectangle}
    * 
	*/
    Traveler.prototype.setWallObject = function(toThis) {
        this._wallObject = toThis;
    }
    ;
    /** 
	*   Returns the _destination property
	*    
	*    
	* @memberof Traveler.prototype 
	* @method getDestination
    * @returns {MoverPoint|MoverSkeleton} 
	*/
    Traveler.prototype.getDestination = function() {
        return this._destination;
    }
    ;
    /** 
	*   
	*    Sets the _destination property.
	*    
	* @memberof Traveler.prototype 
	* @method setDestination
	* @param toThis {MoverPoint|MoverSkeleton}
    * 
	*/
    Traveler.prototype.setDestination = function(toThis) {
        this._destination = toThis;
    }
    ;
    /** 
	*    Updates the position and velocity of the Traveler (changes _veloc _pos and x and y) using forceApplier, maxForce, mass, _deltaTime, and maxSpeed. 
	* 	
	*    forceApplier is truncated by maxForce and divided by mass,
	* 	 then forceApplier is applied to _veloc.
	*	 _veloc is truncated by maxSpeed, and then _pos is updated based on _veloc.
	* 	 If a _wallObject is defined, the boundingMethod defined will be called,
	* 	 and then x and y are updated to match _pos.
	*    
	* @memberof Traveler.prototype 
	* @method move
    * 
	*/
    Traveler.prototype.move = function() {
        this.forceApplier.truncate(this.maxForce);
        this.forceApplier.divide(this.mass, 0);
        this._veloc.add(this.forceApplier.multiply(this._deltaTime,0), 0);
        this.forceApplier.reset();
        this._veloc._length = 0;
        this._veloc._angle = 0;
        this._veloc.truncate(this.maxSpeed);
        this._pos.addBy(this._veloc.x * this._deltaTime, this._veloc.y * this._deltaTime, 0);
        if (this._wallObject)
            this.boundingMethod(this, this._wallObject);
		
        this.x = this._pos.x+1-1;
        this.y = this._pos.y+1-1;
    }
    ;
    /** 
	*   
	*    If a travelType function is defined,
	* 	 this method will call the travelType with the to param of this method or otherwise the _destination property of the instance,
	*    then move is called.
	*
	* 	The TravelerSkeleton methods update the forceApplier and the move method applies forceApplier to update the velocity and position of the Traveler.
	*    
	* @memberof Traveler.prototype 
	* @method travel
	* @param to {MoverPoint|MoverSkeleton} The MoverPoint or MoverSkeleton to travel to.
    * 
	*/
    Traveler.prototype.travel = function(to) {
        if (this.travelType != null)
            this.travelType(to||this._destination);
        this.move();
    }
    ;
    tabageos.Traveler = Traveler;
})();

(function() { 
	'use strict';
    /** 
    *
    *@class TravelerSkeleton
	*  @classdesc
	*    A Class that uses MoverPoints to move based on a given velocity.
	*	 All other 'Traveler' Classes extend this class or use this class.
	* 	This 'skeleton' class does not implement any actual movement,
	* 	it holds all the methods that manipulate points.
	*    
	* 
	* @param x {Number} The initial x position of the TravelerSkeleton.
	* @param y {Number} The initial y position of the TravelerSkeleton.
	* @param width {Number} the width of the TravelerSkeleton
	* @param height  {Number} the height of the TravelerSkeleton
	*  
	*/
    function TravelerSkeleton(x, y, width, height) {
        this.forceApplier = new tabageos.MoverPoint();
        this.forceHolder = new tabageos.MoverPoint();
        this._w = width || 0;
        this._h = height || 0;
        this.wanderOffset = new tabageos.MoverPoint(0,0);
        this.blankMO = new tabageos.MoverPoint();
        this._veloc = new tabageos.MoverPoint();
        this._eventDispatcher = new tabageos.EventDispatcher();
        this.width = width || 0;
        this.height = height || 0;
        this._middlePoint = new tabageos.MoverPoint();
        this._pos = new tabageos.MoverPoint(x,y);
        this._lastVeloc = new tabageos.MoverPoint(0,0);
        this._lastPos = new tabageos.MoverPoint(x,y);
        this.x = x || 0;
        this.y = y || 0;
		this.dX = 0; this.dY = 0;
        this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
		this.spreadDistance = 10;
		this.circleDistance = 10;
		this.separationDistance = 10;
		this.bypassAvoidDistance = null;
		this.maxForce = 12;
		this.followDistance = this._w;
		this.easeProximity = 2;
		this.wanderProximity = 10;
		this.wanderAngle = 10;
		this.wanderRadius = 20;
		this.wanderRange = 20;
		this.avoidSpace = 20;
		this.avoidee = null;
		this.avoidDistance = 20;
		this.visionDistance = 20;
		this.personalSpace = 20;
		this.mass = 2;
		this.maxSpeed = 5;
		this.flockCount = null;
		this.bird = null;
		this._pathIndex = 0;
		this._hp = new tabageos.MoverPoint();
		this._vp = new tabageos.MoverPoint();
		this._pathEvent = new Event("pathComplete");
		this.listenerStrings = null;
		this.listenerMethods = null;
    };
	/** 
	*   @private
	*    
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.constructor = TravelerSkeleton;
    /** 
	*   
	*    Used with the separate method.
	*    Default is 10
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.spreadDistance = 10;
    /** 
	*   
	*    Used with the .circle method.
	*    Default is 10
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.circleDistance = 10;
    /** 
	*   
	*    
	*    Default is 10
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.separationDistance = 10;
    /** 
	*   
	*    
	*    @type Boolean
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.bypassAvoidDistance = null;
    /** 
	*   
	*    
	*    Default is 12
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.maxForce = 12;
    /** 
	*   
	*    @private
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.forceApplier = null;
    /** 
	*   
	*    
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.followDistance = null;
    /** 
	*   
	*    
	*    Default is 2
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.easeProximity = 2;
    /** 
	*   
	*    
	*    Default is 10
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.wanderProximity = 10;
    /** 
	*   
	*    
	*    Default is 10
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.wanderAngle = 10;
    /** 
	*   
	*    
	*    Default is 20
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.wanderRadius = 20;
    /** 
	*   
	*     Default is 20
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.wanderRange = 20;
    /** 
	*   
	*    
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.wanderOffset = null;
    /** 
	*   
	*    Default is 20.
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.avoidSpace = 20;
    /** 
	*   
	*    
	*    @type MoverSkeleton
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.avoidee = null;
    /** 
	*   
	*    Default is 20.
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.avoidDistance = 20;
    /** 
	*   Default is 20
	*    @type Number
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.visionDistance = 20;
    /** 
	*   
	*     Default is 20.
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.personalSpace = 20;
    /** 
	*   
	*     Default is 2
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.mass = 2;
    /** 
	*   
	*     Default is 5
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.maxSpeed = 5;
    /** 
	*   
	*    Holds the velocity of the TravelerSkeleton 
	*    
	*	@type MoverPoint 
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype._veloc = null;
    /** 
	*   
	*    
	*    @type MoverPoint
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.forceHolder = null;
    /** 
	*   
	*    
	*    @private
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.blankMO = null;
    /** 
	*   
	*    @private
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.flockCount = null;
    /** 
	*   
	*    
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.bird = null;
    /** 
	*   
	*    @private
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype._eventDispatcher = null;
    /** 
	*   @private
	*    
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype._pathIndex = 0;
	/** 
	*   
	*    
	*    @type Array
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.path = null;
	/** 
	*   
	*    @private
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype._pathEvent = null;
    /** 
	*   
	*    
	*    @private
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.listenerStrings = null;
    /** 
	*   
	*    
	*    @private
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.listenerMethods = null;
    /** 
	*   
	*    Holds the position of the TravelerSkeleton
	*    @type MoverPoint
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype._pos = null;
    /** 
	*   
	* 	Would hold the last known position of the TravlerSkeleton 
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype._lastPos = null;
    /** 
	*   
	*    Would hold the last known velocity of the TravelerSkeleton
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype._lastVeloc = null;
    /** 
	*   
	*    
	*    @type Rectangle
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype._rect = null;
    /** 
	*   
	*    For denoting horizontal direction
    *
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.dX = null;
    /** 
	*   Holding the x position
	*    
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.x = null;
    /** 
	*   For denoting vertical direction
	*    
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.dY = null;
    /** 
	*   Holding the y position
	*    
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.y = null;
    /** 
	*   
	*    
	*    @type Number
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.width = null;
    /** 
	*   
	*    
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype.height = null;
	/** 
	*   
	*    @private
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype._hp = null;
	/** 
	*   
	*    @private
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype._vp = null;
    /** 
	*   
	*    @private
	*    
	* @memberof TravelerSkeleton 
	*  
	*/
    TravelerSkeleton.prototype._middlePoint = null;
    /** 
	*   
	*    Returns the height of the TravelerSkeleton
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getHeight
    * @returns {Number} 
    *
	*/
    TravelerSkeleton.prototype.getHeight = function() {
        return this.height;
    };
    /** 
	*   
	*    Returns the vertical direction the TravelerSkeleton is moving typically 0 1 or -1.
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getVerticalDirection
    * @returns {Number} 
	*/
    TravelerSkeleton.prototype.getVerticalDirection = function() {
        return this.dY;
    };
    /** 
	*   
	*    Returns the horizontal direction the TravelerSkeleton is moving typically 0 1 or -1.
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getHorizontalDirection
    * @returns {Number} 
	*/
    TravelerSkeleton.prototype.getHorizontalDirection = function() {
        return this.dX;
    };
    /** 
	*   
	*    Returns the width of the TravelerSkeleton
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getWidth
    * @returns {Number} 
	*/
    TravelerSkeleton.prototype.getWidth = function() {
        return this.width;
    };
    /** 
	*   
	*    Returns the MoverPoint position of the TravelerSkeleton
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getPosition
    * @returns {MoverPoint} 
	*/
    TravelerSkeleton.prototype.getPosition = function() {
        return this._pos;
    };
    /** 
	*   
	*    Sets the MoverPoint position of the TravelerSkeleton
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method setPosition
	* @param toThis {MoverPoint}
    * 
	*/
    TravelerSkeleton.prototype.setPosition = function(toThis) {
        this._pos = toThis;
        this.x = this._pos.x+1-1;
        this.y = this._pos.y+1-1;
    };
    /** 
	*   
	*  Returns the current velocity (._veloc) MoverPoint   
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getVelocity
    * @returns {MoverPoint} 
	*/
    TravelerSkeleton.prototype.getVelocity = function() {
        return this._veloc;
    };
    /** 
	*   
	*    Sets the current velocity MoverPoint
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method setVelocity
	* @param toThis {MoverPoint}
    *  
	*/
    TravelerSkeleton.prototype.setVelocity = function(toThis) {
        this._veloc = toThis;
    };
    /** 
	*   
	*    Returns the x position of the TravelerSkeleton
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getX
    * @returns {Number} 
	*/
    TravelerSkeleton.prototype.getX = function() {
        return this.x;
    };
    /** 
	*   
	*    Sets the x position of the TravelerSkeleton
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method setX
	* @param toThis {Number} the number to set the x position to.
	* @param notDX {Number} if present, the direction values of the TravelerSkeleton will not be updated.
    * 
	*/
    TravelerSkeleton.prototype.setX = function(toThis, notDX) {
		if(!notDX) {
			if (toThis > this.x) {
				this.dX = 1;
			}
			if (toThis < this.x) {
				this.dX = -1;
			}
			if (toThis == this.x) {
				this.dX = 0;
			}
		}
        this.x = toThis+1-1;
        this._pos.x = toThis+1-1;
    };
    /** 
	*   Returns the y position of the TravelerSkeleton
	*    
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getY
    * @returns {Number} 
	*/
    TravelerSkeleton.prototype.getY = function() {
        return this.y;
    };
    /** 
	*   
	*    Sets the y position of the TravelerSkeleton
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method setY
	* @param toThis {Number}
	* @param notDY {Number} if present the y direction value will not be updated. 
    * 
	*/
    TravelerSkeleton.prototype.setY = function(toThis, notDY) {
		if(!notDY) {
			if (toThis > this.y) {
				this.dY = 1;
			}
			if (toThis < this.y) {
				this.dY = -1;
			}
			if (toThis == this.y) {
				this.dY = 0;
			}
		}
        this.y = toThis+1-1;
        this._pos.y = toThis+1-1;
    };
    /** 
	*   
	*    Returns the middle position MoverPoint of the TravelerSkeleton
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getMiddle
    * @returns {MoverPoint} 
	*/
    TravelerSkeleton.prototype.getMiddle = function() {
        this._middlePoint.reset();
        this._middlePoint.x = this.x + (this.width >> 1);
        this._middlePoint.y = this.y + (this.height >> 1);
        return this._middlePoint;
    };
    /** 
	*   Returns the rectangle bounds of the TravelerSkeleton
	*    
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getRectangle
	* @param wOffset {Number} offset the width result by this amount
	* @param hOffset {Number} offset the height result by this amount
    * @returns {Rectangle} 
	*/
    TravelerSkeleton.prototype.getRectangle = function(wOffset,hOffset) {
        
        this._rect.x = this.x+1-1;
        this._rect.y = this.y+1-1;
        this._rect.width = this.width+1-1 + (wOffset||0);
        this._rect.height = this.height+1-1 + (hOffset||0);
        return this._rect;
        
    };
    /** 
	*   
	*    Updates _lastPos _lastVeloc _unGrounded _npRight _npLeft and _unCeiling
    *    Gets overriden in other classes to do other additional things.
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method update
    *  
	*/
    TravelerSkeleton.prototype.update = function() {
        this._lastPos.x = this._pos.x +1-1;
        this._lastPos.y = this._pos.y +1-1;
        this._lastVeloc.x = this._veloc.x+1-1;
        this._lastVeloc.y = this._veloc.y+1-1;
        this._unGrounded = this._grounded+1-1;
        this._npRight = this._pRight+1-1;
        this._npLeft = this._pLeft+1-1;
        this._unCeiling = this._atCeiling+1-1;
    };
    /** 
	*   
	*    Returns maxForce * maxForce;
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getMaxForceSquared
    * @returns {Number} 
	*/
    TravelerSkeleton.prototype.getMaxForceSquared = function() {
        return this.maxForce * this.maxForce;
    };
    /** 
	*   
	*    Returns the _pathIndex 
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getPathIndex
    * @returns {Number} 
	*/
    TravelerSkeleton.prototype.getPathIndex = function() {
        return this._pathIndex;
    };
    /** 
	*   
	*    Sets the pathIndex 
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method setPathIndex
	* @param toThis {Number}
    * 
	*/
    TravelerSkeleton.prototype.setPathIndex = function(toThis) {
        this._pathIndex = toThis;
    };
    /** 
	*   
	*    Separate from the other TravelerSkeletons in the withThese Array.
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method separate
	* @param withThese {Array} an Array of TravelerSkeletons to separate from.
	* @param separatePriority {Number} A higher number will produce more separation.
    * 
	*/
    TravelerSkeleton.prototype.separate = function(withThese, separatePriority) {
        this.getSeparationForce(withThese);
        if (separatePriority > 1)
            this.forceApplier.multiply(separatePriority, 0);
        //this.forceApplier = this.forceApplier.add(force);
    };
    /** 
	*   
	*    Separate from the Mover given.
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method separateFromThis
	* @param mover {Mover|Traveler}
    *  
	*/
    TravelerSkeleton.prototype.separateFromThis = function(mover) {
        var difference;
        var distance;
		distance = tabageos.MoverPoint.distBetween(this._pos, mover.getPosition());
        if (distance > 0 && distance < this.separationDistance) {
			this._hp.x = this._pos.x; this._hp.y = this._pos.y;
			this._hp.subtract(mover.getPosition(), 0);
			this._hp.multiply(distance,0);
			this.forceApplier.add(this._hp, 0);
        }
    };
    /** 
	*   
	*    Returns the force needed to steer towards the target given.
	*	 Uses maxForce and maxSpeed.    
	*
	* @memberof TravelerSkeleton.prototype 
	* @method getSteerForce
	* @param target {Mover|Traveler}
	* @param ease {Boolean} If present ease the steer, otherwise just directly steer
	* @param easeDistance {Number} the amount of distance before easing should happen.   
    * @returns {MoverPoint} 
	*/
    TravelerSkeleton.prototype.getSteerForce = function(target, ease, easeDistance) {
		this._hp.x = target.x; this._hp.y = target.y;
        var steeringForce = this._hp;
        steeringForce.subtract(this._pos, 0);
        var distance = this._pos.dist(steeringForce.normalize());
        if (distance > 0) {
            if (distance < easeDistance && ease) {
                steeringForce.multiply(this.maxSpeed * (distance / easeDistance), 0);
            } else {
                steeringForce.multiply(this.maxSpeed, 0);
            }
            steeringForce.subtract(this._veloc, 0);
            if (steeringForce.getSquaredLength() > this.getMaxForceSquared()) {
                steeringForce.truncate(this.maxForce);
            }
        }
        return steeringForce;
    };
    /** 
	*   
	*    Flee the given MoverPoint
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method flee
	* @param mp {MoverPoint} the MoverPoint to flee
    * 
	*/
    TravelerSkeleton.prototype.flee = function(mp) {
		this._hp.x = mp.x; this._hp.y = mp.y;
        var targetVeloc = this._hp.subtract(this._pos, 0);
        targetVeloc.normalize();
        targetVeloc.multiply(this.maxSpeed, 0);
        var force = targetVeloc.subtract(this._veloc, 0);
        this.forceApplier.subtract(force, 0);
    };
    /** 
	*   Ease to the given MoverPoint.
	*    Uses easeProximity.
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method easeTo
	* @param mp {MoverPoint}
    * 
	*/
    TravelerSkeleton.prototype.easeTo = function(mp) {
		this._hp.x = mp.x; this._hp.y = mp.y;
        var targetVeloc = this._hp.subtract(this._pos, 0);
        targetVeloc.normalize();
        var distance = this._pos.dist(mp);
        if (distance > this.easeProximity) {
            targetVeloc.multiply(this.maxSpeed, 0);
        } else {
            var easing = this.maxSpeed * distance / this.easeProximity;
            targetVeloc.multiply(easing, 0);
        }
        var force = targetVeloc.subtract(this._veloc, 0);
        this.forceApplier.add(force, 0);
    };
    /** 
	*   
	*    
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getSeparationForce
	* @param fromThese {Array}
    * 
	*/
    TravelerSkeleton.prototype.getSeparationForce = function(fromThese) {
		//this._hp.x = this.forceHolder.x;this._hp.y = this.forceHolder.y;
		//this._hp.length = this.forceHolder.length; this._hp.angle = this.forceHolder.angle;
       // var force = this.forceHolder.lesserClone();
        //this.forceHolder.reset();
        //var difference;
        var distance;
        var count = 0;
        var mover;
        var i = 0;
        for (i = 0; i < fromThese.length; i++) {
            mover = fromThese[i];
            distance = tabageos.MoverPoint.distBetween(this._pos, mover.getPosition());
            if (distance > 0 && distance < this.separationDistance) {
				this._hp.x = this._pos.x; this._hp.y = this._pos.y;
				this._hp.subtract(mover.getPosition(), 0);
				this._hp.multiply(distance,0);
                //difference = this._pos.subtract(mover.getPosition());
				//difference.multiply(distance, 0);
               //  this.forceHolder.add(this._hp, 0);
			   this.forceApplier.add(this._hp, 0);
                count++;
            }
        }
        if (count > 0) {
            this.forceApplier.multiply(1 / count, 0);
        }
       // return force;
    };
    /** 
	*   
	*    Returns true if the MoverPoint is within visionDistance at the current velocity
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method canSeeThis
	* @param mp {MoverPoint}
    * @returns {Boolean} 
	*/
    TravelerSkeleton.prototype.canSeeThis = function(mp) {
        var result = false;
		this._hp.x = mp.x; this._hp.y = mp.y;
        if (this._pos.dist(mp) > this.visionDistance)
            return result;
		this._vp.x = this._veloc.x; this._vp.y = this._veloc.y;
        var sight = this._vp.normalize();
        var distanceDifference = this._hp.subtract(this._pos, 0);
        var dotProduct = distanceDifference.dotProduct(sight);
        if (dotProduct < 0) {
            result = false;
        } else {
            result = true;
        }
        return result;
    };
    /** 
	*   
	*    
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getAlignmentForce
	* @param withThese {Array}
    * 
	*/
    TravelerSkeleton.prototype.getAlignmentForce = function(withThese) {
      // var force = this.forceHolder.lesserClone();
        //this.forceHolder.reset();
        var distance;
        var count = 0;
        var mover;
        var i = 0;
        for (i = 0; i < withThese.length; i++) {
            mover = withThese[i];
            distance = tabageos.MoverPoint.distBetween(this._pos, mover.getPosition());
            if (distance > 0 && distance < this.separationDistance) {
                this.forceApplier.add(mover._veloc, 0);
                count++;
            }
        }
        if (count > 0) {
            this.forceApplier.multiply(1 / count, 0);
            if (this.forceApplier.getSquaredLength() > this.getMaxForceSquared()) {
                this.forceApplier.truncate(this.maxForce);
            }
        }
        //return force;
    };
    /** 
	*   
	*    Returns true if almost close to the MoverPoint
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method almostCloseTo
	* @param mp {MoverPoint}
    * @returns {Boolean} 
	*/
    TravelerSkeleton.prototype.almostCloseTo = function(mp) {
        return this._pos.dist(mp) < this.personalSpace;
    };
    /** 
	*   
	*    
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method getCohesionForce
	* @param withThese 
    * 
	*/
    TravelerSkeleton.prototype.getCohesionForce = function(withThese) {
       // var force = this.forceHolder.lesserClone();
        //this.forceHolder.reset();
        var distance;
        var count = 0;
        var mover;
        var i = 0;
        for (i = 0; i < withThese.length; i++) {
            mover = withThese[i];
            distance = tabageos.MoverPoint.distBetween(this._pos, mover.getPosition());
            if (distance > 0 && distance < this.personalSpace) {
                this.forceApplier.add(mover.getPosition(), 0);
                count++;
            }
        }
        if (count > 0) {
            this.forceApplier.multiply(1 / count, 0);
			this.forceApplier = this.getSteerForce(this.forceApplier, true, this.personalSpace);
           // return force;
        }
        //return force;
    };
    /** 
	*   
	*    Ease away from the MoverPoint given.
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method easeAwayFrom
	* @param mp {MoverPoint}
    * 
	*/
    TravelerSkeleton.prototype.easeAwayFrom = function(mp) {
        if (this._pos.dist(mp) < this.avoidDistance || this.bypassAvoidDistance > 0) {
            //
			this._hp.x = mp.x; this._hp.y = mp.y;
			var targetVeloc = this._hp.subtract(this._pos, 0);
            targetVeloc.normalize();
            var distance = this._pos.dist(mp);
            if (distance < this.easeProximity) {
                targetVeloc.multiply(this.maxSpeed, 0);
            } else {
                var easing = this.maxSpeed * distance / this.easeProximity;
                targetVeloc.multiply(easing, 0);
            }
            var force = targetVeloc.subtract(this._veloc, 0);
			//this._hp.subtract(this._veloc, 0);
            //this.forceApplier = 
			this.forceApplier.subtract(force, 0);
        }
    };
    /** 
	*   Chase the target given.
	*    
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method chase
	* @param target {Mover|Traveler}
    * 
	*/
    TravelerSkeleton.prototype.chase = function(target) {
        var chaseTime = this._pos.dist(target._pos) / this.maxSpeed;
		this._hp.x = target._pos.x; this._hp.y = target._pos.y;
		this._vp.x = target._veloc.x; this._vp.y = target._veloc.y;
        var heading = this._hp.add(this._vp.multiply(chaseTime, 0), 0);
        this.easeTo(heading);
    };
    /** 
	*   
	*    Returns the MoverPoint position that is out of the given radius of from.
	*	 Uses personalSpace.
	*	 This method is used internally by the hide method.
	*
	* @memberof TravelerSkeleton.prototype 
	* @method getHideSpot
	* @param currentPosition {MoverPoint} the current MoverPoint position to calculate the hide spot from. 
	* @param radius {Number} The radius to use during calculations.
	* @param from {Mover|Traveler} The Mover to hide from.
    * @returns {MoverPoint} 
	*/
    TravelerSkeleton.prototype.getHideSpot = function(currentPosition, radius, from) {
        var dist = (this.personalSpace * 2) + radius;
		this._hp.x = currentPosition.x; this._hp.y = currentPosition.y;
        var ideal = this._hp.subtract(from._pos, 0).normalize();
        return ideal.multiply(dist, 0).add(currentPosition, 0);
    };
    /** 
	*   
	*    Hide behind the given Array of Movers, from the given Mover.
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method hide
	* @param behindThese {Array} An Array of Movers/Travelers to hide behind.
	* @param from {Mover|Traveler} The Mover/Traveler to hide from.
    * 
	*/
    TravelerSkeleton.prototype.hide = function(behindThese, from) {
        var closetObstacleDistance = -9999;
        var i = -1;
        var m;
        var check;
        var spot;
        var dist;
        while (i != behindThese.length - 1) {
            i++;
            m = behindThese[i];
            if (m) {
                check = this.getHideSpot(m._pos, m.width, from);
                dist = check.dist(this._pos);
                if (dist < closetObstacleDistance) {
                    closetObstacleDistance = dist;
                    spot = check;
                }
            }
        }
        if (closetObstacleDistance != -9999) {
            this.easeTo(spot);
        }
    };
    /** 
	*   
	*    Wander aimlessly.
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method wander
    *  
	*/
    TravelerSkeleton.prototype.wander = function() {
		this._hp.x = this._veloc.x; this._hp.y = this._veloc.y;
		this._hp._angle = this._veloc._angle; this._hp._length = this._veloc._length;
        this._hp.normalize().multiply(this.wanderProximity, 0);
        this.wanderOffset.setLength(this.wanderRadius);
        this.wanderOffset.setAngle(this.wanderAngle);
        this.wanderAngle += Math.random() * this.wanderRange - this.wanderRange * .5;
        this._hp.add(this.wanderOffset, 0);
        this.forceApplier.add(this._hp, 0);
    };
    /** 
	*   
	*    Evade the given target
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method evade
	* @param target {Mover|Traveler}
    * 
	*/
    TravelerSkeleton.prototype.evade = function(target) {
        var chaseTime = this._pos.dist(target._pos) / this.maxSpeed;
		this._hp.x = target._pos.x; this._hp.y = target._pos.y;
		this._vp.x = target._veloc.x; this._vp.y = target._veloc.y;
        var heading = this._hp.subtract(this._vp.multiply(chaseTime,0), 0);
        this.easeAwayFrom(heading);
    };
    /** 
	*   
	*    Avoid the given Mover
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method avoid
	* @param moverSkeleton {MoverSkeleton}
    * @returns {Boolean} 
	*/
    TravelerSkeleton.prototype.avoid = function(moverSkeleton) {
        var away = true;
      //  var i = 0;
        //for (i = 0; i < these.length; i++) {
            this.avoidee = moverSkeleton;
			this._vp.x = this._veloc.x; this._vp.y = this._veloc.y;this._vp._angle = this._veloc._angle;this._vp._length=this._veloc._length;
            var myDirection = this._vp.normalize();
            var distanceDifference = this.avoidee.getMiddle().subtract(this._pos);
            var dotProduct = distanceDifference.dotProduct(myDirection);
            if (dotProduct > 0) {
                var lineOfSight = myDirection.multiply(this.avoidDistance);
                var future = myDirection.multiply(dotProduct);
                var howFar = future.subtract(distanceDifference).getLength();
                if (howFar < (this.avoidee.width * 2) + this.avoidSpace && future.getLength() < lineOfSight.getLength()) {
                    var force = myDirection.multiply(this.maxSpeed);
                    force.setAngle(force.getAngle() + (distanceDifference.sign(this._vp) * Math.PI / 2));
                    force.multiply(1 - future.getLength() / lineOfSight.getLength(), 0);
                    this.forceApplier.add(force, 0);
                    this._veloc.multiply(future.getLength() / lineOfSight.getLength(), 0);
                    away = false;
                } else {
                    away = true;
                }
            }
       // }
        return away;
    };
	/** 
	*   
	*    Avoid the given Array of Movers.
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method avoidThese
	* @param these {Array} An Array of the Movers to avoid.
    * @returns {Boolean} 
	*/
    TravelerSkeleton.prototype.avoidThese = function(these) {
        var away = true;
        var i = 0;
        for (i = 0; i < these.length; i++) {
            this.avoidee = these[i];
            this._vp.x = this._veloc.x; this._vp.y = this._veloc.y;this._vp._angle = this._veloc._angle;this._vp._length=this._veloc._length;
            var myDirection = this._vp.normalize();
            var distanceDifference = this.avoidee.getMiddle().subtract(this._pos);
            var dotProduct = distanceDifference.dotProduct(myDirection);
            if (dotProduct > 0) {
                var lineOfSight = myDirection.multiply(this.avoidDistance);
                var future = myDirection.multiply(dotProduct);
                var howFar = future.subtract(distanceDifference).getLength();
                if (howFar < (this.avoidee.width * 2) + this.avoidSpace && future.getLength() < lineOfSight.getLength()) {
                    var force = myDirection.multiply(this.maxSpeed);
                    force.setAngle(force.getAngle() + (distanceDifference.sign(this._veloc) * Math.PI / 2));
                    force = force.multiply(1 - future.getLength() / lineOfSight.getLength());
                    this.forceApplier = this.forceApplier.add(force, 1);
                    this._veloc = this._veloc.multiply(future.getLength() / lineOfSight.getLength(), 1);
                    away = false;
                } else {
                    away = true;
                }
            }
        }
        return away;
    };
    /** 
	*   
	*    Seek the given MoverPoint position.
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method seek
	* @param mp {MoverPoint} The MoverPoint to seek.
    * 
	*/
    TravelerSkeleton.prototype.seek = function(mp) {
		this._hp.x = mp.x; this._hp.y = mp.y;
		this._hp.subtract(this._pos, 0);
        this._hp.normalize();
        this._hp.multiply(this.maxSpeed, 0);
        this.forceApplier.add(this._hp.subtract(this._veloc, 0), 0);
    };
    /** 
	*   
	*    Follow the path of given MoverPoints; easeTo each MoverPoint.
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method followPath
	* @param path {Array} An Array of MoverPoints that make up the path.
	* @param loopPath {Boolean} 
    * 
	*/
    TravelerSkeleton.prototype.followPath = function(path, loopPath) {
        var nextMO = path[this._pathIndex];
        if (!nextMO)
            return;
        if (this._pos.dist(nextMO) < this.followDistance) {
            if (this._pathIndex >= path.length - 1) {
                this.dispatchEvent(this._pathEvent);
                if (loopPath)
                    this._pathIndex = 0;
            } else {
                this._pathIndex += 1;
            }
            return;
        }
        this.easeTo(nextMO);
    };
    
    /** 
	*   Circle around the given MoverPoint position.
	*    Uses circleDistance
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method circle
	* @param mp {MoverPoint} The MoverPoint to circle around.
    *
	*/
    TravelerSkeleton.prototype.circle = function(mp) {
        
        var l = Math.sqrt((this._pos.x - mp.x) * (this._pos.x - mp.x) + (this._pos.y - mp.y) * (this._pos.y - mp.y));
        var thex = (this._pos.x - mp.x) / l;
        var they = (this._pos.y - mp.y) / l;
        var destx = mp.x + (thex*this.circleDistance) - this._pos.x + this._veloc.x;
        var desty = mp.y + (they*this.circleDistance) - this._pos.y + this._veloc.y;
        this.forceApplier.x = destx;
        this.forceApplier.y = desty;
        this.forceApplier._length = 0;
        this.forceApplier._angle = 0;
       
    };
    /** 
	*   
	*    
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method addEventListener
	* @param type 
	* @param listenerString 
	* @param object 
    * 
	*/
    TravelerSkeleton.prototype.addEventListener = function(type, listenerString, object) {
        this._eventDispatcher.addEventListener(type, listenerString, object);
    };
    /** 
	*   
	*    
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method removeEventListener
	* @param type 
	* @param listenerString 
	* @param object 
    * 
	*/
    TravelerSkeleton.prototype.removeEventListener = function(type, listenerString, object) {
        return this._eventDispatcher.removeEventListener(type, listenerString, object);
    };
    /** 
	*   
	*    
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method dispatchEvent
	* @param event 
    * 
	*/
    TravelerSkeleton.prototype.dispatchEvent = function(event) {
        return this._eventDispatcher.dispatchEvent(event);
    };
    /** 
	*   
	*    separate, align, and cohesion together.
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method flock
	* @param withThese {Array} Array of other Travelers
	* @param separatePriority {Number}
	* @param alignPriority {Number}
	* @param cohesionPriority {Number}
    * 
	*/
    TravelerSkeleton.prototype.flock = function(withThese, separatePriority, alignPriority, cohesionPriority) {
        this.separate(withThese, separatePriority );
        this.align(withThese, alignPriority || 1);
        this.cohesion(withThese, cohesionPriority || 1);
    };
    /** 
	*   
	*    
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method align
	* @param withThese {Array} Array of other Travelers
	* @param priority {Number}
    * 
	*/
    TravelerSkeleton.prototype.align = function(withThese, priority) {
        this.getAlignmentForce(withThese);
        if (priority > 1)
            this.forceApplier.multiply(priority, 0);
    };
    /** 
	*   
	*    
	*    
	* @memberof TravelerSkeleton.prototype 
	* @method cohesion
	* @param withThese {Array} Array of other Travelers
	* @param cohesionPriority {Number}
    * 
	*/
    TravelerSkeleton.prototype.cohesion = function(withThese, cohesionPriority) {
        this.getCohesionForce(withThese);
        if (cohesionPriority > 1)
            this.forceApplier.multiply(cohesionPriority, 0);
    };
    tabageos.TravelerSkeleton = TravelerSkeleton;
})();


(function() { 

	'use strict';
    
    /** 
	*   
	* Constructs a new TravelingSceneryThrower
	*    
	* @class TravelingSceneryThrower
    * @classdesc
    *
    *
    *    A MapTraveler designated as a SceneryThrower,
    *    it's similar to a plain SceneryThrower, but can do more.
    *
	* @param x {Number} The x position of the TravelingSceneryThrower
	* @param y {Number} The y position
	* @param width {Number}
	* @param height {Number}
	* @param map {Array} A 2D Array denoting areas the Traveler can pass or not. 0 or [0,0] would denote a blank passable spot.
	* @param [ca] {CanavsAnimation}
	* @param [dontCloneMap] {Boolean}
	* @param [dt=.6666666667] {Number}
	* @param [tWidth] {Number}
	* @param [tHeight] {Number}
	* @param [mr] {Number}
	* @param [mc] {Number} 
    *
    * @see MapTraveler
	* @see TravelerSkeleton
    * 
	*/
    function TravelingSceneryThrower(x,y,width,height, map, ca,dontCloneMap,dt,tWidth,tHeight,mr,mc) {
		tabageos.TravelerSkeleton.call(this,x,y,width,height);
		tabageos.MapTraveler.call(this,x,y,width,height, map, ca,dontCloneMap,dt,tWidth,tHeight,mr,mc);
        //this.init(source, canvasObject, fromRect, x, y, width, height);
        this.width = width || 0;
        this.height = height || 0;
        this._middlePoint = new tabageos.MoverPoint();
        this._pos = new tabageos.MoverPoint(x,y);
        this._veloc = new tabageos.MoverPoint(0,0);
        this._lastVeloc = new tabageos.MoverPoint(0,0);
        this._lastPos = new tabageos.MoverPoint(x,y);
        this._deltaTime = dt || tabageos.TimeKeeper._sae;
        this._map = dontCloneMap ? map : tabageos.BlitMath.cloneMultiArray(map);
        this._state = 1;
        this.x = x || 0;
        this.y = y || 0;
        this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
        this._canvasAnimation = ca || null;
        this._tH = tHeight || this.height;
        this._tW = tWidth || this.width;
        this._outAltered = new tabageos.MoverPoint();
        this.holdingRect = new tabageos.Rectangle(0,0,width,height);
        this.holdingOffsetX = 1;
        this.holdingOffsetY = 3;
        this._jumps = 0;
        this.easeProximity = 7;
        this._checkHelper = new tabageos.MoverPoint();
        this.forceApplier = new tabageos.MoverPoint();
        this.forceHolder = new tabageos.MoverPoint();
        this._w = width || 0;
        this._h = height || 0;
        this.wanderOffset = new tabageos.MoverPoint(0,0);
        this.blankMO = new tabageos.MoverPoint();
        this._eventDispatcher = new tabageos.EventDispatcher();
		this.holdings = [];
		this._holdingHelperRect = new tabageos.Rectangle(0,0,0,0);
		//tabageos.MapTraveler.call(this);
        
    }
    ;
	/** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower 
	*  
	*/
    TravelingSceneryThrower.prototype.constructor = TravelingSceneryThrower;
    TravelingSceneryThrower.prototype = Object.create(tabageos.TravelerSkeleton.prototype); 
	Object.assign(TravelingSceneryThrower.prototype, tabageos.MapTraveler.prototype);
    /** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower
	*  
	*/
    TravelingSceneryThrower.prototype.throwStrength = 10;
    /** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower
	*  
	*/
    TravelingSceneryThrower.prototype.health = 100;
    /** 
	*   
	*    The Object or TileData that the TravelingSceneryThrower is holding
	*    
	* @memberof TravelingSceneryThrower
	*  
	*/
    TravelingSceneryThrower.prototype.holding;//TileData
	/** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower
	*  
	*/
    TravelingSceneryThrower.prototype.holdings;
    /** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower
	*  
	*/
    TravelingSceneryThrower.prototype.holdingRect;
	/** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower
	*  
	*/
    TravelingSceneryThrower.prototype._holdingHelperRect;
    /** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower
	*  
	*/
    TravelingSceneryThrower.prototype._canvasAnimation = null;
    /** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower
	*  
	*/
    TravelingSceneryThrower.prototype._outAltered;
    /** 
	*   
	*    The horizontal offset for when holding
	*    
	* @memberof TravelingSceneryThrower
	*  
	*/
    TravelingSceneryThrower.prototype.holdingOffsetX = 1;
    /** 
	*   
	*    The vertical offset for when holding
	*    
	* @memberof TravelingSceneryThrower 
	*  
	*/
    TravelingSceneryThrower.prototype.holdingOffsetY = 3;
    /** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower
	*  
	*/
    TravelingSceneryThrower.prototype.nameOfThrower = "strawHat";

    /** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method alteredPosition
	* @param xAlterAmount 
	* @param yAlterAmount 
    * @returns {MoverPoint} 
	*/
    TravelingSceneryThrower.prototype.alteredPosition = function(xAlterAmount, yAlterAmount) {
        xAlterAmount = xAlterAmount || 0;
        yAlterAmount = yAlterAmount || 0;
        this._outAltered.x = this.x - xAlterAmount;
        this._outAltered.y = this.y - yAlterAmount;
        return this._outAltered;
    }
    ;
    /** 
	*   
	*    Returns holdingRect
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method holdingImageRect
    * @returns {Rectangle} 
	*/
    TravelingSceneryThrower.prototype.holdingImageRect = function() {
        return this.holdingRect;
    }
    ;
    /** 
	*   
	*    Picks up TileData updating holding and holdingRect
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method pickUpTileData
	* @param td {TileData}
	* @param imageWidthAdjust {Number} 
	* @param imageHeightAdjust {Number}
    * @returns {Boolean} Returns true if TileData was picked up
	*/
    TravelingSceneryThrower.prototype.pickUpTileData = function(td, imageWidthAdjust, imageHeightAdjust) {
        if (!this.holding) {
            this.holding = td;
            this.holdingRect.x = this.holding.value[1] * (this._tw);
            this.holdingRect.y = this.holding.value[0] * (this._th);
            this.holdingRect.width = this._tw;
            this.holdingRect.height = this._th;
            if (imageWidthAdjust) {
                this.holdingRect.width += imageWidthAdjust;
            }
            if (imageHeightAdjust) {
                this.holdingRect.height += imageHeightAdjust;
            }
            return true;
        }
        return false;
    };
	/** 
	*   
	*    Picks up TileData and stores it in the holdings Array
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method pickUpAndStoreTileData
	* @param obj {TileData}
	* @param imageWidthAdjust {Number}
	* @param imageHeightAdjust {Number}
	* @param dontReadyThrow {Boolean} Ready the last value in holdings as holding is the default behavior
    * @returns {Boolean} 
	*/
    TravelingSceneryThrower.prototype.pickUpAndStoreTileData = function(obj, imageWidthAdjust, imageHeightAdjust, dontReadyThrow) {
		
			this.holdings.push(obj);
			var hi = this.holdings.length - 1;
            this.holdingRect.x = this.holdings[hi].value[1] * (this._tw);
            this.holdingRect.y = this.holdings[hi].value[0] * (this._th);
            this.holdingRect.width = this._tw;
            this.holdingRect.height = this._th;
            if (imageWidthAdjust) {
                this.holdingRect.width += imageWidthAdjust;
            }
            if (imageHeightAdjust) {
                this.holdingRect.height += imageHeightAdjust;
            }
			
			if(!dontReadyThrow) { this._readyNextThrow(); } else { this.holding = null; }
			
            return true;
		
	};
    /** 
	*   
	*    Removes the holding from holdings that has the value given.
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method removeFromStorageByValue
	* @param tValue {Object}
    *  
	*/
    TravelingSceneryThrower.prototype.removeFromStorageByValue = function(tValue) {
		
		var i = 0; var l = this.holdings.length;
		for (i; i < l; i ++) {
			if(this.holdings[i] && this.holdings[i].value) {
				if(this.holdings[i].value[0] == tValue[0] && this.holdings[i].value[1] == tValue[1]) {
					
					this.holdings.splice(i, 1); break;
				}
			} else {
				if(this.holdings[i] && this.holdings[i].tileValue) {
					if(this.holdings[i].tileValue[0] == tValue[0] && this.holdings[i].tileValue[1] == tValue[1]) {
					
						this.holdings.splice(i, 1); break;
					}
				}
			}
		}
	};
    /** 
	*   
	*    Removes the last holding from holdings and sets holding to null.
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method removeLastFromStorage
    * @returns {Object} Returns the last holding value or null.
	*/
    TravelingSceneryThrower.prototype.removeLastFromStorage = function() {
		
		if(this.holdings.length) {
			var sceneobj = this.holdings.pop();
			sceneobj.setX( this.x+1-1 );sceneobj.setY(  this.y+1-1 );
			this.holding = null;
			return sceneobj;
		} else {
			
			return null;
		}
		
		
	};
    /** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower 
	*  
	*/
    TravelingSceneryThrower.prototype._tempDivs = [];
	/** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower 
	*  
	*/
    TravelingSceneryThrower.prototype._displayStorageClearRect;
	
	
	
	
	/** 
	*   Displays each value or tileValue in holdings using the given img, backgroundFromRect, and cameraLayer.
	*    
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method displayStorage
	* @param img {Img}
	* @param cameraLayer {CanvasObject}
	* @param backgroundFromRect {Rectangle} The Rectangle defining where in the image to draw from
	* @param bgx {Number} The top left of where to draw the background to
	* @param bgy {Number} The top left of where to draw the background to
	* @param tw {Number} The tile width
	* @param th {Number} tile height
	* @param stx {Number} The starting x position for the first value display
	* @param sty {Number} The starting y position for the first value display
	* @param descriptions {Array} An Array of [y,x, description] values where y,x matches the value of values in holdings, will cause a tool tip to appear with the description when user hovers over the displayed value.
    * 
	*/
    TravelingSceneryThrower.prototype.displayStorage = function(img,cameraLayer,backgroundFromRect,bgx,bgy,tw,th, stx, sty, descriptions) {
		
		var i = 0; var l = this.holdings.length; var j = 0; 
		if(!this._displayStorageClearRect) {
			this._displayStorageClearRect = new tabageos.Rectangle(backgroundFromRect.x + tw + 4, backgroundFromRect.y + th + 4, tw, th);
		}
		var xlc = stx +1-1; var ylc = sty +1-1;
		cameraLayer.copyPixels(img, backgroundFromRect, new tabageos.MoverPoint( bgx, bgy ), backgroundFromRect.width, backgroundFromRect.height);
		for (i; i < l; i++) { 
			
			var val = this.holdings[i].value ? this.holdings[i].value : this.holdings[i].tileValue;
			
			cameraLayer.copyPixels(img, new tabageos.Rectangle(val[1]*tw, val[0]*th, tw, th), new tabageos.MoverPoint( xlc, ylc ), tw, th);
			if(!this._tempDivs[i]) this._tempDivs[i] = document.createElement("div");
			this._tempDivs[i].sceneryThrower = this;
			this._tempDivs[i].cDisplay = cameraLayer;
			this._tempDivs[i]._img = img;
			this._tempDivs[i]._dscr = this._displayStorageClearRect;
			
			var ttle = "";
			if(descriptions && descriptions.length >= 1) {
				for (j = 0; j < descriptions.length; j++) {
					if(descriptions[j][0] == val[0] && descriptions[j][1] == val[1]) {
						ttle = descriptions[j][2];
					}
				}
			}
			this._tempDivs[i].setAttribute("title", ttle);
			this._tempDivs[i].setAttribute("id", val[0]+"v"+val[1]+"");
			this._tempDivs[i].setAttribute("style", "position:absolute;width:"+tw+"px;height:"+th+"px;top:"+ylc+"px;left:"+xlc+"px;cursor:pointer;z-index:99999999999999999999999999999999999999999999999999999999999999999");
			this._tempDivs[i].removeEventListener(tabageos.seekTouch() ? "touchstart" : "click", this.removeFromDisplayedStorage, false);
			this._tempDivs[i].addEventListener(tabageos.seekTouch() ? "touchstart" : "click", this.removeFromDisplayedStorage, false);
			cameraLayer.canvas.offsetParent.appendChild(this._tempDivs[i]);
			
			xlc += tw*2;
			if(xlc >= tw*14) {
				
				xlc = stx +1-1;
				ylc += th*2;
			}
		}
	};
	
	
	/** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower 
	*  
	*/
    TravelingSceneryThrower.prototype._removedFromStorage = [];
	
	/** 
	*   
	*    
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method removeFromDisplayedStorage
	* @param e {Object}
    * 
	*/
    TravelingSceneryThrower.prototype.removeFromDisplayedStorage = function(e) {
		
		
		var ele = e.target;
		var aVal = ele.id.split("v"); 
		function dep(sx) { 
			return Number(sx.replace("px",""));
		};
		
		aVal[0] = Number(aVal[0]); aVal[1] = Number(aVal[1]);
		ele.sceneryThrower.removeFromStorageByValue(aVal);
		ele.sceneryThrower._removedFromStorage.push(aVal);
		ele.cDisplay.copyPixels(ele._img, ele._dscr, new tabageos.MoverPoint(dep(ele.style.left), dep(ele.style.top)), dep(ele.style.width), dep(ele.style.height));
		ele.removeEventListener(tabageos.seekTouch() ? "touchstart" : "click", ele.sceneryThrower.removeFromDisplayedStorage, false);
		ele.offsetParent.removeChild(ele);
		
		
		
	};
    
	/** 
	*   
	*    Picks up the object and stores it in the holdings Array
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method pickUpAndStore
	* @param obj {Object}
	* @param imageWidthAdjust {Number}
	* @param imageHeightAdjust {Number}
	* @param dontReadyThrow {Boolean} By default the obj is also made ready as holding.
    * 
	*/
    TravelingSceneryThrower.prototype.pickUpAndStore = function(obj, imageWidthAdjust, imageHeightAdjust, dontReadyThrow) {
		
			this.holdings.push(obj);
			var hi = this.holdings.length - 1;
            this.holdingRect.x = this.holdings[hi].tileValue[1] * (obj.width);
            this.holdingRect.y = this.holdings[hi].tileValue[0] * (obj.height);
            this.holdingRect.width = obj.width;
            this.holdingRect.height = obj.height;
            if (imageWidthAdjust) {
                this.holdingRect.width += imageWidthAdjust;
            }
            if (imageHeightAdjust) {
                this.holdingRect.height += imageHeightAdjust;
            }
			
			if(!dontReadyThrow) { this._readyNextThrow(); } else { this.holding = null; }
			
            return true;
		
	};
    /** 
	*   
	*    Picks up the obj and stores it has holding
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method pickUp
	* @param obj {Object}
	* @param imageWidthAdjust {Number}  adjust the holdingRect width
	* @param imageHeightAdjust {Number} adjust the holdingRect height
    * @returns {Boolean} 
	*/
    TravelingSceneryThrower.prototype.pickUp = function(obj, imageWidthAdjust, imageHeightAdjust) {
        if (!this.holding) {
            this.holding = obj;
            this.holdingRect.x = obj.tileValue[1] * (obj.width);
            this.holdingRect.y = obj.tileValue[0] * (obj.height);
            this.holdingRect.width = obj.width;
            this.holdingRect.height = obj.height;
            if (imageWidthAdjust) {
                this.holdingRect.width += imageWidthAdjust;
            }
            if (imageHeightAdjust) {
                this.holdingRect.height += imageHeightAdjust;
            }
            return true;
        }
        return false;
    };
    /** 
	*   
	*    Sets holding to null after first removing it from holdings if in holdings.
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method _throwHolding
    *  
	*/
    TravelingSceneryThrower.prototype._throwHolding = function() {
        
		if(this.holdings.indexOf(this.holding) != -1) {
			this.holdings.splice(this.holdings.indexOf(this.holding), 1);
		}
        this.holding = null;
        
    };
	/** 
	*   
	*    Sets holding to the last value in holdings and updates holdingRect
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method _readyNextThrow
    * 
	*/
    TravelingSceneryThrower.prototype._readyNextThrow = function() {
		//window.console.log("r n t");
		if(this.holdings.length) {
			
			
				
				this.holding = this.holdings[this.holdings.length-1];
				if(this.holding.tileValue) {
					this.holdingRect.x = this.holding.tileValue[1] * (this.holding.width);
					this.holdingRect.y = this.holding.tileValue[0] * (this.holding.height);
					this.holdingRect.width = this.holding.width;
					this.holdingRect.height = this.holding.height;
				} else {
					this.holdingRect.x = this.holding.value[1] * (this._tW);
					this.holdingRect.y = this.holding.value[0] * (this._tH);
					this.holdingRect.width = this._tW;
					this.holdingRect.height = this._tH;

					
				}
				
			
		}
		
	};
	/** 
	*   
	*    Returns the value or tileValue of holdin
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method valueFromHolding
	* @param holdin {Object}
    * @returns {Object} 
	*/
    TravelingSceneryThrower.prototype.valueFromHolding = function(holdin) {
		
		return (holdin.value || holdin.tileValue);		
	};
	/** 
	*   
	*    Returns the holding Rectangle.
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method rectFromHolding
	* @param holdin {Object}
    * @returns {Rectangle} 
	*/
    TravelingSceneryThrower.prototype.rectFromHolding = function(holdin) {
		
				if(holdin.tileValue) {
					this._holdingHelperRect.x = holdin.tileValue[1] * (holdin.width);
					this._holdingHelperRect.y = holdin.tileValue[0] * (holdin.height);
					this._holdingHelperRect.width = holdin.width;
					this._holdingHelperRect.height = holdin.height;
				} else {
					this._holdingHelperRect.x = holdin.value[1] * (this._tW);
					this._holdingHelperRect.y = holdin.value[0] * (this._tH);
					this._holdingHelperRect.width = this._tW;
					this._holdingHelperRect.height = this._tH;
				}
		return this._holdingHelperRect;
	};
    /** 
	*   
	*    Throws holding as a SceneryObject.
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method throwSceneryObject
	* @param w {Number}
	* @param h {Number}
	* @param jumps {Boolean} Default is true for setting _jumps of the SceneryObject to true.
    * @returns {SceneryObject} 
	*/
    TravelingSceneryThrower.prototype.throwSceneryObject = function(w,h,jumps) {
        var scenery;
		
		if(this.holding == null && this.holdings.length) {
			this._readyNextThrow();
		}
		
        if (this.holding) {
            
            scenery = new tabageos.SceneryObject(this.x+1-1,this.y+1-1,w||this._tw,h||this._th,this._map,null,1, this._deltaTime, this._tw, this._th,this._mapRows,this._mapColumns);
            scenery._jumps = (jumps == 0 ? 0 : 1);
            scenery.playerHoldingThis = this;
            scenery.tileValue = this.holding.value || this.holding.tileValue;
            scenery.tileRect = new tabageos.Rectangle(this.holdingRect.x,this.holdingRect.y,this.holdingRect.width,this.holdingRect.height);

            this._throwHolding();
			
            return scenery;
        }
        return null;
    };
    
    /** 
	*   
	*    Throws holding as a SceneryObjectTraveler
	*    
	* @memberof TravelingSceneryThrower.prototype 
	* @method throwSceneryObjectTraveler
	* @param w {Number}
	* @param h {Number}
	* @param jumps {Boolean} Default is true, the SceneryObjectTraveler thrown will be effected by gravity.
    * @returns {SceneryObjectTraveler} 
	*/
    TravelingSceneryThrower.prototype.throwSceneryObjectTraveler = function(w,h,jumps) {
        var scenery;
		
		if(this.holding == null && this.holdings.length) {
			this._readyNextThrow();
		}
		
        if (this.holding) {
            
            scenery = new tabageos.SceneryObjectTraveler(this.x+1-1,this.y+1-1,w||this._tw,h||this._th,this._map,null,1, this._deltaTime, this._tw, this._th,this._mapRows,this._mapColumns);
            scenery._jumps = (jumps == 0 ? 0 : 1);
            scenery.playerHoldingThis = this;
            scenery.tileValue = this.holding.value || this.holding.tileValue;
            scenery.tileRect = new tabageos.Rectangle(this.holdingRect.x,this.holdingRect.y,this.holdingRect.width,this.holdingRect.height);

            this._throwHolding();
			
            return scenery;
        }
        return null;
    };
    
    
    tabageos.TravelingSceneryThrower = TravelingSceneryThrower;
})();


(function() { 
	'use strict';
	/**
	* @class TweenMath
	* @classdesc
	*  Used for getting various tweens from point a to point b.
	* 
	*
	* 
	*
	*/
    function TweenMath() {};
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
	TweenMath.LINEAR = "Linear";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.IN = "In";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.OUT = "Out";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.IN_OUT = "In" + "Out";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.IN_BOUNCE = "In" + "Bounce";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.OUT_BOUNCE = "Out" + "Bounce";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.IN_BACK = "In" + "Back";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.OUT_BACK = "Out" + "Back";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.IN_CIRC = "In" + "Circ";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.OUT_CIRC = "Out" + "Circ";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.IN_ELASTIC = "In" + "Elastic";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.OUT_ELASTIC = "Out" + "Elastic";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.IN_LINEAR = "In" + "Linear";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.OUT_LINEAR = "Out" + "Linear";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.IN_SINE = "In" + "Sine";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.OUT_SINE = "Out" + "Sine";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.IN_QUAD = "In" + "Quad";
    /**
	*
	*
	*
	* 
	* @memberof TweenMath
    */
    TweenMath.OUT_QUAD = "Out" + "Quad";
    TweenMath.easeOptions = {
        "Linear": true,
        "InLinear": true,
        "OutLinear": 1,
        "InOutLinear": 1,
        "InElastic": 1,
        "OutElastic": 1,
        "InOutElastic": 1,
        "InQuad": 1,
        "OutQuad": 1,
        "InOutQuad": 1,
        "InBounce": 1,
        "InOutBounce": 1,
        "OutBounce": 1,
        "InCirc": 1,
        "InBack": 1,
        "OutBack": 1,
        "InOutBack": 1,
        "InQuint": 1,
        "OutQuint": 1,
        "InOutQuint": 1,
        "OutCirc": 1,
        "InOutCirc": 1,
        "In": 1,
        "Out": 1,
        "InOut": 1,
        "InSine": 1,
        "OutSine": 1,
        "InOutSine": 1
    }; 
	/**
	* @private
	* 
	*/
    TweenMath._argsers = [0, 0];
	/**
	*
	*
	*
	* The TweenMath.tweenArray method returns an Array that contains the numbers that make up a tween between two numbers.
	* @memberof TweenMath
	* @method tweenArray
    *
	* @param start {Number} The beginning number to start from.
	* @param end {Number} The number to end on.
	* @param interval {Number} The amount of time in seconds that the tween should take.
	* @param [how='Linear'] {String} The type of tween to use. Default is "Linear".
	* @param [loopOptions] {Object} .millisecondRate, default is 1000;  .frameRate, default is 60; .useSeconds, default is 0; 
	* @param [theArray] {Array} You can optionally pass in a pre made Array to use, otherwise a new Array is made.
	*
	* @returns {Array} The Array of numbers that make up the tween. Use a loop to cycle through the numbers and apply them to whatever you want to tween.
	* 
	*/
    TweenMath.tweenArray = function(start, end, interval, how, loopOptions, theArray) {
        var v = theArray || [];
        var si = 0;
        var realHow = "Linear";
        if (TweenMath.easeOptions[how]) {
            realHow = how;
        }
        var ending = end - start;
        tabageos.TweenMath._argsers[0] = ((realHow.indexOf("Back") != -1) ? 1.70158 : 0);
        var millisecondRate = (loopOptions ? loopOptions.millisecondRate || 1000 : 1000);
        var frameRate = (loopOptions ? loopOptions.frameRate || 60 : 60);
        var useSeconds = (loopOptions ? loopOptions.useSeconds || 0 : 0);
        var secondIterations = Math.floor(interval);
        var milliRate = Math.floor(millisecondRate / frameRate);
        var millisecondIterations = (interval / milliRate) >= 1 ? Math.floor(interval / milliRate) : 1;
        var iterations = (useSeconds > 0 ? secondIterations : millisecondIterations);
        for (si = 0; si <= iterations; si++) {
            v[si] = tabageos.RPEase[realHow](si, start, ending, iterations, tabageos.TweenMath._argsers[0], tabageos.TweenMath._argsers[1]);
        }
        return v;
    };
    tabageos.TweenMath = TweenMath;
})();


(function() {
	
	
	
	
	function Utils() {
	
	
	}

	/**
	* Scales the game based on window.innerWidth/Height and gameWidth/Height
	* 
	* @param gameWidth {Number} the width of game game
	* @param gameHeight {Number} the height of the game
	* @param divideScaleXBy {Number} amount to divide the x scale by (1.0 to 1.9)
	* @param divideScaleYBy {Number} amount to divide the y scale by (1.0 to 1.9)
	* @param container {HTMLElement} optional reference to the container div element that holds the game and controller canvas element
	*             if null is passed no resizing happens
	* @param controller  {HTMLCanvasElement} reference to the controller canvas element
	*              (container through the end are optional params)
	* @param showController {Boolean}
	* @param controllerStyle {Number} 1 = 'basicController', 2 = 'directionalsController' or you can pass your own String.
	*                   sets the controllers canvas elements style id. (see ControllerPad.css and ControllerPad.show())
	*  @param dontPositionController {Boolean} optional if you have placed the controller in your own specific way.
	*                           Otherwise the controllers canvas elements style top will be set as controller.y and the left as controller.x.
	*  @param cW {Number} controller width  - default is 640 
	*  @param cH {Number} controller height - default is 192 
	*  @param camera {BasicCamera} optional reference to the camera, if not passed only the container gets scaled, generally you don't need to scale the camera.
	*          
    *  @param cmScaleX {Number} camera scale x 	to use if scaling camera.  for example window.innerWidth / camera.width
	*  @param cmScaleY {Number} camera scale y to use if scaling camera.
	*
	*
	*  @method ResizeGame
	*  @memeberof tabageos
	*
	*/
	tabageos.ResizeGame = function(gameWidth, gameHeight, divideScaleXBy, divideScaleYBy, container, controller, showController, controllerStyle, scaleRectReference, dontPositionController, cW, cH, camera, cmScaleX, cmScaleY) {
		
		var scaleX = window.innerWidth / gameWidth;
		var scaleY = window.innerHeight / gameHeight;
		
		if (controller && !showController) {
			controller.hide();
		} else if (showController && controller) { window.console.log("c show "+ cW + "  "+ cH);
			controller.show(cW || 640, cH || 192, controllerStyle || 1);
		}
		
		if (container) {
			container.style.transformOrigin = "0 0";
			container.style.transform = "scale(" + (divideScaleXBy ? scaleX / divideScaleXBy : 1) + "," + (divideScaleYBy ? scaleY / divideScaleYBy : 1) + ")";
			var scaleRect = container.getBoundingClientRect();
			
			if(camera) {
				camera.layerToRender.canvas.style.transformOrigin = "0 0";
				camera.layerToRender.canvas.style.transform = "scale(" + (divideScaleXBy ? cmScaleX / divideScaleXBy : 1) + "," + (divideScaleYBy ? cmScaleY / divideScaleYBy : 1) + ")";
			}
			
			if(scaleRectReference) {
				scaleRectReference.width = scaleRect.width;
				scaleRectReference.height = scaleRect.height;
			}
			
			tabageos.MouseController.defineMousePositionOffset(gameWidth, gameHeight, scaleRect.width, scaleRect.height);
		}
	};

	/**
	*
	*  Trys to determine if a touch device is being used.
	*  If the browser is an Edge browser an actual touch has to happen before this would return true.
	*  On Chrome and Firefox this returns true on touch devices and in dev tools.
	*
	* @method seekTouch
	* @memeberof tabageos
	*
	*/
	tabageos.seekTouch = function() {
		var basic =  ('ontouchstart'in window ? 1 : (navigator.maxTouchPoints ? 1 : 0));
		tabageos._edge = window.navigator.userAgent.toLowerCase().indexOf("edg") != -1;
		if(tabageos._edge) basic = false;//for edge we assume no touch, but right when they do 'touch' the touch controller should then show.
		//so on endge, start button must be actually 'touched' for touch.
		if(!tabageos._touched) {
			window.removeEventListener('pointerdown', tabageos.getPointerType, false);
			window.addEventListener('pointerdown', tabageos.getPointerType, false);//get true modern touch
		}
		return tabageos._touched || basic;
	};
	
	
	tabageos.getPointerType = function(e) {
		window.removeEventListener('pointerdown', tabageos.getPointerType, false);
		var result = e.pointerType && e.pointerType == 'touch' ? 1 : 0;
		
		if(!result) {
			
			if(tabageos.GameSkeleton.game && tabageos.GameSkeleton.game.controller) {
				tabageos.GameSkeleton.game.controller.hide();
			}
		}
		
		tabageos._touched = result;
		
		if(result && tabageos.GameSkeleton.game) {
			tabageos.GameSkeleton.game.__instanceBasicTwoLayerResize();//will seekTouch again and potentially show the controller
		}
	};
	tabageos._pointerEvents = function() {
		return window.PointerEvent ? 1 : 0;
	};
	/**
	*
	*
	* Bitwsie combine two numbers.
	* Use tabagos.getAFromCombined and tabageos.getBFromCombined to get the numbers back.
	*
	* @method combineTwoNumbers
	* @memeberof tabageos
	* @param a {Number} The first number
	* @param b {Number} The second number
	*
	* @returns {Number}
	*/
	tabageos.combineTwoNumbers = function(a,b) {
		return a << 16 | b;
	};
	/**
	*
	*
	* Returns the first number in a bitwise combined number pair.
	* @method getAFromCombined
	* @memeberof tabageos
	* @param num {Number} The bitwise combined number pair.
	*
	* @returns {Number}
	*/
	tabageos.getAFromCombined = function(num) {
		return num >> 16;
	};
	/**
	*
	*
	* Returns the second number in a bitwise combined number pair.
	*
	*
	*  For example, var combined = tabageos.combineTwoNumbers(1,27)
	*    var twentySeven = tabageos.getBFromCombined(combined)
	*
	* @method getBFromCombined
	* @memeberof tabageos
	*
	* @param num {Number} The bitwise combined number pair.
	*
	* @returns {Number}
	*/
	tabageos.getBFromCombined = function(num) {
		return num & 0xFFFF;
	};
	tabageos.splitNumberAtDecimal = function(num, direction) {
		var absnum = Math.abs(num);
		var fnum = Math.floor(absnum);
		if(direction === 1) {
			return fnum * (num < 0 ? -1 : 1);
		}
		var thounum = Math.round( (absnum - fnum) * 1000 );
		var hunnum = Math.round( (absnum - fnum) * 100 ); 
		var tennum = Math.round( (absnum - fnum) * 10 );
		
		return fnum+(tennum/10) === absnum ? tennum : ( (fnum+(hunnum/100) <= absnum + .001 && fnum+(hunnum/100) >= absnum) ? hunnum : thounum );
		
	};
	tabageos.stringSplitNumberAtDecimal = function(num, direction) {
		var absnum = Math.abs(num);
		var fnum = Math.floor(absnum);
		if(direction === 1) {
			return fnum * (num < 0 ? -1 : 1);
		}
		return Number( (num+"").split(".")[1] );
	};
	
	/**
	*
	*   tabageos.stringSplitter
	*
	*  Splits a string ntimes amount of times.
	*  The result gets output to the console.
	*
	* @method stringSplitter
	* @memeberof tabageos
	* @param str {string} The String to split
	* @param ntimes {Number} The amount of times to split the string
	* 
	* 
	*
	*/
	tabageos.stringSplitter = function(str, ntimes, log) {
		ntimes = ntimes || 10;
		var wlen = str.length;
		var plen = wlen/ntimes;
		var i = 0;
		for(i;i<ntimes;i++) {	
			window.console.log(str.substr(plen*i,plen));
		}
	};
	/**
	*
	*   tabageos.loadSpriteSheetAndStart
	*
	*  Loads a sprite sheet and then dispatches the given start function.
	*  The sprite sheet loaded becomes the tabageos.GameSkeleton.__sprites offscreen CanvasObject.
	*  You can streamline the loading of your sprite sheet using this method.
	*  These are the steps for streamlining:
	*  1. Turn your sprite sheet into a base64 string (without the 'data:image/base64,' intro part)
	*  2. Use the tabageos.stringSplitter method on the base64 string to split it into up to 10 parts.
	*  3. tabageos.GameSkeleton._str is a static Array ready to hold the parts.
	*      Place each part in order into tabageos.GameSkeleton._str.
	*      For example; tabageos.GameSkeleton._str[1] = "asdfakjhglwehgrlsabc..." tabageos.GameSkeleton._str[3] = "asldjhgasldyasgtd...."; and so on for each of your parts.
	*      They need to be in order but you dont have to start with index 0 and you can skip indexes.
	*   4. With those three steps done, when you call this method your sprite sheet gets constructed pixel by pixel into tabageos.GameSkeleton.__sprites, instead of being loaded as a file.
	*   If your using the GameSkeleton Class then pass "streamline" as the specs.spriteSheetImage value if your going to streamline using this method.
	*   And then inside of your start method passed to this function is when you would contruct your new GameSkeleton extension.
	*   
	*   If you want to do it yourself, or realize the fullness of what is happening during streamlining,
	*   the following otherwise undocumented methods are what are being used:
	*    tabageos.GameSkeleton.__baseToCol turns a base64 (stored as parts in tabageos.GameSkeleton._str) string into an array of rgba color values using PNG-JS which is built into the tbgs_min release.
	*   and then it calls tabageos.GameSkeleton.__buildColors which uses the color values to construct the CanvasObject pixel by pixel.
	*
	*    Streamlining is a memory intensive process, if your sprite sheet is very large you may not be able to rely on streamlining working on low end devices.
	*    For best results your sprite sheet should be 2k to 4k width and height or less and less than 1MB as a .png.
	*
	*
	* @method loadSpriteSheetAndStart
	* @memeberof tabageos
	* @param img {String} The file to load, include the full path if its not in the same location as the game index. 
	*					If you are going to streamline your spritesheet this would be a dummy file, loading your file here and streamlining defeats the purpose of streamlining.
	* @param w {Number} The width of your sprite sheet
	* @param h {Number} The height of your sprite sheet
	* @param start {Function} An event handler method to call when loading is complete.
	*							A "GameSkeleton" event will happen on the window when loading is complete and your start method will be the handler.
	*
	*
	*
	*
	* 
	*
	*
	*
	*/
	tabageos.loadSpriteSheetAndStart = function(img, w,h,start) {
		window.addEventListener("GameSkeleton", start, false);
		window.setTimeout( function(e) {
			var sheet = new Image();
			sheet.onload = function(e) {
				var i = 0;
				for(i;i<10;i++) {
					
					if(tabageos.GameSkeleton._str[i]) {
						i = 77; break;
					}
					
				}
				if(i != 77) {
					tabageos.GameSkeleton.__sprites = new tabageos.CanvasObject(null,w,h);
					tabageos.GameSkeleton.__sprites.copyPixels(sheet,new tabageos.Rectangle(0,0,w,h),new tabageos.MoverPoint());
					var ev = document.createEvent("MouseEvents");
					ev.initEvent("GameSkeleton", true, true);
					window.dispatchEvent(ev);
				} else {
					var ai = tabageos.GameSkeleton._str;
					tabageos.GameSkeleton.__baseToCol( w,h, ai[0]+ai[1]+ai[2]+ai[3]+ai[4]+ai[5]+ai[6]+ai[7]+ai[8]+ai[9]  );
				}
			}; sheet.src = img;
		}, 700 ); 
	};


})();
(function() { 
	'use strict';
    /** 
    *
    * @class WayDeterminer
	*   @classdesc
    *    A Class for pixel level collision detection.
	*    
	*    
	*
	* @param [transparencyColor=0] {Number} The pixel color value denoting clear, default is 0.
	* @param canvasObject {CanvasObject} the CanvasObject to use during wayIsClear calls.
	* @param [arrayOfCanvasObjects]  {Array} optional array of CanvasObjects to use during multipleWaysClear and multipleWaysClearAndRegister
	*  
	*/
    function WayDeterminer(transparencyColor, canvasObject, arrayOfCanvasObjects) {
        WayDeterminer.transColor = transparencyColor;
        this._bmdRef = canvasObject;
        this.multipleBitmapDatas = arrayOfCanvasObjects;
		this._lastBitmapHit = null;
    };
	/** 
	*   
	*    
	*    
	* @memberof WayDeterminer 
	*  
	*/
    WayDeterminer.prototype.constructor = WayDeterminer;
    /** 
	*   
	*    The pixel color value denoting clear pixels, default is 0.
	*    @type Number
    * @static
	* @memberof WayDeterminer 
	*  
	*/
	WayDeterminer.transColor = 0;
     /** 
	*   
	*    The CanvasObject to use during wayIsClear calls.
    *    Whatever CanvasObject is set during construction overrules this value, but this value is not a reference to what was set during construction.
	*    @type CanvasObject
    * @static
	* @memberof WayDeterminer 
	*  
	*/
    WayDeterminer.bitmapData = null;
    /** 
	*   
	*    Set during multipleWaysClearAndRegister
	*    
	* @memberof WayDeterminer 
	*  
	*/
    WayDeterminer.prototype._lastBitmapHit = null;
    /** 
	*   
	*    Set during construction to the CanvasObject you pass.
	*    
	* @memberof WayDeterminer 
	*  
	*/
    WayDeterminer.prototype._bmdRef = null;
    /** 
	*   
	*    Set during construction.
	*    
	* @memberof WayDeterminer 
	*  
	*/
    WayDeterminer.prototype.multipleBitmapDatas = null;
    /** 
	*   
	*    Returns true if the pixel color value in _bmdRef or WayDeterminer.bitmapData at the x y location given matches WayDeterminer.transColor or 0.
	*    
	* @memberof WayDeterminer.prototype 
	* @method wayIsClear
	* @param x {Number} The x location to check
	* @param y {Number} The y location to check
    * @returns {Boolean} 
	*/
    WayDeterminer.prototype.wayIsClear = function(x, y) {
        var bmd = this._bmdRef ? this._bmdRef : WayDeterminer.bitmapData;
        if (!bmd)
            return false;
        var color = bmd.getPixel(x, y);
        if (color == WayDeterminer.transColor || color == 0) {
            return true;
        } else {
            return false;
        }
    };
    /** 
	*   
	*    Returns true if the pixel color value in each CanvasObject in the bitmapDatas Array matchs WayDeterminer.transColor or 0.
	*    
	* @memberof WayDeterminer.prototype 
	* @method multipleWaysClear
	* @param x {Number} The x location to check
	* @param y {Number} The y location to check
	* @param bitmapDatas {Array} Array of CanvasObjects to check, if not set the multipleBitmapDatas property will be used.
    * @returns {Boolean} 
	*/
    WayDeterminer.prototype.multipleWaysClear = function(x, y, bitmapDatas) {
        var result = false;
        var bmd;
        var color;
        var trans;
        var a = bitmapDatas || this.multipleBitmapDatas;
        var i = 0;
        for (i = 0; i < a.length; i++) {
            bmd = a[i];
            color = bmd.getPixel(x, y);
            result = (color == WayDeterminer.transColor || color == 0);
            if (!result)
                break;
        }
        return result;
    };
    /** 
	*   
	*    Checks the x y position on each CanvasObject in the bitmapDatas Array.
    *    Returns true if the pixel color value in each CanvasObject matches WayDeterminer.transColor at the given x y location.
	*    If the way is not clear this method sets _lastBitmapHit to the CanvasObject that was not clear at the location.
    *
	* @memberof WayDeterminer.prototype 
	* @method multipleWaysClearAndRegister
	* @param x {Number} The x location to check
	* @param y {Number} The y location to check
	* @param bitmapDatas {Array} Array of CanvasObjects, if not set the multipleBitmapDatas property will be used.
    * @returns {Boolean} 
	*/
    WayDeterminer.prototype.multipleWaysClearAndRegister = function(x, y, bitmapDatas) {
        var result = false;
        var bmd;
        var color;
        var trans;
        var a = bitmapDatas || this.multipleBitmapDatas;
        var i = 0;
        for (i = 0; i < a.length; i++) {
            bmd = a[i];
            color = bmd.getPixel(x, y);
            result = color == WayDeterminer.transColor;
            if (!result) {
                this._lastBitmapHit = bmd;
                break;
            }
        }
        return result;
    };
    tabageos.WayDeterminer = WayDeterminer;
})();

(function() { 

	'use strict';

    /** 
    *
    *
    * @class WDTraveler
	*  @classdesc
	*    Way Determined Traveler.
	*     WDTraveler > BlittedTraveler > Traveler > TravelerSkeleton.
	* 	  A BlittedTraveler that collides based on a WayDeterminer instance given during construction.
	*    A BlittedTraveler is also a CanvasAnimation.
	* 
	* @param wayDeterminer {WayDeterminer} The WayDeterminer instance to use for collisions
	* @param source {Image} The source image to draw from
	* @param canvasObject {CanvasObject} The CanvasObject to draw to
	* @param [fromRect=null] {Rectangle} A Rectangle defining where to draw from
	* @param [x] {Number} The x position of the WDTraveler
	* @param [y] {Number} The y position of the WDTraveler
	* @param [width] {Number} The width of the WDTraveler
	* @param [height] {Number} The height of the WDTraveler
	* @param [dt=.6666666667]  {Number} delat time, default is tabageos.TimeKeeper._sae 
    *
    * @see BlittedTraveler
	*  
	*/
    function WDTraveler(wayDeterminer, source, canvasObject, fromRect, x, y, width, height, dt) {
		tabageos.TravelerSkeleton.call(this,x,y,width,height);
		tabageos.Traveler.call(this,x,y,width,height);
		tabageos.BlittedTraveler.call(this, source, canvasObject, fromRect, x, y, width, height, dt);
        this.health = 100;
        this._wayDeterminer = wayDeterminer;
        this.init(source, canvasObject, fromRect, x, y, width, height);
		this.ani = 0;
		this.vCheckOffset = 0;
		this.lastAnim = "";
		this.currentAnimation = "";
		this.animationSpecs = {};
		this.animationIndexOrder = null;
		this.fromHeightOffset = 0;
		this.fromWidthOffset = 0;
		this.fromXOffset = 0;
		this.fromYOffset = 0;
		this.hCheckOffsetRight = 0;
		this.hCheckOffset = 0;
		this.blitIndex = 0;
		this._cBB = 0;
		this._throttRef = 0;
		this._inDelay = 0;
		this._cpos = null;
		this._addedPos =null;
		this._deltaTime = dt || tabageos.TimeKeeper._sae;
    };
	/** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.constructor = WDTraveler;
    WDTraveler.prototype = Object.create(tabageos.TravelerSkeleton.prototype);
	Object.assign(WDTraveler.prototype, tabageos.Traveler.prototype, tabageos.BlittedTraveler.prototype);
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.vCheckOffset = 0;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.currentAnimation = "";
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.animationSpecs = {};
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.animationIndexOrder = [];
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.ani = 0;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.lastAnim = "";
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.fromHeightOffset = 0;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.fromWidthOffset = 0;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.fromXOffset = 0;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.fromYOffset = 0;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.hCheckOffsetRight = 0;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.hCheckOffset = 0;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.blitIndex = 0;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.sae = null;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype._wic = null;
	/** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype._cpos = null;
	/** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype._addedPos = null;
    /** 
	*   
	*    The WayDeterminer instance for collisions.
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype._wayDeterminer = null;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype._moveY = null;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype.vCheckOffsetUp = 0;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype._moveX = null;
	/** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype._deltaTime = null;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler.prototype 
	* @method animate
	* @param thrott {Number}
    * 
	*/
    WDTraveler.prototype.animate = function(thrott) {
        var anim = (this.currentAnimation != "" && this.animationSpecs[this.currentAnimation] ? this.currentAnimation : "idle");
        this.blitIndex = this.animationSpecs[anim][0];
        this.animationIndexOrder = this.animationSpecs[anim][1];
        if (this.ani == this.animationIndexOrder.length - 1) {
            this.ani = 0;
        } else {
            this.ani += (thrott||1);
        }
        if (anim != this.lastAnim) {
            this.ani = 0;
            this.currentAnimation = anim;
        }
        this.lastAnim = anim;
        this.fromRect.x = this.animationIndexOrder[this.ani] * (this.width + this.fromXOffset);
        this.fromRect.y = this.blitIndex * (this.height + this.fromYOffset);
        this.fromRect.width = this.width + this.fromWidthOffset;
        this.fromRect.height = this.height + this.fromHeightOffset;
    };
	/** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype._throttRef;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype._cBB;
	/** 
	*   
	*    
	*    
	* @memberof WDTraveler 
	*  
	*/
    WDTraveler.prototype._inDelay = 0;
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler.prototype 
	* @method delayedAnimateAndBlitt
	* @param thrott {Number}
	* @param milliSecondDelay {Number}
	* @param animation {String}
	* @param clearBeforeBlitt {Boolean}
    *  
	*/
    WDTraveler.prototype.delayedAnimateAndBlitt = function(thrott, milliSecondDelay, animation,clearBeforeBlitt) {
        this._inDelay = 1;
        if(animation) {
            this.currentAnimation = animation;
        }
        this._throttRef = thrott || 0;
        this._cBB = clearBeforeBlitt || 0;
        var ref = this;
        window.setTimeout(function(e) { ref._delayedFunction(); }, milliSecondDelay);
    };
    /** 
	*   
	*    @private
	*    
	* @memberof WDTraveler.prototype 
	* @method _delayedFunction
	* @param e 
    * @returns {} 
	*/
    WDTraveler.prototype._delayedFunction = function(e) {
        if(this._inDelay) {
            this.animate(this._throttRef);
            if(this._cBB) {
                this._canvas.context.clearRect(this.x,this.y,this.width,this.height);
            }
            this.blitt();
            this._inDelay = 0;
        }
    };
    /** 
	*   Changes animation based on dY and dX and _veloc.x and y.
	*    
	*    
	* @memberof WDTraveler.prototype 
	* @method basicChangeDirectionAnimation
    * 
	*/
    WDTraveler.prototype.basicChangeDirectionAnimation = function() {
        if (this.dY == -1 && (this._veloc.y >= 1 || this._veloc.y <= -1))
            this.currentAnimation = "up";
        if (this.dX == -1 && (this._veloc.x >= 1 || this._veloc.x <= -1))
            this.currentAnimation = "left";
        if (this.dX == 1 && (this._veloc.x >= 1 || this._veloc.x <= -1))
            this.currentAnimation = "right";
        if (this.dY == 1 && (this._veloc.y >= 1 || this._veloc.y <= -1))
            this.currentAnimation = "down";
    };
	/** 
	*   
	*    
	*    
	* @memberof WDTraveler.prototype 
	* @method getUnreferencedPosition
	* @param addedX 
	* @param addedY 
    * @returns {MoverPoint} 
	*/
    WDTraveler.prototype.getUnreferencedPosition = function(addedX, addedY) {
        if (!this._cpos || !this._addedPos) {
            this._cpos = new tabageos.MoverPoint();
            this._addedPos = new tabageos.MoverPoint();
        }
        this._cpos.x = this.x;
        this._cpos.y = this.y;
        if (addedX || addedY) {
            this._addedPos.x = this.x + (addedX || 0);
            this._addedPos.y = this.y + (addedY || 0)
        }
        return ((addedX || addedY) ? this._addedPos : this._cpos);
    };
    /** 
	*   
	*    Changes the animation based on the params given.
	*    
	* @memberof WDTraveler.prototype 
	* @method changeDirectionAnimation
	* @param left {Boolean}
	* @param right {Boolean}
	* @param up {Boolean}
	* @param down {Boolean}
	* @param keepAniIndex {Boolean{
    *  
	*/
    WDTraveler.prototype.changeDirectionAnimation = function(left, right, up, down, keepAniIndex) {
        
        this.currentAnimation = (up ? "up" : (down ? "down" : "")) + (left ? "left" : (right ? "right" : (((up || down) && this.lastAnim.match("left")) ? "left" : (((up || down) && this.lastAnim.match("right")) ? "right" : ""))));
        if (this.currentAnimation.length <= 0)
            this.currentAnimation = this.lastAnim.replace("idle", "").replace("down", "").replace("up", "") + "idle";
        if (keepAniIndex) {
            this.lastAnim = this.currentAnimation;
        }
    };
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler.prototype 
	* @method getBottomY
    * @returns {Number} 
	*/
    WDTraveler.prototype.getBottomY = function() {
        return this.y + this.height;
    };
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler.prototype 
	* @method getMiddleY
    * @returns {Number} 
	*/
    WDTraveler.prototype.getMiddleY = function() {
        return this.y + (this.height / 2);
    };
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler.prototype 
	* @method getTopY
    * @returns {Number} 
	*/
    WDTraveler.prototype.getTopY = function() {
        return this.y+1-1;
    };
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler.prototype 
	* @method getRightX
    * @returns {Number} 
	*/
    WDTraveler.prototype.getRightX = function() {
        return this.x + this.width;
    };
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler.prototype 
	* @method getMiddleX
    * @returns {Number} 
	*/
    WDTraveler.prototype.getMiddleX = function() {
        return this.x + (this.width / 2);
    };
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler.prototype 
	* @method getLeftX
    * @returns {Number} 
	*/
    WDTraveler.prototype.getLeftX = function() {
        return this.x+1-1;
    };
    /** 
	*   velocity is adjusted using forceApplier,
	*    then landCheckHorizontal and landCheckVertical are used to determine collisions,
	*	 for each direction, if there is no collision velocity is applied to position and x y.
	*    
	*    
	* @memberof WDTraveler.prototype 
	* @method move
    * 
	*/
    WDTraveler.prototype.move = function() {
		
		this.forceApplier.truncate(this.maxForce);
        this.forceApplier.divide(this.mass, 0);
		var newVeloc = this._veloc.add(this.forceApplier.multiply(this._deltaTime,1), 1);
        this.forceApplier.reset();
		newVeloc._length = 0;
        newVeloc._angle = 0;
        newVeloc.truncate(this.maxSpeed);

        var xDirec = this._pos.x + newVeloc.x < this._pos.x ? -1 : 1;
        var yDirec = this._pos.y + newVeloc.y < this._pos.y ? -1 : 1;
        var pNewX = this._pos.x + (newVeloc.x * this._deltaTime);
        var pNewY = this._pos.y + (newVeloc.y * this._deltaTime);
        this._moveX = this.landCheckHorizontal(xDirec, pNewX);
        this._moveY = this.landCheckVertical(yDirec, pNewY);
        if (this._moveX) {
			this._veloc.x = newVeloc.x+1-1;
            this._pos.x = pNewX;
        }
        if (this._moveY) {
			this._veloc.y = newVeloc.y+1-1;
            this._pos.y = pNewY;
        }
        if (this._wallObject)
            this.boundingMethod(this, this._wallObject);
		
        if (this._moveX)
            this.x = this._pos.x+1-1;
        if (this._moveY)
            this.y = this._pos.y+1-1;
    };
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler.prototype 
	* @method landCheckHorizontal
	* @param leftRight 
	* @param pNewX 
    * @returns {Boolean} 
	*/
    WDTraveler.prototype.landCheckHorizontal = function(leftRight, pNewX) {
        var result = 0;
        var toCheck = leftRight == -1 ? this.x - this.hCheckOffset : this.x + this.width + this.hCheckOffsetRight;
        if (this._wayDeterminer.wayIsClear(toCheck, this.getMiddleY())) {
            result = 1;
        }
        return result;
    };
    /** 
	*   
	*    
	*    
	* @memberof WDTraveler.prototype 
	* @method landCheckVertical
	* @param topBottom 
	* @param pNewY 
    * @returns {Boolean} 
	*/
    WDTraveler.prototype.landCheckVertical = function(topBottom, pNewY) {
        var result = 0;
        var toCheck = topBottom == -1 ? this.getTopY() - this.vCheckOffsetUp : this.getBottomY() + this.vCheckOffset;
        if (this._wayDeterminer.wayIsClear(this.getMiddleX(), toCheck)) {
            result = 1;
        }
        return result;
    };
    tabageos.WDTraveler = WDTraveler;
})();


(function() { 
	
	
	/** 
	*   
	*    
	*    
	* @class WeaponHoldingAttacker
    * @classdesc 
    *
    *   A BasicPlatformer the can hack and slash with a set of weapon animations.
    *   Set up to let a user be able to repeatedly mash the button to cause repeated fast attacks, or hold the button for slower steady attacks.
    *   Also ready for duck and dash animation and functionality.
    *
	* @param x {Number}
	* @param y {Number}
	* @param width {Number}
	* @param height {Number}
	* @param map {Object}
	* @param ca {Object}
	* @param dontCloneMap {Object}
	* @param dt {Object}
	* @param tWidth {Object}
	* @param tHeight {Object}
	* @param mr {Object}
	* @param mc {Object}
	* @param mapOfOriginalTiles {Object}
	* @param controller {Object}
	* @param ladderTileValue {Object}
	* @param attackButtonOneKeyCode {Object}
	* @param attackButtonTwoKeyCode {Object} 
	*  
	*/
    function WeaponHoldingAttacker(x,y,width,height, map, ca,dontCloneMap,dt,tWidth,tHeight,mr,mc, mapOfOriginalTiles, controller, ladderTileValue, attackButtonOneKeyCode, attackButtonTwoKeyCode) {
		tabageos.TravelerSkeleton.call(this, x, y, width, height);
		tabageos.MapTraveler.call(this,x,y,width,height, map,ca,dontCloneMap, dt, tWidth,tHeight, mr, mc);
		tabageos.TravelingSceneryThrower.call(this, x,y, width, height, map, ca, dontCloneMap, dt, tWidth, tHeight, mr, mc);
		tabageos.BasicPlatformer.call(this, x,y, width, height, map, ca, dontCloneMap, dt, tWidth, tHeight, mr, mc, mapOfOriginalTiles, controller, ladderTileValue);
		this.width = width || 0;
			this.height = height || 0;
			this._middlePoint = new tabageos.MoverPoint();
			this._pos = new tabageos.MoverPoint(x,y);
			this._veloc = new tabageos.MoverPoint(0,0);
			this._lastVeloc = new tabageos.MoverPoint(0,0);
			this._lastPos = new tabageos.MoverPoint(x,y);
			this._deltaTime = dt || tabageos.TimeKeeper._sae;
			this._map = dontCloneMap ? map : tabageos.BlitMath.cloneMultiArray(map);
			this._state = 1;
			this.x = x || 0;
			this.y = y || 0;
			this._rect = new tabageos.Rectangle(this.x,this.y,this.width,this.height);
			this._canvasAnimation = ca || null;
			this._tH = tHeight || this.height;
			this._tW = tWidth || this.width;
			this._outAltered = new tabageos.MoverPoint();
			this.holdingRect = new tabageos.Rectangle(0,0,width,height);
			this.holdingOffsetX = 1;
			this.holdingOffsetY = 3;
			this._jumps = 1;
			this.easeProximity = 7;
			this._checkHelper = new tabageos.MoverPoint();
			this.forceApplier = new tabageos.MoverPoint();
			this.forceHolder = new tabageos.MoverPoint();
			this._w = width || 0;
			this._h = height || 0;
			this.wanderOffset = new tabageos.MoverPoint(0,0);
			this.blankMO = new tabageos.MoverPoint();
			this._eventDispatcher = new tabageos.EventDispatcher();
			this.holdings = [];
			this._holdingHelperRect = new tabageos.Rectangle(0,0,0,0);
			this.personalSpace = this.width * 9;
			this._hpt = new tabageos.MoverPoint();
			this._jumpSpeed = 10;
			this.throwStrength = 10;
			if(this._canvasAnimation) {
				this._canvasAnimation.addedAnimationChanges = this._addedToChangeDirectionAni;
				this._canvasAnimation._playerRef = this;
			}
			this._controllerRef = controller;
			this.tileMap = mapOfOriginalTiles;
			this.ladderValue = ladderTileValue;
			
			this._attackB = attackButtonOneKeyCode || 0;
			this._attackC = attackButtonTwoKeyCode || 0;
			if(this._attackB) {
				this._controllerRef.basicArrows.b = this._attackB;
				this._controllerRef.basicWasd.b = this._attackB;
			}
			if(this._attackC[0]) {
				this._comboC = 1;
				this._controllerRef.basicArrows.c = this._attackC[0];
				this._controllerRef.basicWasd.c = this._attackC[0];
			} else if(this._attackC) {
				this._controllerRef.basicArrows.c = this._attackC;
				this._controllerRef.basicWasd.c = this._attackC;
			}
	};
	
	
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype.constructor = WeaponHoldingAttacker;
	WeaponHoldingAttacker.prototype = Object.create(tabageos.TravelerSkeleton.prototype);
	Object.assign(WeaponHoldingAttacker.prototype, tabageos.MapTraveler.prototype, tabageos.TravelingSceneryThrower.prototype, tabageos.BasicPlatformer.prototype);
	
	
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype.crouchHeightOffset = 16;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype.crouchWidthOffset = 32;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype.attackWidthOffset = 32;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype.attackHeightOffset = 32;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype.attackTwoWidthOffset = 32;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype.attackTwoHeightOffset = 32;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype._alternate = 0;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype._controllerRef = null;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype._fwoHold = -9999;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype._fhoHold = -9999;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype._attackB = 0;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype._attackC = 0;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype._comboC = 0;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype.hurt = 0;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype.attackTwoName = "attack2";
	
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype.atApexOfAttack = 0;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype._dashTime = 0;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype.dashSpeed = 10;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype._originalWalkSpeed = -7777;
	/** 
	*   
	*    
	*    
	* @memberof WeaponHoldingAttacker 
	*  
	*/
    WeaponHoldingAttacker.prototype.totalDashTime = 500;
	
    
    
    /**
    *
    * Call this method if your WeaponHoldingAttacker is going to be top down.
    * _addedToChangeDirectionAniRpger will be used instead of _addedToChangeDirectionAni
    * @method setupForTopDown
    * @memberof WeaponHoldingAttacker.prototype 
    *
    */
    WeaponHoldingAttacker.prototype.setupForTopDown = function() {
		this.crouchHeightOffset = 0;
		this.crouchWidthOffset = 0;
		if(this._canvasAnimation) {
			this._canvasAnimation.addedAnimationChanges = this._addedToChangeDirectionAniRpger;
		}
	};
	
	/**
    *
    *
    *
    * @method _addedToChangeDirectionAniRpger
    * @memberof WeaponHoldingAttacker.prototype 
    *
    */
	WeaponHoldingAttacker.prototype._addedToChangeDirectionAniRpger = function(left, right, up, down, keepAniIndex, noIdle) {
		
		var canidirec;var attal;
		var btns = this._playerRef._controllerRef.buttons;
		canidirec = (this.currentAnimation.indexOf("right") != -1 ? "right" : (this.currentAnimation.indexOf("left") != -1 ? "left" : (this.currentAnimation.indexOf("down") != -1 ? "down" : (this.currentAnimation.indexOf("up") != -1 ? "up" : "")   )) );
		
	
		if(this._playerRef._fwoHold >= 0) {
				this.fromHeightOffset = this._playerRef._fhoHold+1-1;
				this.fromWidthOffset = this._playerRef._fwoHold+1-1;
		}
		
		this.currentAnimation = this.currentAnimation.replace("idle","");
		
		if(btns.down && (btns.right || btns.left)) {
			
			if(this.currentAnimation.indexOf("down") != -1) {
				this.currentAnimation = this.currentAnimation.replace("down","");
			}
			if(this._playerRef._fwoHold >= 0) {
				this.fromHeightOffset = this._playerRef._fhoHold+1-1;
				this.fromWidthOffset = this._playerRef._fwoHold+1-1;
			}
		}
		
		if(btns.down && !btns.left && !left && !right && !btns.right && !up && this._playerRef.onLadder == 0) {
			
			this.currentAnimation = "down";
			if(this._playerRef._fwoHold == -9999) {
				this._playerRef._fwoHold = this.fromWidthOffset+1-1;
			}
			if(this._playerRef._fhoHold == -9999) {
				this._playerRef._fhoHold = this.fromHeightOffset+1-1;
			}
			this.fromHeightOffset = this._playerRef.crouchHeightOffset+1-1;
			this.fromWidthOffset = this._playerRef.crouchWidthOffset+1-1;
			
		} else {
			
			
		}
		
		if(this.currentAnimation.indexOf("down") == -1) {
			
			if(this._playerRef._fwoHold != -9999 && this.fromWidthOffset == this._playerRef.crouchWidthOffset && this.fromHeightOffset == this._playerRef.crouchHeightOffset) {
				
				this.fromWidthOffset = this._playerRef._fwoHold+1-1;
				this.fromHeightOffset = this._playerRef._fhoHold+1-1;
				
			}
		}
		
		
		if(btns.up && (btns.right || btns.left)) {
			
			if(this.currentAnimation.indexOf("up") != -1) {
				this.currentAnimation = this.currentAnimation.replace("up","");
			}
			if(this._playerRef._fwoHold >= 0) {
				this.fromHeightOffset = this._playerRef._fhoHold+1-1;
				this.fromWidthOffset = this._playerRef._fwoHold+1-1;
			}
		}
		
		if(btns.up && !btns.left && !left && !right && !btns.right && !down ) {
			
			this.currentAnimation = "up";
			if(this._playerRef._fwoHold == -9999) {
				this._playerRef._fwoHold = this.fromWidthOffset+1-1;
			}
			if(this._playerRef._fhoHold == -9999) {
				this._playerRef._fhoHold = this.fromHeightOffset+1-1;
			}
			
			
		} else {
			
			
		}
		
		
		if(btns.b && !left && !right && !up && this.currentAnimation.indexOf("attack") == -1 && this.currentAnimation != "climb") {
			
			this.currentAnimation = "attack"+canidirec;
			if(this._playerRef._fwoHold == -9999) {
				this._playerRef._fwoHold = this.fromWidthOffset+1-1;
			}
			if(this._playerRef._fhoHold == -9999) {
				this._playerRef._fhoHold = this.fromHeightOffset+1-1;
			}
			this.fromHeightOffset = this._playerRef.attackHeightOffset+1-1;
			this.fromWidthOffset = this._playerRef.attackWidthOffset+1-1;
			this._playerRef.atApexOfAttack = 0;
			
		} else {
			
			if(this.currentAnimation.indexOf("attack") != -1 && this.finishedCurrentAnimation()) {
				if( this._playerRef._fhoHold != -9999) {
					this.fromHeightOffset = this._playerRef._fhoHold+1-1;
					this.fromWidthOffset = this._playerRef._fwoHold+1-1;
				}
				this.currentAnimation = this.currentAnimation.replace("attack","");
				this._playerRef.atApexOfAttack = 0;
				this._playerRef._alternate = 0;
				
			} else if (btns.b && this.currentAnimation.indexOf("attack") != -1 && !this.finishedCurrentAnimation()) {
				this.fromHeightOffset = this._playerRef.attackHeightOffset+1-1;
				this.fromWidthOffset = this._playerRef.attackWidthOffset+1-1;
				
				if(this._playerRef._alternate == 0) {
					attal = this.animationSpecs[this.currentAnimation][1].length;
					
					if(this.ani > (attal/4) + 2) { this.ani = attal/4; this._playerRef.atApexOfAttack = 1; }
					if (this.ani < attal/4) { this.ani++; }
					
					
					
					this._playerRef._alternate = 1;
				} else {
					
					attal = this.animationSpecs[this.currentAnimation][1].length;
					
					if(this.ani > (attal/4) + 2) { this._playerRef.atApexOfAttack = 1; }
					
					
				}
			} else if (!btns.b && this.currentAnimation.indexOf("attack") != -1 && !this.finishedCurrentAnimation()) {
				this.fromHeightOffset = this._playerRef.attackHeightOffset+1-1;
				this.fromWidthOffset = this._playerRef.attackWidthOffset+1-1;
				if(this._playerRef._alternate == 1) {
					this._playerRef._alternate = 0;
				} else {
					
					attal = this.animationSpecs[this.currentAnimation][1].length;
					if(this.ani > (attal/4) + 2) { this._playerRef.atApexOfAttack = 1; }
					
				}
				
			}
			
		}
		
		if(!this._playerRef._comboC && btns.c && this.currentAnimation.indexOf(this._playerRef.attackTwoName) == -1 && this.currentAnimation != "climb") {
			
			
			this.currentAnimation = this._playerRef.attackTwoName+canidirec;
			if(this._playerRef._fwoHold == -9999) {
				this._playerRef._fwoHold = this.fromWidthOffset+1-1;
			}
			if(this._playerRef._fhoHold == -9999) {
				this._playerRef._fhoHold = this.fromHeightOffset+1-1;
			}
			this.fromHeightOffset = this._playerRef.attackTwoHeightOffset+1-1;
			this.fromWidthOffset = this._playerRef.attackTwoWidthOffset+1-1;
			
		} else {
			
			if(!btns.c && this.currentAnimation.indexOf(this._playerRef.attackTwoName) != -1) {
				
				this.currentAnimation = this.currentAnimation.replace(this._playerRef.attackTwoName, "");
				if(this._playerRef._fwoHold >= 0) {
					this.fromHeightOffset = this._playerRef._fhoHold+1-1;
					this.fromWidthOffset = this._playerRef._fwoHold+1-1;
				}
				
			}
			
			
			
		}
		
		
		
		if(this.currentAnimation.indexOf(this._playerRef.attackTwoName) == -1 && this.currentAnimation.indexOf("attack") == -1 && !btns.left && !btns.right && !btns.up && !btns.down && !left && !up && !right && !down) {
			
			
			this.currentAnimation = this.currentAnimation + "idle";
			if(this._playerRef._fwoHold >= 0) {
				this.fromHeightOffset = this._playerRef._fhoHold+1-1;
				this.fromWidthOffset = this._playerRef._fwoHold+1-1;
			}
		}
		
		
		//window.console.log(this.currentAnimation  + "  " + this._playerRef._fwoHold + "  " + this.fromHeightOffset);
		
	};
    
    
	
	/** 
	*   
	*    Augment tp changeDirectionAnimation. The CanvasAnimation for this class will be calling this method in addition to the normal CanvasAnimation.changeDirectionAnimation.
	*    
	* @memberof WeaponHoldingAttacker.prototype 
	* @method _addedToChangeDirectionAni
	* @param left 
	* @param right 
	* @param up 
	* @param down 
	* @param keepAniIndex 
	* @param noIdle 
    * 
	*/
    WeaponHoldingAttacker.prototype._addedToChangeDirectionAni = function(left, right, up, down, keepAniIndex, noIdle) {
		
		
		
		
		
		var canidirec;var attal;
		var btns = this._playerRef._controllerRef.buttons;
		canidirec = (this.currentAnimation.indexOf("right") != -1 ? "right" : (this.currentAnimation.indexOf("left") != -1 ? "left" : (this._playerRef._lastVeloc.x > 0 ? "right" : "left")) );
		
		if(btns.down && (btns.right || btns.left)) {
			
			if(this.currentAnimation.indexOf("duck") != -1) {
				this.currentAnimation = this.currentAnimation.replace("duck","");
			}
			if(this._playerRef._fwoHold > 0) {
				this.fromHeightOffset = this._playerRef._fhoHold+1-1;
				this.fromWidthOffset = this._playerRef._fwoHold+1-1;
			}
		}
		
		if(btns.down && !btns.left && !left && !right && !btns.right && !up && this._playerRef.onLadder == 0) {
			
			this.currentAnimation = "duck"+canidirec;
			if(this._playerRef._fwoHold == -9999) {
				this._playerRef._fwoHold = this.fromWidthOffset+1-1;
			}
			if(this._playerRef._fhoHold == -9999) {
				this._playerRef._fhoHold = this.fromHeightOffset+1-1;
			}
			this.fromHeightOffset = this._playerRef.crouchHeightOffset+1-1;
			this.fromWidthOffset = this._playerRef.crouchWidthOffset+1-1;
			
		} else {
			
			if(this.currentAnimation.indexOf("duck") != -1) {
				this.fromHeightOffset = this._playerRef._fhoHold+1-1;
				this.fromWidthOffset = this._playerRef._fwoHold+1-1;
				this.currentAnimation = this.currentAnimation.replace("duck","");
			}
		}
		
		if(this.currentAnimation.indexOf("duck") == -1) {
			
			if(this.fromWidthOffset == this._playerRef.crouchWidthOffset && this.fromHeightOffset == this._playerRef.crouchHeightOffset) {
				
				this.fromWidthOffset = this._playerRef._fwoHold+1-1;
				this.fromHeightOffset = this._playerRef._fhoHold+1-1;
				
			}
		}
		
		if(btns.b && !left && !right && !up && this.currentAnimation.indexOf("attack") == -1 && this.currentAnimation != "climb") {
			
			this.currentAnimation = "attack"+canidirec;
			if(this._playerRef._fwoHold == -9999) {
				this._playerRef._fwoHold = this.fromWidthOffset+1-1;
			}
			if(this._playerRef._fhoHold == -9999) {
				this._playerRef._fhoHold = this.fromHeightOffset+1-1;
			}
			this.fromHeightOffset = this._playerRef.attackWidthOffset+1-1;
			this.fromWidthOffset = this._playerRef.attackHeightOffset+1-1;
			this._playerRef.atApexOfAttack = 0;
			
		} else {
			
			if(this.currentAnimation.indexOf("attack") != -1 && this.finishedCurrentAnimation()) {
				this.fromHeightOffset = this._playerRef._fhoHold+1-1;
				this.fromWidthOffset = this._playerRef._fwoHold+1-1;
				this.currentAnimation = this.currentAnimation.replace("attack","");
				this._playerRef.atApexOfAttack = 0;
				this._playerRef._alternate = 0;
				
			} else if (btns.b && this.currentAnimation.indexOf("attack") != -1 && !this.finishedCurrentAnimation()) {
				
				
				if(this._playerRef._alternate == 0) {
					attal = this.animationSpecs[this.currentAnimation][1].length;
					
					if(this.ani > (attal/4) + 2) { this.ani = attal/4; this._playerRef.atApexOfAttack = 1; }
					if (this.ani < attal/4) { this.ani++; }
					
					
					
					this._playerRef._alternate = 1;
				} else {
					
					attal = this.animationSpecs[this.currentAnimation][1].length;
					
					if(this.ani > (attal/4) + 2) { this._playerRef.atApexOfAttack = 1; }
					
					
				}
			} else if (!btns.b && this.currentAnimation.indexOf("attack") != -1 && !this.finishedCurrentAnimation()) {
				if(this._playerRef._alternate == 1) {
					this._playerRef._alternate = 0;
				} else {
					
					attal = this.animationSpecs[this.currentAnimation][1].length;
					if(this.ani > (attal/4) + 2) { this._playerRef.atApexOfAttack = 1; }
					
				}
				
			}
			
		}
		
		if(!this._playerRef._comboC && btns.c && this.currentAnimation.indexOf(this._playerRef.attackTwoName) == -1 && this.currentAnimation != "climb") {
			
			
			this.currentAnimation = this._playerRef.attackTwoName+canidirec;
			if(this._playerRef._fwoHold == -9999) {
				this._playerRef._fwoHold = this.fromWidthOffset+1-1;
			}
			if(this._playerRef._fhoHold == -9999) {
				this._playerRef._fhoHold = this.fromHeightOffset+1-1;
			}
			this.fromHeightOffset = this._playerRef.attackTwoWidthOffset+1-1;
			this.fromWidthOffset = this._playerRef.attackTwoHeightOffset+1-1;
			
		}
		
		if(btns.c && this._playerRef._dashTime <= this._playerRef.totalDashTime && this.currentAnimation.indexOf("dash") != -1) {
			
			if(this._playerRef._originalWalkSpeed == -7777) {
				this._playerRef._originalWalkSpeed = this._playerRef._walkSpeed +1-1;
			}
			this._playerRef._walkSpeed = this._playerRef.dashSpeed+1-1;
			this._playerRef._dashTime += 33.3;
			
			
		
		}
		if(this._playerRef._dashTime > this._playerRef.totalDashTime && this.currentAnimation.indexOf("dash") != -1  || (!btns.c && this.currentAnimation.indexOf("dash") != -1) ) {
			if(!btns.c) {
						
				this._playerRef._dashTime = 0;
			}
						
			this._playerRef._walkSpeed = this._playerRef._originalWalkSpeed;
			this.currentAnimation = this.currentAnimation.replace("dash", "");
		}
		if(this.currentAnimation.indexOf("dash") == -1 && this._playerRef._dashTime > 0) {
						
			if(!btns.c) {
						
				this._playerRef._dashTime = 0;
			}
			if(this._playerRef._originalWalkSpeed == -7777) {
				this._playerRef._originalWalkSpeed = this._playerRef._walkSpeed +1-1;
			}
			this._playerRef._walkSpeed = this._playerRef._originalWalkSpeed+1-1;
						
		}
		
		
		
		
		if(this._playerRef.ladderValue) {
			
			this._playerRef.getValuesOfCloseTiles();
			var qpr = this._playerRef;
			if(!up && !left && !right && qpr.valuesMatch(qpr.tileDown, qpr.ladderValue) && !qpr.valuesMatch(qpr.tileUp, qpr.ladderValue)) {
				this._playerRef._veloc.y = 0;
				this._playerRef._grounded = 1;this._playerRef._state = 1;
			}
			if(btns.up && (qpr.valuesMatch(qpr.tileUp, qpr.ladderValue) ||  qpr.valuesMatch(qpr.tile, qpr.ladderValue) ||  qpr.valuesMatch(qpr.tileDown, qpr.ladderValue)) ) {
				this._playerRef._veloc.y = 0;
				this._playerRef._pos.y -= 1;
				this._playerRef.y -= 1;
				this._playerRef.onLadder = 1;
				if(this.animationSpecs.climb) { 
					this.currentAnimation = "climb";
				}
			} else if( (btns.down) && qpr.valuesMatch(qpr.tileDown, qpr.ladderValue) ) {
				this._playerRef._veloc.y = 0;
				this._playerRef._pos.y += 1;
				this._playerRef.y += 1;
				this._playerRef.onLadder = 1;
				if(this.animationSpecs.climb) {
					this.currentAnimation = "climb";
				}
			} else {
				this._playerRef.onLadder = 0;
			}
		
		}
		
	};
	
	tabageos.WeaponHoldingAttacker = WeaponHoldingAttacker;
})();













(function() {
    
    /** 
	*   
	*    @classdesc
    *       A setup for a Webgl copyPixels call. This Class is not utilized by the library but exists to show the basics of what would be needed.
    *       
	*    
	* @class WebglRenderer
	* @param canvas 
	* @param context  
	*  
	*/
    function WebglRenderer(canvas, context) {
        if(canvas && !context) {
            this.context = canvas.getContext("webgl", {alpha:false, antialias:false, depth:false,stencil:false, preserveDrawingBuffer:true });
        } else {
            this.context = context;
            
        }
        
    }
    
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype.context = null;
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer.prototype 
	* @method getContext
    * @returns {} 
	*/
    WebglRenderer.prototype.getContext = function() {
      return this.context;  
    };
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._program = null;
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._positionLocation = null;
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._texcoordLocation = null;
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._matrixLocation = null;
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._textureMatrixLocation = null;
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._textureLocation = null;
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._positionBuffer = null;
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._positions = [
        0, 0,
        0, 1,
        1, 0,
        1, 0,
        0, 1,
        1, 1,
    ];
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._texcoordBuffer = null;
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._texcoords = [
        0, 0,
        0, 1,
        1, 0,
        1, 0,
        0, 1,
        1, 1,
    ];
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._texture = null;
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._imgWidth = 1;
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._imgHeight = 1;
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer.prototype 
	* @method _assembleProgram
    * @returns {} 
	*/
    WebglRenderer.prototype._assembleProgram = function() {
        
        //this.__injectScripts();
        
        var s1 = this.context.createShader(this.context.VERTEX_SHADER );
        
        this.context.shaderSource(s1, this.__vs());
        this.context.compileShader(s1);
        window.console.log(this.context.getShaderParameter(s1, this.context.COMPILE_STATUS) ? "vShader compiled" : "shader compile error");
        var s2 = this.context.createShader(this.context.FRAGMENT_SHADER );
        
        this.context.shaderSource(s2, this.__fs());
        this.context.compileShader(s2);
        window.console.log(this.context.getShaderParameter(s2, this.context.COMPILE_STATUS) ? "fShader compiled" : "f shader compile error");
        
        this._program = this.context.createProgram();
        this.context.attachShader(this._program, s1);
        this.context.attachShader(this._program, s2);
        
        this.context.linkProgram(this._program);
        
        window.console.log(  this.context.getProgramParameter(this._program, this.context.LINK_STATUS)  ? "program linked" : "program link error");
        
    };
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer.prototype 
	* @method readyWebglProgram
    * @returns {} 
	*/
    WebglRenderer.prototype.readyWebglProgram = function() {
      
      if(!this._program) {
            this._assembleProgram();
            this._positionLocation = this.context.getAttribLocation(this._program, "a_position");
            this._texcoordLocation = this.context.getAttribLocation(this._program, "a_texcoord");
            this._matrixLocation = this.context.getUniformLocation(this._program, "u_matrix");
            this._textureMatrixLocation = this.context.getUniformLocation(this._program, "u_textureMatrix");
            this._textureLocation = this.context.getUniformLocation(this._program, "u_texture");
            this._positionBuffer = this.context.createBuffer();
            this.context.bindBuffer(this.context.ARRAY_BUFFER, this._positionBuffer);
            this.context.bufferData(this.context.ARRAY_BUFFER, new Float32Array(this._positions), this.context.STATIC_DRAW);
            this._texcoordBuffer = this.context.createBuffer();
            this.context.bindBuffer(this.context.ARRAY_BUFFER, this._texcoordBuffer);
            this.context.bufferData(this.context.ARRAY_BUFFER, new Float32Array(this._texcoords), this.context.STATIC_DRAW);
      }
    };
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer.prototype 
	* @method _bindImageForWebglCopyPixels
	* @param img 
	* @param webglContext 
    * @returns {} 
	*/
    WebglRenderer.prototype._bindImageForWebglCopyPixels = function(img, webglContext) {
        if(!webglContext) { webglContext = this.context; }
        this._texture = webglContext.createTexture();
        webglContext.bindTexture(webglContext.TEXTURE_2D, this._texture);
    
        webglContext.texImage2D(webglContext.TEXTURE_2D, 0, webglContext.RGBA, 1, 1, 0, webglContext.RGBA, webglContext.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));

        webglContext.texParameteri(webglContext.TEXTURE_2D, webglContext.TEXTURE_WRAP_S, webglContext.CLAMP_TO_EDGE);
        webglContext.texParameteri(webglContext.TEXTURE_2D, webglContext.TEXTURE_WRAP_T, webglContext.CLAMP_TO_EDGE);
        webglContext.texParameteri(webglContext.TEXTURE_2D, webglContext.TEXTURE_MIN_FILTER, webglContext.LINEAR);
        
        webglContext.bindTexture(webglContext.TEXTURE_2D, this._texture);
        webglContext.texImage2D(webglContext.TEXTURE_2D, 0, webglContext.RGBA, webglContext.RGBA, webglContext.UNSIGNED_BYTE, img);
        
        this._imgWidth = img.width;
        this._imgHeight = img.height;
        
    };
    
    WebglRenderer.__scripts = 0;
    
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer.prototype 
	* @method __injectScripts
    * @returns {} 
	*/
    WebglRenderer.prototype.__injectScripts = function() {
        
        if(!WebglRenderer.__scripts) {
        
          var vs = document.createElement("script");
            vs.setAttribute("type", "x-shader/x-vertex");
            vs.setAttribute("id", "vsh");
            vs.text = "attribute vec4 a_position;  attribute vec2 a_texcoord;  uniform mat4 u_matrix;  uniform mat4 u_textureMatrix;  varying vec2 v_texcoord; void main() { gl_Position = u_matrix * a_position; v_texcoord = (u_textureMatrix * vec4(a_texcoord, 0, 1)).xy; }";
            document.getElementsByTagName("body")[0].appendChild(vs);

          var fs = document.createElement("script");
            fs.setAttribute("type", "x-shader/x-fragment");
            fs.setAttribute("id", "fsh");
            fs.text = "precision mediump float;  varying vec2 v_texcoord;  uniform sampler2D u_texture;  void main() {   gl_FragColor = texture2D(u_texture, v_texcoord); }";
            document.getElementsByTagName("body")[0].appendChild(fs);

            WebglRenderer.__scripts = 1;
        }
        
    };
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer.prototype 
	* @method __vs
    * @returns {} 
	*/
    WebglRenderer.prototype.__vs = function() {
        return `precision mediump float;
        attribute vec4 a_position;

        attribute vec2 a_texcoord;

        uniform mat4 u_matrix;

        uniform mat4 u_textureMatrix;

        varying vec2 v_texcoord;

        void main() {
           gl_Position = u_matrix * a_position;
           v_texcoord = (u_textureMatrix * vec4(a_texcoord, 0, 1)).xy;
        }`;
        
    };
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer.prototype 
	* @method __fs
    * @returns {} 
	*/
    WebglRenderer.prototype.__fs = function() {
        return `precision mediump float;

        varying vec2 v_texcoord;

        uniform sampler2D u_texture;

        void main() {
           gl_FragColor = texture2D(u_texture, v_texcoord);
        }`;
        
    };
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._orA = new Float32Array(16);
    
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer.prototype 
	* @method _orthographic
	* @param left 
	* @param right 
	* @param bottom 
	* @param top 
	* @param near 
	* @param far 
	* @param dst 
    * @returns {} 
	*/
    WebglRenderer.prototype._orthographic = function(left, right, bottom, top, near, far, dst) {
            dst = dst || this._orA;

            dst[ 0] = 2 / (right - left);
            dst[ 1] = 0;
            dst[ 2] = 0;
            dst[ 3] = 0;
            dst[ 4] = 0;
            dst[ 5] = 2 / (top - bottom);
            dst[ 6] = 0;
            dst[ 7] = 0;
            dst[ 8] = 0;
            dst[ 9] = 0;
            dst[10] = 2 / (near - far);
            dst[11] = 0;
            dst[12] = (left + right) / (left - right);
            dst[13] = (bottom + top) / (bottom - top);
            dst[14] = (near + far) / (near - far);
            dst[15] = 1;

            return dst;
    };
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._trA = new Float32Array(16);
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer.prototype 
	* @method _translate
	* @param m 
	* @param tx 
	* @param ty 
	* @param tz 
	* @param dst 
    * @returns {} 
	*/
    WebglRenderer.prototype._translate = function(m, tx, ty, tz, dst) {
        
        dst = dst || this._trA;

        var m00 = m[0];
        var m01 = m[1];
        var m02 = m[2];
        var m03 = m[3];
        var m10 = m[1 * 4 + 0];
        var m11 = m[1 * 4 + 1];
        var m12 = m[1 * 4 + 2];
        var m13 = m[1 * 4 + 3];
        var m20 = m[2 * 4 + 0];
        var m21 = m[2 * 4 + 1];
        var m22 = m[2 * 4 + 2];
        var m23 = m[2 * 4 + 3];
        var m30 = m[3 * 4 + 0];
        var m31 = m[3 * 4 + 1];
        var m32 = m[3 * 4 + 2];
        var m33 = m[3 * 4 + 3];

        if (m !== dst) {
          dst[ 0] = m00;
          dst[ 1] = m01;
          dst[ 2] = m02;
          dst[ 3] = m03;
          dst[ 4] = m10;
          dst[ 5] = m11;
          dst[ 6] = m12;
          dst[ 7] = m13;
          dst[ 8] = m20;
          dst[ 9] = m21;
          dst[10] = m22;
          dst[11] = m23;
        }

        dst[12] = m00 * tx + m10 * ty + m20 * tz + m30;
        dst[13] = m01 * tx + m11 * ty + m21 * tz + m31;
        dst[14] = m02 * tx + m12 * ty + m22 * tz + m32;
        dst[15] = m03 * tx + m13 * ty + m23 * tz + m33;

        return dst;
    };
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._tranA = new Float32Array(16);
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer.prototype 
	* @method _translation
	* @param tx 
	* @param ty 
	* @param tz 
	* @param dst 
    * @returns {} 
	*/
    WebglRenderer.prototype._translation = function(tx, ty, tz, dst) {
        dst = dst || this._tranA;

        dst[ 0] = 1;
        dst[ 1] = 0;
        dst[ 2] = 0;
        dst[ 3] = 0;
        dst[ 4] = 0;
        dst[ 5] = 1;
        dst[ 6] = 0;
        dst[ 7] = 0;
        dst[ 8] = 0;
        dst[ 9] = 0;
        dst[10] = 1;
        dst[11] = 0;
        dst[12] = tx;
        dst[13] = ty;
        dst[14] = tz;
        dst[15] = 1;

        return dst;
    };
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._scA = new Float32Array(16);
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer.prototype 
	* @method _scale
	* @param m 
	* @param sx 
	* @param sy 
	* @param sz 
	* @param dst 
    * @returns {} 
	*/
    WebglRenderer.prototype._scale = function(m, sx, sy, sz, dst) {
        
        dst = dst || this._scA;

        dst[ 0] = sx * m[0 * 4 + 0];
        dst[ 1] = sx * m[0 * 4 + 1];
        dst[ 2] = sx * m[0 * 4 + 2];
        dst[ 3] = sx * m[0 * 4 + 3];
        dst[ 4] = sy * m[1 * 4 + 0];
        dst[ 5] = sy * m[1 * 4 + 1];
        dst[ 6] = sy * m[1 * 4 + 2];
        dst[ 7] = sy * m[1 * 4 + 3];
        dst[ 8] = sz * m[2 * 4 + 0];
        dst[ 9] = sz * m[2 * 4 + 1];
        dst[10] = sz * m[2 * 4 + 2];
        dst[11] = sz * m[2 * 4 + 3];

        if (m !== dst) {
          dst[12] = m[12];
          dst[13] = m[13];
          dst[14] = m[14];
          dst[15] = m[15];
        }

        return dst;
    };
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer 
	*  
	*/
    WebglRenderer.prototype._matrix = null;
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer.prototype 
	* @method copyPixels
	* @param source 
	* @param fromRect 
	* @param toMoverPoint 
	* @param copyWidth 
	* @param copyHeight 
    * @returns {} 
	*/
    WebglRenderer.prototype.copyPixels = function(source, fromRect, toMoverPoint, copyWidth, copyHeight) {
        
        if(!this._program) {
            this.readyWebglProgram();
            this._bindImageForWebglCopyPixels(source);
            this.context.bindTexture(this.context.TEXTURE_2D, this._texture);
            this.context.useProgram(this._program);
            this.context.bindBuffer(this.context.ARRAY_BUFFER, this._positionBuffer);
            this.context.enableVertexAttribArray(this._positionLocation);
            this.context.vertexAttribPointer(this._positionLocation, 2, this.context.FLOAT, false, 0, 0);
            this.context.bindBuffer(this.context.ARRAY_BUFFER, this._texcoordBuffer);
            this.context.enableVertexAttribArray(this._texcoordLocation);
            this.context.vertexAttribPointer(this._texcoordLocation, 2, this.context.FLOAT, false, 0, 0);
            this._matrix = this._orthographic(0, this.context.canvas.width, this.context.canvas.height, 0, -1, 1);
            window.console.log("cp setup");
        }
 
       // var matrix = this._orthographic(0, this.context.canvas.width, this.context.canvas.height, 0, -1, 1);

        this._matrix = this._translate(this._matrix, toMoverPoint.x, toMoverPoint.y, 0);

        this._matrix = this._scale(this._matrix, copyWidth || fromRect.width, copyHeight || fromRect.height, 1);

        this.context.uniformMatrix4fv(this._matrixLocation, false, this._matrix);

       
        var tm = this._translation(fromRect.x / this._imgWidth, fromRect.y / this._imgHeight, 0);
        tm = this._scale(tm, fromRect.width / this._imgWidth, fromRect.height / this._imgHeight, 1);

        this.context.uniformMatrix4fv(this._textureMatrixLocation, false, tm);

        this.context.uniform1i(this._textureLocation, 0);

        this.context.drawArrays(this.context.TRIANGLES, 0, 6);
        
        
    };
    
    /** 
	*   
	*    
	*    
	* @memberof WebglRenderer.prototype 
	* @method clearRect
	* @param x 
	* @param y 
	* @param width 
	* @param height 
    * @returns {} 
	*/
    WebglRenderer.prototype.clearRect = function(x,y,width,height) {
        var c = this.context || this;
        c.enable(c.SCISSOR_TEST);
        c.scissor(x,(c.canvas.height - y) - height,width,height);
        c.clearColor(0,0,0,0);
        c.clear(c.COLOR_BUFFER_BIT);
        c.disable(c.SCISSOR_TEST);
        
    };
    
    
    tabageos.WebglRenderer = WebglRenderer;
    
})();